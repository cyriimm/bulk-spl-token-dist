{"ast":null,"code":"import { MARKETS } from '@project-serum/serum';\nimport { MAINNET_URL } from './connection';\nexport const serumMarkets = (() => {\n  const m = {};\n  MARKETS.forEach(market => {\n    const coin = market.name.split('/')[0];\n\n    if (m[coin]) {\n      // Only override a market if it's not deprecated\t.\n      if (!m.deprecated) {\n        m[coin] = {\n          publicKey: market.address,\n          name: market.name.split('/').join('')\n        };\n      }\n    } else {\n      m[coin] = {\n        publicKey: market.address,\n        name: market.name.split('/').join('')\n      };\n    }\n  });\n  return m;\n})(); // Create a cached API wrapper to avoid rate limits.\n\nclass PriceStore {\n  constructor() {\n    this.cache = void 0;\n    this.cache = {};\n  }\n\n  async getPrice(connection, marketName) {\n    return new Promise((resolve, reject) => {\n      if (connection._rpcEndpoint !== MAINNET_URL) {\n        resolve(undefined);\n        return;\n      }\n\n      if (this.cache[marketName] === undefined) {\n        fetch(`https://serum-api.bonfida.com/orderbooks/${marketName}`).then(resp => {\n          resp.json().then(resp => {\n            if (resp.data.asks === null || resp.data.bids === null) {\n              resolve(undefined);\n            } else if (resp.data.asks.length === 0 && resp.data.bids.length === 0) {\n              resolve(undefined);\n            } else if (resp.data.asks.length === 0) {\n              resolve(resp.data.bids[0].price);\n            } else if (resp.data.bids.length === 0) {\n              resolve(resp.data.asks[0].price);\n            } else {\n              const mid = (resp.data.asks[0].price + resp.data.bids[0].price) / 2.0;\n              this.cache[marketName] = mid;\n              resolve(this.cache[marketName]);\n            }\n          });\n        });\n      } else {\n        return resolve(this.cache[marketName]);\n      }\n    });\n  }\n\n}\n\nexport const priceStore = new PriceStore();","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/markets.ts"],"names":["MARKETS","MAINNET_URL","serumMarkets","m","forEach","market","coin","name","split","deprecated","publicKey","address","join","PriceStore","constructor","cache","getPrice","connection","marketName","Promise","resolve","reject","_rpcEndpoint","undefined","fetch","then","resp","json","data","asks","bids","length","price","mid","priceStore"],"mappings":"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","sourcesContent":["import { MARKETS } from '@project-serum/serum';\nimport { PublicKey } from '@solana/web3.js';\nimport { MAINNET_URL } from './connection';\n\ninterface Markets {\n  [coin: string]: {\n    publicKey: PublicKey;\n    name: string;\n    deprecated?: boolean;\n  };\n}\n\nexport const serumMarkets = (() => {\n  const m: Markets = {};\n  MARKETS.forEach((market) => {\n    const coin = market.name.split('/')[0];\n    if (m[coin]) {\n      // Only override a market if it's not deprecated\t.\n      if (!m.deprecated) {\n        m[coin] = {\n          publicKey: market.address,\n          name: market.name.split('/').join(''),\n        };\n      }\n    } else {\n      m[coin] = {\n        publicKey: market.address,\n        name: market.name.split('/').join(''),\n      };\n    }\n  });\n  return m;\n})();\n\n// Create a cached API wrapper to avoid rate limits.\nclass PriceStore {\n  cache: {};\n\n  constructor() {\n    this.cache = {};\n  }\n\n  async getPrice(connection, marketName): Promise<number | undefined> {\n    return new Promise((resolve, reject) => {\n      if (connection._rpcEndpoint !== MAINNET_URL) {\n        resolve(undefined);\n        return;\n      }\n      if (this.cache[marketName] === undefined) {\n        fetch(`https://serum-api.bonfida.com/orderbooks/${marketName}`).then(\n          (resp) => {\n            resp.json().then((resp) => {\n              if (resp.data.asks === null || resp.data.bids === null) {\n                resolve(undefined);\n              } else if (\n                resp.data.asks.length === 0 &&\n                resp.data.bids.length === 0\n              ) {\n                resolve(undefined);\n              } else if (resp.data.asks.length === 0) {\n                resolve(resp.data.bids[0].price);\n              } else if (resp.data.bids.length === 0) {\n                resolve(resp.data.asks[0].price);\n              } else {\n                const mid =\n                  (resp.data.asks[0].price + resp.data.bids[0].price) / 2.0;\n                this.cache[marketName] = mid;\n                resolve(this.cache[marketName]);\n              }\n            });\n          },\n        );\n      } else {\n        return resolve(this.cache[marketName]);\n      }\n    });\n  }\n}\n\nexport const priceStore = new PriceStore();\n"]},"metadata":{},"sourceType":"module"}