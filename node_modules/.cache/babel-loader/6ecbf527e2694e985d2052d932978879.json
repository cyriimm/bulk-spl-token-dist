{"ast":null,"code":"/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n'use strict';\n\nconst assert = require('assert');\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\n\n\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n\n\n    this.span = span;\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n\n    this.property = property;\n  }\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n\n\n  makeDestinationObject() {\n    return {};\n  }\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n\n\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n\n\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n\n\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n\n    return this.span;\n  }\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n\n\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n\n\n  fromArray(values) {\n    return undefined;\n  }\n\n}\n\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\n\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n\n  return name;\n}\n\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\n\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n\n  if (!(layout && layout instanceof Layout)) {\n    throw new TypeError('layout must be a Layout');\n  }\n\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n\n  layout.makeDestinationObject = () => new Class();\n\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function (b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function (b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true\n  });\n}\n\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\n\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n\n}\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\n\n\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n\n    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n\n    super(-1, property);\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n\n    this.elementSpan = elementSpan;\n  }\n  /** @override */\n\n\n  isCount() {\n    return true;\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    return 0;\n  }\n\n}\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\n\n\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n    /** The subordinated layout. */\n\n    this.layout = layout;\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n\n    this.offset = offset;\n  }\n  /** @override */\n\n\n  isCount() {\n    return this.layout instanceof UInt || this.layout instanceof UIntBE;\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return this.layout.decode(b, offset + this.offset);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n\n}\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readUIntLE(offset, this.span);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n\n}\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readUIntBE(offset, this.span);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n\n}\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readIntLE(offset, this.span);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n\n}\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readIntBE(offset, this.span);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n\n}\n\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\n\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - hi32 * V2E32; // assert.equal(roundedInt64(hi32, lo32), src);\n  // assert(0 <= lo32);\n\n  return {\n    hi32,\n    lo32\n  };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\n\n\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\n\n\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n\n}\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\n\n\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n\n}\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\n\n\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n\n}\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\n\n\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n\n}\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readFloatLE(offset);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n\n}\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readFloatBE(offset);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n\n}\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readDoubleLE(offset);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n\n}\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.readDoubleBE(offset);\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n\n}\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n\n    if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n      throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n\n    if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n    /** The layout for individual elements of the sequence. */\n\n    this.elementLayout = elementLayout;\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n\n    this.count = count;\n  }\n  /** @override */\n\n\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let span = 0;\n    let count = this.count;\n\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n\n    return span;\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n\n    return rv;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n\n    return span;\n  }\n\n}\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\n\n\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n\n    if ('boolean' === typeof property && undefined === decodePrefixes) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n    /* Verify absence of unnamed variable-length fields. */\n\n\n    for (const fd of fields) {\n      if (0 > fd.span && undefined === fd.property) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {}\n\n    super(span, property);\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n\n    this.fields = fields;\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n\n    this.decodePrefixes = !!decodePrefixes;\n  }\n  /** @override */\n\n\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let span = 0;\n\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n\n    return span;\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const dest = this.makeDestinationObject();\n\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n\n      offset += fd.getSpan(b, offset);\n\n      if (this.decodePrefixes && b.length === offset) {\n        break;\n      }\n    }\n\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = 0 < span ? span : 0;\n\n      if (undefined === fd.property) {\n        /* By construction the field must be fixed-length (because\n         * unnamed variable-length fields are disallowed when\n         * encoding).  But check it anyway. */\n        assert(0 < span);\n      } else {\n        const fv = src[fd.property];\n\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n\n\n    return lastOffset + lastWrote - firstOffset;\n  }\n  /** @override */\n\n\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n\n    for (const fd of this.fields) {\n      if (undefined !== fd.property && 0 < values.length) {\n        dest[fd.property] = values.shift();\n      }\n    }\n\n    return dest;\n  }\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n\n\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n\n\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n\n    let offset = 0;\n\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n\n}\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\n\n\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n\n\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n\n\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n}\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\n\n\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!(layout instanceof ExternalLayout && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n\n    this.layout = layout;\n  }\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n\n\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n\n\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n\n}\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = discr instanceof UInt || discr instanceof UIntBE;\n\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if (discr instanceof ExternalLayout && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');\n    }\n\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n\n    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n\n\n    let span = -1;\n\n    if (defaultLayout) {\n      span = defaultLayout.span;\n\n      if (0 <= span && upv) {\n        span += discr.layout.span;\n      }\n    }\n\n    super(span, property);\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n\n    this.discriminator = discr;\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n\n    this.usesPrefixDiscriminator = upv;\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n\n    this.defaultLayout = defaultLayout;\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n\n    this.registry = {};\n    /* Private variable used when invoking getSourceVariant */\n\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n\n    this.getSourceVariant = function (src) {\n      return boundGetSourceVariant(src);\n    };\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n\n\n    this.configGetSourceVariant = function (gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n  /** @override */\n\n\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n\n\n    const vlo = this.getVariant(b, offset);\n\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n\n    return vlo.getSpan(b, offset);\n  }\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n\n\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n\n      const vlo = this.registry[src[this.discriminator.property]];\n\n      if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n\n    throw new Error('unable to infer src variant');\n  }\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const vlo = this.getSourceVariant(src);\n\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n    }\n\n    return vlo.encode(src, b, offset);\n  }\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n\n\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n\n\n  getVariant(vb, offset) {\n    let variant = vb;\n\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n\n      variant = this.discriminator.decode(vb, offset);\n    }\n\n    return this.registry[variant];\n  }\n\n}\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\n\n\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n\n    if (!Number.isInteger(variant) || 0 > variant) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n\n    if ('string' === typeof layout && undefined === property) {\n      property = layout;\n      layout = null;\n    }\n\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n\n      if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n\n    let span = union.span;\n\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n\n      if (0 <= span && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n\n    super(span, property);\n    /** The {@link Union} to which this variant belongs. */\n\n    this.union = union;\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n\n    this.variant = variant;\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n\n    this.layout = layout || null;\n  }\n  /** @override */\n\n\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let contentOffset = 0;\n\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n\n\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n\n    let contentOffset = 0;\n\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n\n    return dest;\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let contentOffset = 0;\n\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n\n    if (this.layout && !src.hasOwnProperty(this.property)) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n\n      if (0 <= this.union.span && span > this.union.span) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n\n    return span;\n  }\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n\n\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n\n}\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\n\n\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n\n  return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!(word instanceof UInt || word instanceof UIntBE)) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n\n    if ('string' === typeof msb && undefined === property) {\n      property = msb;\n      msb = undefined;\n    }\n\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n\n    super(word.span, property);\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n\n    this.word = word;\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n\n    this.msb = !!msb;\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n\n    this.fields = [];\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n\n    let value = 0;\n\n    this._packedSetValue = function (v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n\n    this._packedGetValue = function () {\n      return value;\n    };\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const value = this.word.decode(b, offset);\n\n    this._packedSetValue(value);\n\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    const value = this.word.decode(b, offset);\n\n    this._packedSetValue(value);\n\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n\n\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n\n\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n\n\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n}\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\n\n\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n\n    if (!Number.isInteger(bits) || 0 >= bits) {\n      throw new TypeError('bits must be positive integer');\n    }\n\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n\n    if (bits + usedBits > totalBits) {\n      throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');\n    }\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n\n\n    this.container = container;\n    /** The span of this value in bits. */\n\n    this.bits = bits;\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n\n    this.valueMask = (1 << bits) - 1;\n\n    if (32 === bits) {\n      // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n\n\n    this.start = usedBits;\n\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n\n\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n\n    this.property = property;\n  }\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n\n\n  decode() {\n    const word = this.container._packedGetValue();\n\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n\n\n  encode(value) {\n    if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n      throw new TypeError(nameWithProperty('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);\n    }\n\n    const word = this.container._packedGetValue();\n\n    const wordValue = fixBitwiseResult(value << this.start);\n\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n  }\n\n}\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n\n/* eslint-disable no-extend-native */\n\n\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n\n\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n  /** @override */\n\n\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n\n    return BitField.prototype.encode.call(this, value);\n  }\n\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n      throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n\n    super(span, property);\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n\n    this.length = length;\n  }\n  /** @override */\n\n\n  getSpan(b, offset) {\n    let span = this.span;\n\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n\n    return span;\n  }\n  /** @override */\n\n\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let span = this.span;\n\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n\n    return b.slice(offset, offset + span);\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n\n\n  encode(src, b, offset) {\n    let span = this.length;\n\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n\n    if (!(Buffer.isBuffer(src) && span === src.length)) {\n      throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Buffer as src');\n    }\n\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n\n    b.write(src.toString('hex'), offset, span, 'hex');\n\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n\n    return span;\n  }\n\n}\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n  /** @override */\n\n\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let idx = offset;\n\n    while (idx < b.length && 0 !== b[idx]) {\n      idx += 1;\n    }\n\n    return 1 + idx - offset;\n  }\n  /** @override */\n\n\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n\n\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n\n}\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if ('string' === typeof maxSpan && undefined === property) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n\n    this.maxSpan = maxSpan;\n  }\n  /** @override */\n\n\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    return b.length - offset;\n  }\n  /** @override */\n\n\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n\n    let span = this.getSpan(b, offset);\n\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n\n\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n\n    srcb.copy(b, offset);\n    return span;\n  }\n\n}\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\n\n\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n\n    this.value = value;\n  }\n  /** @override */\n\n\n  decode(b, offset, dest) {\n    return this.value;\n  }\n  /** @override */\n\n\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n\n}\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\n\nexports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */\n\n\nexports.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\n\n\nexports.u8 = property => new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\n\n\nexports.u16 = property => new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\n\n\nexports.u24 = property => new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\n\n\nexports.u32 = property => new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\n\n\nexports.u40 = property => new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\n\n\nexports.u48 = property => new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\n\n\nexports.nu64 = property => new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\n\n\nexports.u16be = property => new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\n\n\nexports.u24be = property => new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\n\n\nexports.u32be = property => new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\n\n\nexports.u40be = property => new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\n\n\nexports.u48be = property => new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\n\n\nexports.nu64be = property => new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\n\n\nexports.s8 = property => new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\n\n\nexports.s16 = property => new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\n\n\nexports.s24 = property => new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\n\n\nexports.s32 = property => new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\n\n\nexports.s40 = property => new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\n\n\nexports.s48 = property => new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\n\n\nexports.ns64 = property => new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\n\n\nexports.s16be = property => new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\n\n\nexports.s24be = property => new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\n\n\nexports.s32be = property => new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\n\n\nexports.s40be = property => new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\n\n\nexports.s48be = property => new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\n\n\nexports.ns64be = property => new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\n\n\nexports.f32 = property => new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\n\n\nexports.f32be = property => new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\n\n\nexports.f64 = property => new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\n\n\nexports.f64be = property => new DoubleBE(property);\n/** Factory for {@link Structure} values. */\n\n\nexports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */\n\n\nexports.bits = (word, msb, property) => new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */\n\n\nexports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */\n\n\nexports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */\n\n\nexports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */\n\n\nexports.blob = (length, property) => new Blob(length, property);\n/** Factory for {@link CString} values. */\n\n\nexports.cstr = property => new CString(property);\n/** Factory for {@link UTF8} values. */\n\n\nexports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */\n\n\nexports.const = (value, property) => new Constant(value, property);","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/node_modules/buffer-layout/lib/Layout.js"],"names":["assert","require","Layout","constructor","span","property","Number","isInteger","TypeError","makeDestinationObject","decode","b","offset","Error","encode","src","getSpan","RangeError","replicate","rv","Object","create","prototype","assign","fromArray","values","undefined","exports","nameWithProperty","name","lo","bindConstructorLayout","Class","layout","hasOwnProperty","layout_","boundConstructor_","defineProperty","value","writable","ExternalLayout","isCount","GreedyCount","elementSpan","rem","length","Math","floor","OffsetLayout","UInt","UIntBE","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","Int","readIntLE","writeIntLE","IntBE","readIntBE","writeIntBE","V2E32","pow","divmodInt64","hi32","lo32","roundedInt64","NearUInt64","readUInt32LE","split","writeUInt32LE","NearUInt64BE","readUInt32BE","writeUInt32BE","NearInt64","readInt32LE","writeInt32LE","NearInt64BE","readInt32BE","writeInt32BE","Float","readFloatLE","writeFloatLE","FloatBE","readFloatBE","writeFloatBE","Double","readDoubleLE","writeDoubleLE","DoubleBE","readDoubleBE","writeDoubleBE","Sequence","elementLayout","count","idx","i","push","elo","reduce","v","Structure","fields","decodePrefixes","Array","isArray","acc","fd","e","fsp","dest","firstOffset","lastOffset","lastWrote","fv","shift","layoutFor","offsetOf","UnionDiscriminator","UnionLayoutDiscriminator","Union","discr","defaultLayout","upv","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","VariantLayout","vb","Buffer","isBuffer","union","fixBitwiseResult","BitStructure","word","msb","_packedSetValue","_packedGetValue","addField","bits","bf","BitField","addBoolean","Boolean","fieldFor","container","totalBits","usedBits","sum","valueMask","start","wordMask","wordValue","call","Blob","slice","write","toString","CString","srcb","copy","UTF8","maxSpan","Constant","greedy","u8","u16","u24","u32","u40","u48","nu64","u16be","u24be","u32be","u40be","u48be","nu64be","s8","s16","s24","s32","s40","s48","ns64","s16be","s24be","s32be","s40be","s48be","ns64be","f32","f32be","f64","f64be","struct","seq","unionLayoutDiscriminator","blob","cstr","utf8","const"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,MAAN,CAAa;AACXC,EAAAA,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiB;AAC1B,QAAI,CAACC,MAAM,CAACC,SAAP,CAAiBH,IAAjB,CAAL,EAA6B;AAC3B,YAAM,IAAII,SAAJ,CAAc,yBAAd,CAAN;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,SAAKJ,IAAL,GAAYA,IAAZ;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,SAAKC,QAAL,GAAgBA,QAAhB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEI,EAAAA,qBAAqB,GAAG;AACtB,WAAO,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,MAAM,CAACC,CAAD,EAAIC,MAAJ,EAAY;AAChB,UAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,EAAAA,MAAM,CAACC,GAAD,EAAMJ,CAAN,EAASC,MAAT,EAAiB;AACrB,UAAM,IAAIC,KAAJ,CAAU,oBAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEG,EAAAA,OAAO,CAACL,CAAD,EAAIC,MAAJ,EAAY;AACjB,QAAI,IAAI,KAAKR,IAAb,EAAmB;AACjB,YAAM,IAAIa,UAAJ,CAAe,oBAAf,CAAN;AACD;;AACD,WAAO,KAAKb,IAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEc,EAAAA,SAAS,CAACb,QAAD,EAAW;AAClB,UAAMc,EAAE,GAAGC,MAAM,CAACC,MAAP,CAAc,KAAKlB,WAAL,CAAiBmB,SAA/B,CAAX;AACAF,IAAAA,MAAM,CAACG,MAAP,CAAcJ,EAAd,EAAkB,IAAlB;AACAA,IAAAA,EAAE,CAACd,QAAH,GAAcA,QAAd;AACA,WAAOc,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEK,EAAAA,SAAS,CAACC,MAAD,EAAS;AAChB,WAAOC,SAAP;AACD;;AA7JU;;AA+JbC,OAAO,CAACzB,MAAR,GAAiBA,MAAjB;AAEA;AACA;AACA;AACA;AACA;;AACA,SAAS0B,gBAAT,CAA0BC,IAA1B,EAAgCC,EAAhC,EAAoC;AAClC,MAAIA,E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","sourcesContent":["/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\n'use strict';\n\nconst assert = require('assert');\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Class.hasOwnProperty('layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && (layout instanceof Layout))) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (layout.hasOwnProperty('boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = (() => new Class());\n  Object.defineProperty(Class.prototype, 'encode', {\n    value: function(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true,\n  });\n  Object.defineProperty(Class, 'decode', {\n    value: function(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true,\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan, property) {\n    if (undefined === elementSpan) {\n      elementSpan = 1;\n    }\n    if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n\n  /** @override */\n  isCount() {\n    return true;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  // assert.equal(roundedInt64(hi32, lo32), src);\n  // assert(0 <= lo32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readUInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const hi32 = b.readInt32BE(offset);\n    const lo32 = b.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeInt32BE(split.hi32, offset);\n    b.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatLE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readFloatBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeFloatBE(src, offset);\n    return 4;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleLE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleLE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readDoubleBE(offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeDoubleBE(src, offset);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(((count instanceof ExternalLayout) && count.isCount())\n          || (Number.isInteger(count) && (0 <= count)))) {\n      throw new TypeError('count must be non-negative integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if ((!(count instanceof ExternalLayout))\n        && (0 < elementLayout.span)) {\n      span = count * elementLayout.span;\n    }\n\n    super(span, property);\n\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined === fd.property) {\n        /* By construction the field must be fixed-length (because\n         * unnamed variable-length fields are disallowed when\n         * encoding).  But check it anyway. */\n        assert(0 < span);\n      } else {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!((word instanceof UInt)\n          || (word instanceof UIntBE))) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if (('string' === typeof msb)\n        && (undefined === property)) {\n      property = msb;\n      msb = undefined;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function(v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function() {\n      return value;\n    };\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(value);\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    // eslint-disable-next-line no-new-wrappers\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n}\n\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if ((!Number.isInteger(bits)) || (0 >= bits)) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if ((bits + usedBits) > totalBits) {\n      throw new Error('bits too long for span remainder ('\n                      + (totalBits - usedBits) + ' of '\n                      + totalBits + ' remain)');\n    }\n\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n\n    /** The span of this value in bits. */\n    this.bits = bits;\n\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) { // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode() {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ((!Number.isInteger(value))\n        || (value !== fixBitwiseResult(value & this.valueMask))) {\n      throw new TypeError(nameWithProperty('BitField.encode', this)\n                          + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n                                   | wordValue);\n  };\n}\n\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!BitField.prototype.decode.call(this, b, offset);\n  }\n\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    return BitField.prototype.encode.call(this, value);\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let idx = offset;\n    while ((idx < b.length) && (0 !== b[idx])) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    return b.slice(offset, offset + span - 1).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    b[offset + span] = 0;\n    return span + 1;\n  }\n}\n\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if (('string' === typeof maxSpan)\n        && (undefined === property)) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n\n    super(-1, property);\n\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (!Buffer.isBuffer(b)) {\n      throw new TypeError('b must be a Buffer');\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.length - offset;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.getSpan(b, offset);\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return b.slice(offset, offset + span).toString('utf-8');\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = src.toString();\n    }\n    const srcb = new Buffer(src, 'utf8');\n    const span = srcb.length;\n    if ((0 <= this.maxSpan)\n        && (this.maxSpan < span)) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(b, offset);\n    return span;\n  }\n}\n\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n\n  /** @override */\n  decode(b, offset, dest) {\n    return this.value;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\n\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = (property => new UInt(2, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = (property => new UInt(3, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = (property => new UInt(4, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = (property => new UInt(5, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = (property => new UInt(6, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = (property => new UIntBE(2, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = (property => new UIntBE(3, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = (property => new UIntBE(4, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = (property => new UIntBE(5, property));\n\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = (property => new UIntBE(6, property));\n\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = (property => new NearUInt64BE(property));\n\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = (property => new Int(1, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = (property => new Int(2, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = (property => new Int(3, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = (property => new Int(4, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = (property => new Int(5, property));\n\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = (property => new Int(6, property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = (property => new IntBE(2, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = (property => new IntBE(3, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = (property => new IntBE(4, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = (property => new IntBE(5, property));\n\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = (property => new IntBE(6, property));\n\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = (property => new NearInt64BE(property));\n\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = (property => new Float(property));\n\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = (property => new FloatBE(property));\n\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = (property => new Double(property));\n\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = (property => new DoubleBE(property));\n\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n\n/** Factory for {@link CString} values. */\nexports.cstr = (property => new CString(property));\n\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n\n/** Factory for {@link Constant} values. */\nexports.const = ((value, property) => new Constant(value, property));\n"]},"metadata":{},"sourceType":"script"}