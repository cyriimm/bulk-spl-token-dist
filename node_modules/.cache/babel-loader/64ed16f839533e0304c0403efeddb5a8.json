{"ast":null,"code":"var _jsxFileName = \"/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/connection.tsx\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$();\n\nimport React, { useContext, useEffect, useMemo } from 'react';\nimport { clusterApiUrl, Connection, PublicKey } from '@solana/web3.js';\nimport tuple from 'immutable-tuple';\nimport { struct } from 'superstruct';\nimport assert from 'assert';\nimport { useLocalStorageState, useRefEqual } from './utils';\nimport { refreshCache, setCache, useAsyncData } from './fetch-loop';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ConnectionContext = /*#__PURE__*/React.createContext(null);\nexport const MAINNET_URL = 'https://api.mainnet-beta.solana.com';\nexport function ConnectionProvider({\n  children\n}) {\n  _s();\n\n  const [endpoint, setEndpoint] = useLocalStorageState('connectionEndpoint', MAINNET_URL);\n  const connection = useMemo(() => new Connection(endpoint, 'recent'), [endpoint]);\n  return /*#__PURE__*/_jsxDEV(ConnectionContext.Provider, {\n    value: {\n      endpoint,\n      setEndpoint,\n      connection\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 32,\n    columnNumber: 5\n  }, this);\n}\n\n_s(ConnectionProvider, \"hPH+wZkp+18st19deLu1UmZhJL8=\", false, function () {\n  return [useLocalStorageState];\n});\n\n_c = ConnectionProvider;\nexport function useConnection() {\n  _s2();\n\n  let context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return context.connection;\n}\n\n_s2(useConnection, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nexport function useConnectionConfig() {\n  _s3();\n\n  let context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return {\n    endpoint: context.endpoint,\n    setEndpoint: context.setEndpoint\n  };\n}\n\n_s3(useConnectionConfig, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nexport function useIsProdNetwork() {\n  _s4();\n\n  let context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return context.endpoint === MAINNET_URL;\n}\n\n_s4(useIsProdNetwork, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nexport function useSolanaExplorerUrlSuffix() {\n  _s5();\n\n  const context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  const endpoint = context.endpoint;\n\n  if (endpoint === clusterApiUrl('devnet')) {\n    return '?cluster=devnet';\n  } else if (endpoint === clusterApiUrl('testnet')) {\n    return '?cluster=testnet';\n  }\n\n  return '';\n}\n\n_s5(useSolanaExplorerUrlSuffix, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n\nexport function useAccountInfo(publicKey) {\n  _s6();\n\n  var _publicKey$toBase;\n\n  const connection = useConnection();\n  const cacheKey = tuple(connection, publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58());\n  const [accountInfo, loaded] = useAsyncData(async () => publicKey ? connection.getAccountInfo(publicKey) : null, cacheKey);\n  useEffect(() => {\n    if (!publicKey) {\n      console.log('! public key', publicKey);\n      return;\n    }\n\n    let previousInfo = null;\n    const id = connection.onAccountChange(publicKey, info => {\n      if (!previousInfo || !previousInfo.data.equals(info.data) || previousInfo.lamports !== info.lamports) {\n        previousInfo = info;\n        setCache(cacheKey, info);\n      }\n    });\n    return () => {\n      connection.removeAccountChangeListener(id);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [connection, (_publicKey$toBase = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()) !== null && _publicKey$toBase !== void 0 ? _publicKey$toBase : '', cacheKey]);\n  return [useRefEqual(accountInfo, (oldInfo, newInfo) => !!oldInfo && !!newInfo && oldInfo.data.equals(newInfo.data) && oldInfo.lamports === newInfo.lamports), loaded];\n}\n\n_s6(useAccountInfo, \"paX3kKSrquYvLDQGt8ef/AMEeY0=\", false, function () {\n  return [useConnection, useAsyncData, useRefEqual];\n});\n\nexport function refreshAccountInfo(connection, publicKey, clearCache = false) {\n  const cacheKey = tuple(connection, publicKey.toBase58());\n  refreshCache(cacheKey, clearCache);\n}\nexport function setInitialAccountInfo(connection, publicKey, accountInfo) {\n  const cacheKey = tuple(connection, publicKey.toBase58());\n  setCache(cacheKey, accountInfo, {\n    initializeOnly: true\n  });\n}\nexport async function getMultipleSolanaAccounts(connection, publicKeys) {\n  const args = [publicKeys.map(k => k.toBase58()), {\n    commitment: 'recent'\n  }]; // @ts-ignore\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  const res = GetMultipleAccountsAndContextRpcResult(unsafeRes);\n\n  if (res.error) {\n    throw new Error('failed to get info about accounts ' + publicKeys.map(k => k.toBase58()).join(', ') + ': ' + res.error.message);\n  }\n\n  assert(typeof res.result !== 'undefined');\n  const accounts = [];\n\n  for (const account of res.result.value) {\n    let value = null;\n\n    if (res.result.value && account) {\n      const {\n        executable,\n        owner,\n        lamports,\n        data\n      } = account;\n      assert(data[1] === 'base64');\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], 'base64')\n      };\n    }\n\n    accounts.push(value);\n  }\n\n  return accounts.map((account, idx) => {\n    return account === null ? null : {\n      publicKey: publicKeys[idx],\n      account\n    };\n  });\n}\n\nfunction jsonRpcResult(resultDescription) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([struct({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'any'\n  }), struct({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'null?',\n    result: resultDescription\n  })]);\n}\n\nfunction jsonRpcResultAndContext(resultDescription) {\n  return jsonRpcResult({\n    context: struct({\n      slot: 'number'\n    }),\n    value: resultDescription\n  });\n}\n\nconst AccountInfoResult = struct({\n  executable: 'boolean',\n  owner: 'string',\n  lamports: 'number',\n  data: 'any',\n  rentEpoch: 'number?'\n});\nexport const GetMultipleAccountsAndContextRpcResult = jsonRpcResultAndContext(struct.array([struct.union(['null', AccountInfoResult])]));\n\nvar _c;\n\n$RefreshReg$(_c, \"ConnectionProvider\");","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/connection.tsx"],"names":["React","useContext","useEffect","useMemo","clusterApiUrl","Connection","PublicKey","tuple","struct","assert","useLocalStorageState","useRefEqual","refreshCache","setCache","useAsyncData","ConnectionContext","createContext","MAINNET_URL","ConnectionProvider","children","endpoint","setEndpoint","connection","useConnection","context","Error","useConnectionConfig","useIsProdNetwork","useSolanaExplorerUrlSuffix","useAccountInfo","publicKey","cacheKey","toBase58","accountInfo","loaded","getAccountInfo","console","log","previousInfo","id","onAccountChange","info","data","equals","lamports","removeAccountChangeListener","oldInfo","newInfo","refreshAccountInfo","clearCache","setInitialAccountInfo","initializeOnly","getMultipleSolanaAccounts","publicKeys","args","map","k","commitment","unsafeRes","_rpcRequest","res","GetMultipleAccountsAndContextRpcResult","error","join","message","result","accounts","account","value","executable","owner","Buffer","from","push","idx","jsonRpcResult","resultDescription","jsonRpcVersion","literal","union","jsonrpc","jsonRpcResultAndContext","slot","AccountInfoResult","rentEpoch","array"],"mappings":"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","sourcesContent":["import React, { useContext, useEffect, useMemo } from 'react';\nimport {\n  AccountInfo,\n  clusterApiUrl,\n  Connection,\n  PublicKey,\n} from '@solana/web3.js';\nimport tuple from 'immutable-tuple';\nimport { struct } from 'superstruct';\nimport assert from 'assert';\nimport { useLocalStorageState, useRefEqual } from './utils';\nimport { refreshCache, setCache, useAsyncData } from './fetch-loop';\n\nexport const ConnectionContext = React.createContext<{\n  endpoint: string;\n  setEndpoint: (string) => void;\n  connection: Connection;\n} | null>(null);\n\nexport const MAINNET_URL = 'https://api.mainnet-beta.solana.com';\nexport function ConnectionProvider({ children }) {\n  const [endpoint, setEndpoint] = useLocalStorageState(\n    'connectionEndpoint',\n    MAINNET_URL,\n  );\n\n  const connection = useMemo(() => new Connection(endpoint, 'recent'), [\n    endpoint,\n  ]);\n\n  return (\n    <ConnectionContext.Provider value={{ endpoint, setEndpoint, connection }}>\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection(): Connection {\n  let context = useContext(ConnectionContext);\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n  return context.connection;\n}\n\nexport function useConnectionConfig() {\n  let context = useContext(ConnectionContext);\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n  return { endpoint: context.endpoint, setEndpoint: context.setEndpoint };\n}\n\nexport function useIsProdNetwork() {\n  let context = useContext(ConnectionContext);\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n  return context.endpoint === MAINNET_URL;\n}\n\nexport function useSolanaExplorerUrlSuffix() {\n  const context = useContext(ConnectionContext);\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n  const endpoint = context.endpoint;\n  if (endpoint === clusterApiUrl('devnet')) {\n    return '?cluster=devnet';\n  } else if (endpoint === clusterApiUrl('testnet')) {\n    return '?cluster=testnet';\n  }\n  return '';\n}\n\nexport function useAccountInfo(publicKey?: PublicKey) {\n  const connection = useConnection();\n  const cacheKey = tuple(connection, publicKey?.toBase58());\n  const [accountInfo, loaded] = useAsyncData(\n    async () => (publicKey ? connection.getAccountInfo(publicKey) : null),\n    cacheKey,\n  );\n  useEffect(() => {\n    if (!publicKey) {\n      console.log('! public key', publicKey);\n      return;\n    }\n    let previousInfo: AccountInfo<Buffer> | null = null;\n    const id = connection.onAccountChange(publicKey, (info) => {\n      if (\n        !previousInfo ||\n        !previousInfo.data.equals(info.data) ||\n        previousInfo.lamports !== info.lamports\n      ) {\n        previousInfo = info;\n        setCache(cacheKey, info);\n      }\n    });\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [connection, publicKey?.toBase58() ?? '', cacheKey]);\n  return [\n    useRefEqual(\n      accountInfo,\n      (oldInfo, newInfo) =>\n        !!oldInfo &&\n        !!newInfo &&\n        oldInfo.data.equals(newInfo.data) &&\n        oldInfo.lamports === newInfo.lamports,\n    ),\n    loaded,\n  ];\n}\n\nexport function refreshAccountInfo(connection, publicKey, clearCache = false) {\n  const cacheKey = tuple(connection, publicKey.toBase58());\n  refreshCache(cacheKey, clearCache);\n}\n\nexport function setInitialAccountInfo(connection, publicKey, accountInfo) {\n  const cacheKey = tuple(connection, publicKey.toBase58());\n  setCache(cacheKey, accountInfo, { initializeOnly: true });\n}\n\nexport async function getMultipleSolanaAccounts(\n  connection: Connection,\n  publicKeys: PublicKey[],\n): Promise<\n  Array<null | { publicKey: PublicKey; account: AccountInfo<Buffer> }>\n> {\n  const args = [publicKeys.map((k) => k.toBase58()), { commitment: 'recent' }];\n  // @ts-ignore\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  const res = GetMultipleAccountsAndContextRpcResult(unsafeRes);\n  if (res.error) {\n    throw new Error(\n      'failed to get info about accounts ' +\n        publicKeys.map((k) => k.toBase58()).join(', ') +\n        ': ' +\n        res.error.message,\n    );\n  }\n  assert(typeof res.result !== 'undefined');\n  const accounts: Array<null | {\n    executable: any;\n    owner: PublicKey;\n    lamports: any;\n    data: Buffer;\n  }> = [];\n  for (const account of res.result.value) {\n    let value: {\n      executable: any;\n      owner: PublicKey;\n      lamports: any;\n      data: Buffer;\n    } | null = null;\n    if (res.result.value && account) {\n      const { executable, owner, lamports, data } = account;\n      assert(data[1] === 'base64');\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], 'base64'),\n      };\n    }\n    accounts.push(value);\n  }\n  return accounts.map((account, idx) => {\n    return account === null\n      ? null\n      : {\n          publicKey: publicKeys[idx],\n          account,\n        };\n  });\n}\n\nfunction jsonRpcResult(resultDescription: any) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'any',\n    }),\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'null?',\n      result: resultDescription,\n    }),\n  ]);\n}\n\nfunction jsonRpcResultAndContext(resultDescription: any) {\n  return jsonRpcResult({\n    context: struct({\n      slot: 'number',\n    }),\n    value: resultDescription,\n  });\n}\n\nconst AccountInfoResult = struct({\n  executable: 'boolean',\n  owner: 'string',\n  lamports: 'number',\n  data: 'any',\n  rentEpoch: 'number?',\n});\n\nexport const GetMultipleAccountsAndContextRpcResult = jsonRpcResultAndContext(\n  struct.array([struct.union(['null', AccountInfoResult])]),\n);\n"]},"metadata":{},"sourceType":"module"}