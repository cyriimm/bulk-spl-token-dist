{"ast":null,"code":"var _jsxFileName = \"/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/components/MergeAccountsDialog.js\",\n    _s = $RefreshSig$();\n\nimport { useState } from 'react';\nimport { useSnackbar } from 'notistack';\nimport Button from '@material-ui/core/Button';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport Link from '@material-ui/core/Link';\nimport TextField from '@material-ui/core/TextField';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport FingerprintIcon from '@material-ui/icons/Fingerprint';\nimport { TokenInstructions } from '@project-serum/serum';\nimport { useWalletPublicKeys } from '../utils/wallet';\nimport { useConnection, refreshAccountInfo, getMultipleSolanaAccounts } from '../utils/connection';\nimport { parseTokenAccountData } from '../utils/tokens/data';\nimport { refreshWalletPublicKeys, useWallet } from '../utils/wallet';\nimport { createAssociatedTokenAccount, findAssociatedTokenAddress } from '../utils/tokens';\nimport { sleep } from '../utils/utils';\nimport { useTokenInfos, getTokenInfo } from '../utils/tokens/names';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function MergeAccountsDialog({\n  open,\n  onClose\n}) {\n  _s();\n\n  const [publicKeys] = useWalletPublicKeys();\n  const connection = useConnection();\n  const wallet = useWallet();\n  const {\n    enqueueSnackbar\n  } = useSnackbar();\n  const [isMerging, setIsMerging] = useState(false);\n  const [mergeCheck, setMergeCheck] = useState('');\n  const tokenInfos = useTokenInfos(); // Merging accounts is a destructive operation that, for each mint,\n  //\n  // * Creates an associated token account, if not already created\n  // * Moves all funds into the associated token account\n  // * Closes every account, excluding the associated token account.\n  //\n  // Although it's ok if this operation fails--since the user can just\n  // retry again--it's not a good experience; hence the retry logic.\n  // The retry count of 30 is arbitrary and probably overly conservative.\n\n  const mergeAccounts = async (retryCount = 30) => {\n    try {\n      if (retryCount === 0) {\n        enqueueSnackbar(`Unable to complete merge. Please try again.`, {\n          variant: 'error'\n        });\n        return;\n      } // Fetch all token accounts owned by the wallet. An account is null\n      // if we previously sent the close transaction, but did not receive\n      // a response due to RPC node instability.\n\n\n      const tokenAccounts = (await getMultipleSolanaAccounts(connection, publicKeys)).filter(acc => acc !== null && acc.account.owner.equals(TokenInstructions.TOKEN_PROGRAM_ID)).map(({\n        publicKey,\n        account\n      }) => {\n        return {\n          publicKey,\n          account: parseTokenAccountData(account.data),\n          owner: account.owner\n        };\n      }); // Group the token accounts by mint.\n\n      const groupedTokenAccounts = {};\n      tokenAccounts.forEach(ta => {\n        const key = ta.account.mint.toString();\n\n        if (groupedTokenAccounts[key]) {\n          groupedTokenAccounts[key].push(ta);\n        } else {\n          groupedTokenAccounts[key] = [ta];\n        }\n      }); // For each mint, merge them into one, associated token account.\n\n      const mints = Object.keys(groupedTokenAccounts);\n\n      for (let k = 0; k < mints.length; k += 1) {\n        const mintGroup = groupedTokenAccounts[mints[k]];\n\n        if (mintGroup.length > 0) {\n          const mint = mintGroup[0].account.mint;\n          const assocTokAddr = await findAssociatedTokenAddress(wallet.publicKey, mint); // Don't merge if the only account is the associated token address.\n\n          if (!(mintGroup.length === 1 && assocTokAddr.equals(mintGroup[0].publicKey))) {\n            const tokenInfo = getTokenInfo(mint, connection._rpcEndpoint, tokenInfos);\n            const symbol = tokenInfo.symbol ? tokenInfo.symbol : mint.toString();\n            console.log(`Merging ${symbol}`);\n            enqueueSnackbar(`Merging ${symbol}`, {\n              variant: 'info'\n            });\n            await mergeMint(assocTokAddr, mintGroup, mint, tokenInfo.decimals, wallet, connection, enqueueSnackbar);\n          }\n        }\n      } // Wait to give the RPC nodes some time to catch up.\n\n\n      await sleep(5000); // Refresh the UI to remove any duplicates.\n\n      await refresh(wallet, publicKeys); // Exit dialogue.\n\n      close();\n    } catch (err) {\n      console.error('There was a problem merging accounts', err);\n      enqueueSnackbar('Could not confirm transaction. Please wait.', {\n        variant: 'info'\n      }); // Sleep to give the RPC nodes some time to catch up.\n\n      await sleep(10000);\n      enqueueSnackbar('Retrying merge', {\n        variant: 'info'\n      });\n      await mergeAccounts(retryCount - 1);\n    }\n  };\n\n  const close = () => {\n    setMergeCheck('');\n    onClose();\n  };\n\n  const disabled = mergeCheck.toLowerCase() !== 'merge';\n  return /*#__PURE__*/_jsxDEV(Dialog, {\n    disableBackdropClick: isMerging,\n    open: open,\n    onClose: onClose,\n    children: isMerging ? /*#__PURE__*/_jsxDEV(DialogContent, {\n      children: [/*#__PURE__*/_jsxDEV(DialogContentText, {\n        style: {\n          marginBottom: 0,\n          textAlign: 'center'\n        },\n        children: \"Merging Accounts\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          display: 'flex',\n          justifyContent: 'center',\n          padding: '24px'\n        },\n        children: /*#__PURE__*/_jsxDEV(CircularProgress, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 168,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 161,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(DialogTitle, {\n        children: \"Are you sure you want to merge tokens?\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 173,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(DialogContent, {\n        children: [/*#__PURE__*/_jsxDEV(DialogContentText, {\n          children: [/*#__PURE__*/_jsxDEV(\"b\", {\n            children: \"WARNING\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 176,\n            columnNumber: 15\n          }, this), \": This action may break apps that depend on your existing token accounts.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(DialogContentText, {\n          children: [\"Merging sends all tokens to\", ' ', /*#__PURE__*/_jsxDEV(Link, {\n            href: 'https://spl.solana.com/associated-token-account',\n            target: \"_blank\",\n            rel: \"noopener\",\n            children: \"associated token accounts\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 181,\n            columnNumber: 15\n          }, this), ' ', /*#__PURE__*/_jsxDEV(FingerprintIcon, {\n            style: {\n              marginBottom: '-7px'\n            }\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 188,\n            columnNumber: 15\n          }, this), \". If associated token accounts do not exist, then they will be created.\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 179,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(DialogContentText, {\n          children: \"If merging fails during a period of high network load, you will not have lost your funds. Just recontinue the merge from where you left off. If you have a lot of accounts, merging might take a while.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 191,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(TextField, {\n          label: `Please type \"merge\" to confirm`,\n          fullWidth: true,\n          variant: \"outlined\",\n          margin: \"normal\",\n          value: mergeCheck,\n          onChange: e => setMergeCheck(e.target.value.trim())\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 197,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 174,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(DialogActions, {\n        children: [/*#__PURE__*/_jsxDEV(Button, {\n          onClick: close,\n          color: \"primary\",\n          children: \"Cancel\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 207,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          disabled: disabled,\n          onClick: () => {\n            setIsMerging(true);\n            mergeAccounts().then(() => {\n              enqueueSnackbar('Account merge complete', {\n                variant: 'success'\n              });\n              setIsMerging(false);\n            }).catch(err => {\n              enqueueSnackbar(`There was a problem merging your accounts: ${err.toString()}`, {\n                variant: 'error'\n              });\n              setIsMerging(false);\n            });\n          },\n          color: \"secondary\",\n          autoFocus: true,\n          children: \"Merge\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 210,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 206,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 155,\n    columnNumber: 5\n  }, this);\n} // Merges the given array of token accounts into one associated token account.\n\n_s(MergeAccountsDialog, \"i5KIW+E70arI3tgCXUVfHT8jN64=\", false, function () {\n  return [useWalletPublicKeys, useConnection, useWallet, useSnackbar, useTokenInfos];\n});\n\n_c = MergeAccountsDialog;\n\nasync function mergeMint(assocTokAddr, mintAccountSet, mint, decimals, wallet, connection, enqueueSnackbar) {\n  if (mintAccountSet.length === 0) {\n    return;\n  } // Get the associated token account.\n\n\n  let associatedTokenAccount = await (async () => {\n    let assocTok = mintAccountSet.map(assocTok => assocTok.publicKey).filter(tokAddr => tokAddr.equals(assocTokAddr)).pop(); // Do we already have the token account?\n\n    if (assocTok) {\n      return assocTok;\n    } // Check if the associated token account has been created.\n    // This is required due to a sometimes unstable network, where\n    // the account is created, but the client doesn't receive a\n    // response confirmation.\n\n\n    const accInfo = await connection.getAccountInfo(assocTokAddr);\n\n    if (accInfo !== null) {\n      return assocTokAddr;\n    } // If it doesn't exist, then make it.\n\n\n    const [address] = await createAssociatedTokenAccount({\n      connection,\n      wallet,\n      splTokenMintAddress: mintAccountSet[0].account.mint\n    });\n    return address;\n  })(); // Send all funds to the associated token account for each account.\n  // Once the funds are transferred, close the duplicated account.\n\n  for (let k = 0; k < mintAccountSet.length; k += 1) {\n    const tokenAccount = mintAccountSet[k];\n\n    if (tokenAccount.publicKey.equals(associatedTokenAccount) === false) {\n      if (tokenAccount.account.amount > 0) {\n        await wallet.transferToken(tokenAccount.publicKey, associatedTokenAccount, tokenAccount.account.amount, mint, decimals);\n      }\n    }\n  }\n}\n\nasync function refresh(wallet, publicKeys) {\n  await refreshWalletPublicKeys(wallet);\n  publicKeys.map(publicKey => refreshAccountInfo(wallet.connection, publicKey, true));\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"MergeAccountsDialog\");","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/components/MergeAccountsDialog.js"],"names":["useState","useSnackbar","Button","Dialog","DialogTitle","DialogContent","DialogContentText","DialogActions","Link","TextField","CircularProgress","FingerprintIcon","TokenInstructions","useWalletPublicKeys","useConnection","refreshAccountInfo","getMultipleSolanaAccounts","parseTokenAccountData","refreshWalletPublicKeys","useWallet","createAssociatedTokenAccount","findAssociatedTokenAddress","sleep","useTokenInfos","getTokenInfo","MergeAccountsDialog","open","onClose","publicKeys","connection","wallet","enqueueSnackbar","isMerging","setIsMerging","mergeCheck","setMergeCheck","tokenInfos","mergeAccounts","retryCount","variant","tokenAccounts","filter","acc","account","owner","equals","TOKEN_PROGRAM_ID","map","publicKey","data","groupedTokenAccounts","forEach","ta","key","mint","toString","push","mints","Object","keys","k","length","mintGroup","assocTokAddr","tokenInfo","_rpcEndpoint","symbol","console","log","mergeMint","decimals","refresh","close","err","error","disabled","toLowerCase","marginBottom","textAlign","display","justifyContent","padding","e","target","value","trim","then","catch","mintAccountSet","associatedTokenAccount","assocTok","tokAddr","pop","accInfo","getAccountInfo","address","splTokenMintAddress","tokenAccount","amount","transferToken"],"mappings":";;;AAAA,SAASA,QAAT,QAAyB,OAAzB;AACA,SAASC,WAAT,QAA4B,WAA5B;AACA,OAAOC,MAAP,MAAmB,0BAAnB;AACA,OAAOC,MAAP,MAAmB,0BAAnB;AACA,OAAOC,WAAP,MAAwB,+BAAxB;AACA,OAAOC,aAAP,MAA0B,iCAA1B;AACA,OAAOC,iBAAP,MAA8B,qCAA9B;AACA,OAAOC,aAAP,MAA0B,iCAA1B;AACA,OAAOC,IAAP,MAAiB,wBAAjB;AACA,OAAOC,SAAP,MAAsB,6BAAtB;AACA,OAAOC,gBAAP,MAA6B,oCAA7B;AACA,OAAOC,eAAP,MAA4B,gCAA5B;AACA,SAASC,iBAAT,QAAkC,sBAAlC;AACA,SAASC,mBAAT,QAAoC,iBAApC;AACA,SACEC,aADF,EAEEC,kBAFF,EAGEC,yBAHF,QAIO,qBAJP;AAKA,SAASC,qBAAT,QAAsC,sBAAtC;AACA,SAASC,uBAAT,EAAkCC,SAAlC,QAAmD,iBAAnD;AACA,SACEC,4BADF,EAEEC,0BAFF,QAGO,iBAHP;AAIA,SAASC,KAAT,QAAsB,gBAAtB;AACA,SAASC,aAAT,EAAwBC,YAAxB,QAA4C,uBAA5C;;;AAEA,eAAe,SAASC,mBAAT,CAA6B;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAA7B,EAAgD;AAAA;;AAC7D,QAAM,CAACC,UAAD,IAAef,mBAAmB,EAAxC;AACA,QAAMgB,UAAU,GAAGf,aAAa,EAAhC;AACA,QAAMgB,MAAM,GAAGX,SAAS,EAAxB;AACA,QAAM;AAAEY,IAAAA;AAAF,MAAsB9B,WAAW,EAAvC;AACA,QAAM,CAAC+B,SAAD,EAAYC,YAAZ,IAA4BjC,QAAQ,CAAC,KAAD,CAA1C;AACA,QAAM,CAACkC,UAAD,EAAaC,aAAb,IAA8BnC,QAAQ,CAAC,EAAD,CAA5C;AACA,QAAMoC,UAAU,GAAGb,aAAa,EAAhC,CAP6D,CAS7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMc,aAAa,GAAG,OAAOC,UAAU,GAAG,EAApB,KAA2B;AAC/C,QAAI;AACF,UAAIA,UAAU,KAAK,CAAnB,EAAsB;AACpBP,QAAAA,eAAe,CAAE,6CAAF,EAAgD;AAC7DQ,UAAAA,OAAO,EAAE;AADoD,SAAhD,CAAf;AAGA;AACD,OANC,CAOF;AACA;AACA;;;AACA,YAAMC,aAAa,GAAG,CACpB,MAAMxB,yBAAyB,CAACa,UAAD,EAAaD,UAAb,CADX,EAGnBa,MAHmB,CAIjBC,GAAD,IACEA,GAAG,KAAK,IAAR,IACAA,GAAG,CAACC,OAAJ,CAAYC,KAAZ,CAAkBC,MAAlB,CAAyBjC,iBAAiB,CAACkC,gBAA3C,CANgB,EAQnBC,GARmB,CAQf,CAAC;AAAEC,QAAAA,SAAF;AAAaL,QAAAA;AAAb,OAAD,KAA4B;AAC/B,eAAO;AACLK,UAAAA,SADK;AAELL,UAAAA,OAAO,EAAE1B,qBAAqB,CAAC0B,OAAO,CAACM,IAAT,CAFzB;AAGLL,UAAAA,KAAK,EAAED,OAAO,CAACC;AAHV,SAAP;AAKD,OAdmB,CAAtB,CAVE,CA0BF;;AACA,YAAMM,oBAAoB,GAAG,EAA7B;AACAV,MAAAA,aAAa,CAACW,OAAd,CAAuBC,EAAD,IAAQ;AAC5B,cAAMC,GAAG,GAAGD,EAAE,CAACT,OAAH,CAAWW,IAAX,CAAgBC,QAAhB,EAAZ;;AACA,YAAIL,oBAAoB,CAACG,GAAD,CAAxB,EAA+B;AAC7BH,UAAAA,oBAAoB,CAACG,GAAD,CAApB,CAA0BG,IAA1B,CAA+BJ,EAA/B;AACD,SAFD,MAEO;AACLF,UAAAA,oBAAoB,CAACG,GAAD,CAApB,GAA4B,CAACD,EAAD,CAA5B;AACD;AACF,OAPD,EA5BE,CAqCF;;AACA,YAAMK,KAAK,GAAGC,MAAM,CAACC,IAAP,CAAYT,oBAAZ,CAAd;;AACA,WAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,IAAI,CAAvC,EAA0C;AACxC,cAAME,SAAS,GAAGZ,oBAAoB,CAACO,KAAK,CAACG,CAAD,CAAN,CAAtC;;AACA,YAAIE,SAAS,CAACD,MAAV,GAAmB,CAAvB,EAA0B;AACxB,gBAAMP,IAAI,GAAGQ,SAAS,CAAC,CAAD,CAAT,CAAanB,OAAb,CAAqBW,IAAlC;AACA,gBAAMS,YAAY,GAAG,MAAM1C,0BAA0B,CACnDS,MAAM,CAACkB,SAD4C,EAEnDM,IAFmD,CAArD,CAFwB,CAMxB;;AACA,cACE,EACEQ,SAAS,CAACD,MAAV,KAAqB,CAArB,IACAE,YAAY,CAAClB,MAAb,CAAoBiB,SAAS,CAAC,CAAD,CAAT,CAAad,SAAjC,CAFF,CADF,EAKE;AACA,kBAAMgB,SAAS,GAAGxC,YAAY,CAC5B8B,IAD4B,EAE5BzB,UAAU,CAACoC,YAFiB,EAG5B7B,UAH4B,CAA9B;AAKA,kBAAM8B,MAAM,GAAGF,SAAS,CAACE,MAAV,GACXF,SAAS,CAACE,MADC,GAEXZ,IAAI,CAACC,QAAL,EAFJ;AAGAY,YAAAA,OAAO,CAACC,GAAR,CAAa,WAAUF,MAAO,EAA9B;AACAnC,YAAAA,eAAe,CAAE,WAAUmC,MAAO,EAAnB,EAAsB;AACnC3B,cAAAA,OAAO,EAAE;AAD0B,aAAtB,CAAf;AAGA,kBAAM8B,SAAS,CACbN,YADa,EAEbD,SAFa,EAGbR,IAHa,EAIbU,SAAS,CAACM,QAJG,EAKbxC,MALa,EAMbD,UANa,EAObE,eAPa,CAAf;AASD;AACF;AACF,OA7EC,CA+EF;;;AACA,YAAMT,KAAK,CAAC,IAAD,CAAX,CAhFE,CAkFF;;AACA,YAAMiD,OAAO,CAACzC,MAAD,EAASF,UAAT,CAAb,CAnFE,CAqFF;;AACA4C,MAAAA,KAAK;AACN,KAvFD,CAuFE,OAAOC,GAAP,EAAY;AACZN,MAAAA,OAAO,CAACO,KAAR,CAAc,sCAAd,EAAsDD,GAAtD;AACA1C,MAAAA,eAAe,CAAC,6CAAD,EAAgD;AAC7DQ,QAAAA,OAAO,EAAE;AADoD,OAAhD,CAAf,CAFY,CAMZ;;AACA,YAAMjB,KAAK,CAAC,KAAD,CAAX;AAEAS,MAAAA,eAAe,CAAC,gBAAD,EAAmB;AAAEQ,QAAAA,OAAO,EAAE;AAAX,OAAnB,CAAf;AACA,YAAMF,aAAa,CAACC,UAAU,GAAG,CAAd,CAAnB;AACD;AACF,GApGD;;AAqGA,QAAMkC,KAAK,GAAG,MAAM;AAClBrC,IAAAA,aAAa,CAAC,EAAD,CAAb;AACAR,IAAAA,OAAO;AACR,GAHD;;AAIA,QAAMgD,QAAQ,GAAGzC,UAAU,CAAC0C,WAAX,OAA6B,OAA9C;AAEA,sBACE,QAAC,MAAD;AAAQ,IAAA,oBAAoB,EAAE5C,SAA9B;AAAyC,IAAA,IAAI,EAAEN,IAA/C;AAAqD,IAAA,OAAO,EAAEC,OAA9D;AAAA,cACGK,SAAS,gBACR,QAAC,aAAD;AAAA,8BACE,QAAC,iBAAD;AAAmB,QAAA,KAAK,EAAE;AAAE6C,UAAAA,YAAY,EAAE,CAAhB;AAAmBC,UAAAA,SAAS,EAAE;AAA9B,SAA1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cADF,eAIE;AACE,QAAA,KAAK,EAAE;AACLC,UAAAA,OAAO,EAAE,MADJ;AAELC,UAAAA,cAAc,EAAE,QAFX;AAGLC,UAAAA,OAAO,EAAE;AAHJ,SADT;AAAA,+BAOE,QAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAPF;AAAA;AAAA;AAAA;AAAA,cAJF;AAAA;AAAA;AAAA;AAAA;AAAA,YADQ,gBAgBR;AAAA,8BACE,QAAC,WAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cADF,eAEE,QAAC,aAAD;AAAA,gCACE,QAAC,iBAAD;AAAA,kCACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBADF;AAAA;AAAA;AAAA;AAAA;AAAA,gBADF,eAKE,QAAC,iBAAD;AAAA,oDAC8B,GAD9B,eAEE,QAAC,IAAD;AACE,YAAA,IAAI,EAAE,iDADR;AAEE,YAAA,MAAM,EAAC,QAFT;AAGE,YAAA,GAAG,EAAC,UAHN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAFF,EAQU,GARV,eASE,QAAC,eAAD;AAAiB,YAAA,KAAK,EAAE;AAAEJ,cAAAA,YAAY,EAAE;AAAhB;AAAxB;AAAA;AAAA;AAAA;AAAA,kBATF;AAAA;AAAA;AAAA;AAAA;AAAA,gBALF,eAiBE,QAAC,iBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAjBF,eAuBE,QAAC,SAAD;AACE,UAAA,KAAK,EAAG,gCADV;AAEE,UAAA,SAAS,MAFX;AAGE,UAAA,OAAO,EAAC,UAHV;AAIE,UAAA,MAAM,EAAC,QAJT;AAKE,UAAA,KAAK,EAAE3C,UALT;AAME,UAAA,QAAQ,EAAGgD,CAAD,IAAO/C,aAAa,CAAC+C,CAAC,CAACC,MAAF,CAASC,KAAT,CAAeC,IAAf,EAAD;AANhC;AAAA;AAAA;AAAA;AAAA,gBAvBF;AAAA;AAAA;AAAA;AAAA;AAAA,cAFF,eAkCE,QAAC,aAAD;AAAA,gCACE,QAAC,MAAD;AAAQ,UAAA,OAAO,EAAEb,KAAjB;AAAwB,UAAA,KAAK,EAAC,SAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBADF,eAIE,QAAC,MAAD;AACE,UAAA,QAAQ,EAAEG,QADZ;AAEE,UAAA,OAAO,EAAE,MAAM;AACb1C,YAAAA,YAAY,CAAC,IAAD,CAAZ;AACAI,YAAAA,aAAa,GACViD,IADH,CACQ,MAAM;AACVvD,cAAAA,eAAe,CAAC,wBAAD,EAA2B;AACxCQ,gBAAAA,OAAO,EAAE;AAD+B,eAA3B,CAAf;AAGAN,cAAAA,YAAY,CAAC,KAAD,CAAZ;AACD,aANH,EAOGsD,KAPH,CAOUd,GAAD,IAAS;AACd1C,cAAAA,eAAe,CACZ,8CAA6C0C,GAAG,CAAClB,QAAJ,EAAe,EADhD,EAEb;AAAEhB,gBAAAA,OAAO,EAAE;AAAX,eAFa,CAAf;AAIAN,cAAAA,YAAY,CAAC,KAAD,CAAZ;AACD,aAbH;AAcD,WAlBH;AAmBE,UAAA,KAAK,EAAC,WAnBR;AAoBE,UAAA,SAAS,MApBX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAJF;AAAA;AAAA;AAAA;AAAA;AAAA,cAlCF;AAAA;AAjBJ;AAAA;AAAA;AAAA;AAAA,UADF;AAqFD,C,CAED;;GApNwBR,mB;UACDZ,mB,EACFC,a,EACJK,S,EACalB,W,EAGTsB,a;;;KAPGE,mB;;AAqNxB,eAAe4C,SAAf,CACEN,YADF,EAEEyB,cAFF,EAGElC,IAHF,EAIEgB,QAJF,EAKExC,MALF,EAMED,UANF,EAOEE,eAPF,EAQE;AACA,MAAIyD,cAAc,CAAC3B,MAAf,KAA0B,CAA9B,EAAiC;AAC/B;AACD,GAHD,CAIA;;;AACA,MAAI4B,sBAAsB,GAAG,MAAM,CAAC,YAAY;AAC9C,QAAIC,QAAQ,GAAGF,cAAc,CAC1BzC,GADY,CACP2C,QAAD,IAAcA,QAAQ,CAAC1C,SADf,EAEZP,MAFY,CAEJkD,OAAD,IAAaA,OAAO,CAAC9C,MAAR,CAAekB,YAAf,CAFR,EAGZ6B,GAHY,EAAf,CAD8C,CAM9C;;AACA,QAAIF,QAAJ,EAAc;AACZ,aAAOA,QAAP;AACD,KAT6C,CAW9C;AACA;AACA;AACA;;;AACA,UAAMG,OAAO,GAAG,MAAMhE,UAAU,CAACiE,cAAX,CAA0B/B,YAA1B,CAAtB;;AACA,QAAI8B,OAAO,KAAK,IAAhB,EAAsB;AACpB,aAAO9B,YAAP;AACD,KAlB6C,CAoB9C;;;AACA,UAAM,CAACgC,OAAD,IAAY,MAAM3E,4BAA4B,CAAC;AACnDS,MAAAA,UADmD;AAEnDC,MAAAA,MAFmD;AAGnDkE,MAAAA,mBAAmB,EAAER,cAAc,CAAC,CAAD,CAAd,CAAkB7C,OAAlB,CAA0BW;AAHI,KAAD,CAApD;AAMA,WAAOyC,OAAP;AACD,GA5BkC,GAAnC,CALA,CAmCA;AACA;;AACA,OAAK,IAAInC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4B,cAAc,CAAC3B,MAAnC,EAA2CD,CAAC,IAAI,CAAhD,EAAmD;AACjD,UAAMqC,YAAY,GAAGT,cAAc,CAAC5B,CAAD,CAAnC;;AACA,QAAIqC,YAAY,CAACjD,SAAb,CAAuBH,MAAvB,CAA8B4C,sBAA9B,MAA0D,KAA9D,EAAqE;AACnE,UAAIQ,YAAY,CAACtD,OAAb,CAAqBuD,MAArB,GAA8B,CAAlC,EAAqC;AACnC,cAAMpE,MAAM,CAACqE,aAAP,CACJF,YAAY,CAACjD,SADT,EAEJyC,sBAFI,EAGJQ,YAAY,CAACtD,OAAb,CAAqBuD,MAHjB,EAIJ5C,IAJI,EAKJgB,QALI,CAAN;AAOD;AACF;AACF;AACF;;AAED,eAAeC,OAAf,CAAuBzC,MAAvB,EAA+BF,UAA/B,EAA2C;AACzC,QAAMV,uBAAuB,CAACY,MAAD,CAA7B;AACAF,EAAAA,UAAU,CAACmB,GAAX,CAAgBC,SAAD,IACbjC,kBAAkB,CAACe,MAAM,CAACD,UAAR,EAAoBmB,SAApB,EAA+B,IAA/B,CADpB;AAGD","sourcesContent":["import { useState } from 'react';\nimport { useSnackbar } from 'notistack';\nimport Button from '@material-ui/core/Button';\nimport Dialog from '@material-ui/core/Dialog';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport DialogContent from '@material-ui/core/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport Link from '@material-ui/core/Link';\nimport TextField from '@material-ui/core/TextField';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport FingerprintIcon from '@material-ui/icons/Fingerprint';\nimport { TokenInstructions } from '@project-serum/serum';\nimport { useWalletPublicKeys } from '../utils/wallet';\nimport {\n  useConnection,\n  refreshAccountInfo,\n  getMultipleSolanaAccounts,\n} from '../utils/connection';\nimport { parseTokenAccountData } from '../utils/tokens/data';\nimport { refreshWalletPublicKeys, useWallet } from '../utils/wallet';\nimport {\n  createAssociatedTokenAccount,\n  findAssociatedTokenAddress,\n} from '../utils/tokens';\nimport { sleep } from '../utils/utils';\nimport { useTokenInfos, getTokenInfo } from '../utils/tokens/names';\n\nexport default function MergeAccountsDialog({ open, onClose }) {\n  const [publicKeys] = useWalletPublicKeys();\n  const connection = useConnection();\n  const wallet = useWallet();\n  const { enqueueSnackbar } = useSnackbar();\n  const [isMerging, setIsMerging] = useState(false);\n  const [mergeCheck, setMergeCheck] = useState('');\n  const tokenInfos = useTokenInfos();\n\n  // Merging accounts is a destructive operation that, for each mint,\n  //\n  // * Creates an associated token account, if not already created\n  // * Moves all funds into the associated token account\n  // * Closes every account, excluding the associated token account.\n  //\n  // Although it's ok if this operation fails--since the user can just\n  // retry again--it's not a good experience; hence the retry logic.\n  // The retry count of 30 is arbitrary and probably overly conservative.\n  const mergeAccounts = async (retryCount = 30) => {\n    try {\n      if (retryCount === 0) {\n        enqueueSnackbar(`Unable to complete merge. Please try again.`, {\n          variant: 'error',\n        });\n        return;\n      }\n      // Fetch all token accounts owned by the wallet. An account is null\n      // if we previously sent the close transaction, but did not receive\n      // a response due to RPC node instability.\n      const tokenAccounts = (\n        await getMultipleSolanaAccounts(connection, publicKeys)\n      )\n        .filter(\n          (acc) =>\n            acc !== null &&\n            acc.account.owner.equals(TokenInstructions.TOKEN_PROGRAM_ID),\n        )\n        .map(({ publicKey, account }) => {\n          return {\n            publicKey,\n            account: parseTokenAccountData(account.data),\n            owner: account.owner,\n          };\n        });\n\n      // Group the token accounts by mint.\n      const groupedTokenAccounts = {};\n      tokenAccounts.forEach((ta) => {\n        const key = ta.account.mint.toString();\n        if (groupedTokenAccounts[key]) {\n          groupedTokenAccounts[key].push(ta);\n        } else {\n          groupedTokenAccounts[key] = [ta];\n        }\n      });\n\n      // For each mint, merge them into one, associated token account.\n      const mints = Object.keys(groupedTokenAccounts);\n      for (let k = 0; k < mints.length; k += 1) {\n        const mintGroup = groupedTokenAccounts[mints[k]];\n        if (mintGroup.length > 0) {\n          const mint = mintGroup[0].account.mint;\n          const assocTokAddr = await findAssociatedTokenAddress(\n            wallet.publicKey,\n            mint,\n          );\n          // Don't merge if the only account is the associated token address.\n          if (\n            !(\n              mintGroup.length === 1 &&\n              assocTokAddr.equals(mintGroup[0].publicKey)\n            )\n          ) {\n            const tokenInfo = getTokenInfo(\n              mint,\n              connection._rpcEndpoint,\n              tokenInfos,\n            );\n            const symbol = tokenInfo.symbol\n              ? tokenInfo.symbol\n              : mint.toString();\n            console.log(`Merging ${symbol}`);\n            enqueueSnackbar(`Merging ${symbol}`, {\n              variant: 'info',\n            });\n            await mergeMint(\n              assocTokAddr,\n              mintGroup,\n              mint,\n              tokenInfo.decimals,\n              wallet,\n              connection,\n              enqueueSnackbar,\n            );\n          }\n        }\n      }\n\n      // Wait to give the RPC nodes some time to catch up.\n      await sleep(5000);\n\n      // Refresh the UI to remove any duplicates.\n      await refresh(wallet, publicKeys);\n\n      // Exit dialogue.\n      close();\n    } catch (err) {\n      console.error('There was a problem merging accounts', err);\n      enqueueSnackbar('Could not confirm transaction. Please wait.', {\n        variant: 'info',\n      });\n\n      // Sleep to give the RPC nodes some time to catch up.\n      await sleep(10000);\n\n      enqueueSnackbar('Retrying merge', { variant: 'info' });\n      await mergeAccounts(retryCount - 1);\n    }\n  };\n  const close = () => {\n    setMergeCheck('');\n    onClose();\n  };\n  const disabled = mergeCheck.toLowerCase() !== 'merge';\n\n  return (\n    <Dialog disableBackdropClick={isMerging} open={open} onClose={onClose}>\n      {isMerging ? (\n        <DialogContent>\n          <DialogContentText style={{ marginBottom: 0, textAlign: 'center' }}>\n            Merging Accounts\n          </DialogContentText>\n          <div\n            style={{\n              display: 'flex',\n              justifyContent: 'center',\n              padding: '24px',\n            }}\n          >\n            <CircularProgress />\n          </div>\n        </DialogContent>\n      ) : (\n        <>\n          <DialogTitle>Are you sure you want to merge tokens?</DialogTitle>\n          <DialogContent>\n            <DialogContentText>\n              <b>WARNING</b>: This action may break apps that depend on your\n              existing token accounts.\n            </DialogContentText>\n            <DialogContentText>\n              Merging sends all tokens to{' '}\n              <Link\n                href={'https://spl.solana.com/associated-token-account'}\n                target=\"_blank\"\n                rel=\"noopener\"\n              >\n                associated token accounts\n              </Link>{' '}\n              <FingerprintIcon style={{ marginBottom: '-7px' }} />. If\n              associated token accounts do not exist, then they will be created.\n            </DialogContentText>\n            <DialogContentText>\n              If merging fails during a period of high network load, you will\n              not have lost your funds. Just recontinue the merge from where you\n              left off. If you have a lot of accounts, merging might take a\n              while.\n            </DialogContentText>\n            <TextField\n              label={`Please type \"merge\" to confirm`}\n              fullWidth\n              variant=\"outlined\"\n              margin=\"normal\"\n              value={mergeCheck}\n              onChange={(e) => setMergeCheck(e.target.value.trim())}\n            />\n          </DialogContent>\n          <DialogActions>\n            <Button onClick={close} color=\"primary\">\n              Cancel\n            </Button>\n            <Button\n              disabled={disabled}\n              onClick={() => {\n                setIsMerging(true);\n                mergeAccounts()\n                  .then(() => {\n                    enqueueSnackbar('Account merge complete', {\n                      variant: 'success',\n                    });\n                    setIsMerging(false);\n                  })\n                  .catch((err) => {\n                    enqueueSnackbar(\n                      `There was a problem merging your accounts: ${err.toString()}`,\n                      { variant: 'error' },\n                    );\n                    setIsMerging(false);\n                  });\n              }}\n              color=\"secondary\"\n              autoFocus\n            >\n              Merge\n            </Button>\n          </DialogActions>\n        </>\n      )}\n    </Dialog>\n  );\n}\n\n// Merges the given array of token accounts into one associated token account.\nasync function mergeMint(\n  assocTokAddr,\n  mintAccountSet,\n  mint,\n  decimals,\n  wallet,\n  connection,\n  enqueueSnackbar,\n) {\n  if (mintAccountSet.length === 0) {\n    return;\n  }\n  // Get the associated token account.\n  let associatedTokenAccount = await (async () => {\n    let assocTok = mintAccountSet\n      .map((assocTok) => assocTok.publicKey)\n      .filter((tokAddr) => tokAddr.equals(assocTokAddr))\n      .pop();\n\n    // Do we already have the token account?\n    if (assocTok) {\n      return assocTok;\n    }\n\n    // Check if the associated token account has been created.\n    // This is required due to a sometimes unstable network, where\n    // the account is created, but the client doesn't receive a\n    // response confirmation.\n    const accInfo = await connection.getAccountInfo(assocTokAddr);\n    if (accInfo !== null) {\n      return assocTokAddr;\n    }\n\n    // If it doesn't exist, then make it.\n    const [address] = await createAssociatedTokenAccount({\n      connection,\n      wallet,\n      splTokenMintAddress: mintAccountSet[0].account.mint,\n    });\n\n    return address;\n  })();\n\n  // Send all funds to the associated token account for each account.\n  // Once the funds are transferred, close the duplicated account.\n  for (let k = 0; k < mintAccountSet.length; k += 1) {\n    const tokenAccount = mintAccountSet[k];\n    if (tokenAccount.publicKey.equals(associatedTokenAccount) === false) {\n      if (tokenAccount.account.amount > 0) {\n        await wallet.transferToken(\n          tokenAccount.publicKey,\n          associatedTokenAccount,\n          tokenAccount.account.amount,\n          mint,\n          decimals,\n        );\n      }\n    }\n  }\n}\n\nasync function refresh(wallet, publicKeys) {\n  await refreshWalletPublicKeys(wallet);\n  publicKeys.map((publicKey) =>\n    refreshAccountInfo(wallet.connection, publicKey, true),\n  );\n}\n"]},"metadata":{},"sourceType":"module"}