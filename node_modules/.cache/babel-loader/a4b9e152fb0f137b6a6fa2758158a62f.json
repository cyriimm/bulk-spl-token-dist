{"ast":null,"code":"const createHmac = require('create-hmac');\n\nconst ONE1 = Buffer.alloc(1, 1);\nconst ZERO1 = Buffer.alloc(1, 0); // https://tools.ietf.org/html/rfc6979#section-3.2\n\nfunction deterministicGenerateK(hash, x, checkSig, isPrivate, extraEntropy) {\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  let k = Buffer.alloc(32, 0);\n  let v = Buffer.alloc(32, 1); // Step D\n\n  k = createHmac('sha256', k).update(v).update(ZERO1).update(x).update(hash).update(extraEntropy || '').digest(); // Step E\n\n  v = createHmac('sha256', k).update(v).digest(); // Step F\n\n  k = createHmac('sha256', k).update(v).update(ONE1).update(x).update(hash).update(extraEntropy || '').digest(); // Step G\n\n  v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n\n  v = createHmac('sha256', k).update(v).digest();\n  let T = v; // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n\n  while (!isPrivate(T) || !checkSig(T)) {\n    k = createHmac('sha256', k).update(v).update(ZERO1).digest();\n    v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n\n    v = createHmac('sha256', k).update(v).digest();\n    T = v;\n  }\n\n  return T;\n}\n\nmodule.exports = deterministicGenerateK;","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/node_modules/tiny-secp256k1/rfc6979.js"],"names":["createHmac","require","ONE1","Buffer","alloc","ZERO1","deterministicGenerateK","hash","x","checkSig","isPrivate","extraEntropy","k","v","update","digest","T","module","exports"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,aAAD,CAA1B;;AAEA,MAAMC,IAAI,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,EAAgB,CAAhB,CAAb;AACA,MAAMC,KAAK,GAAGF,MAAM,CAACC,KAAP,CAAa,CAAb,EAAgB,CAAhB,CAAd,C,CAEA;;AACA,SAASE,sBAAT,CAAiCC,IAAjC,EAAuCC,CAAvC,EAA0CC,QAA1C,EAAoDC,SAApD,EAA+DC,YAA/D,EAA6E;AAC3E;AACA;AACA;AACA,MAAIC,CAAC,GAAGT,MAAM,CAACC,KAAP,CAAa,EAAb,EAAiB,CAAjB,CAAR;AACA,MAAIS,CAAC,GAAGV,MAAM,CAACC,KAAP,CAAa,EAAb,EAAiB,CAAjB,CAAR,CAL2E,CAO3E;;AACAQ,EAAAA,CAAC,GAAGZ,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CACDE,MADC,CACMD,CADN,EAEDC,MAFC,CAEMT,KAFN,EAGDS,MAHC,CAGMN,CAHN,EAIDM,MAJC,CAIMP,IAJN,EAKDO,MALC,CAKMH,YAAY,IAAI,EALtB,EAMDI,MANC,EAAJ,CAR2E,CAgB3E;;AACAF,EAAAA,CAAC,GAAGb,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CAAwBE,MAAxB,CAA+BD,CAA/B,EAAkCE,MAAlC,EAAJ,CAjB2E,CAmB3E;;AACAH,EAAAA,CAAC,GAAGZ,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CACDE,MADC,CACMD,CADN,EAEDC,MAFC,CAEMZ,IAFN,EAGDY,MAHC,CAGMN,CAHN,EAIDM,MAJC,CAIMP,IAJN,EAKDO,MALC,CAKMH,YAAY,IAAI,EALtB,EAMDI,MANC,EAAJ,CApB2E,CA4B3E;;AACAF,EAAAA,CAAC,GAAGb,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CAAwBE,MAAxB,CAA+BD,CAA/B,EAAkCE,MAAlC,EAAJ,CA7B2E,CA+B3E;AACA;;AACAF,EAAAA,CAAC,GAAGb,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CAAwBE,MAAxB,CAA+BD,CAA/B,EAAkCE,MAAlC,EAAJ;AAEA,MAAIC,CAAC,GAAGH,CAAR,CAnC2E,CAqC3E;;AACA,SAAO,CAACH,SAAS,CAACM,CAAD,CAAV,IAAiB,CAACP,QAAQ,CAACO,CAAD,CAAjC,EAAsC;AACpCJ,IAAAA,CAAC,GAAGZ,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CACDE,MADC,CACMD,CADN,EAEDC,MAFC,CAEMT,KAFN,EAGDU,MAHC,EAAJ;AAKAF,IAAAA,CAAC,GAAGb,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CAAwBE,MAAxB,CAA+BD,CAA/B,EAAkCE,MAAlC,EAAJ,CANoC,CAQpC;AACA;;AACAF,IAAAA,CAAC,GAAGb,UAAU,CAAC,QAAD,EAAWY,CAAX,CAAV,CAAwBE,MAAxB,CAA+BD,CAA/B,EAAkCE,MAAlC,EAAJ;AACAC,IAAAA,CAAC,GAAGH,CAAJ;AACD;;AAED,SAAOG,CAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiBZ,sBAAjB","sourcesContent":["const createHmac = require('create-hmac')\n\nconst ONE1 = Buffer.alloc(1, 1)\nconst ZERO1 = Buffer.alloc(1, 0)\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  let k = Buffer.alloc(32, 0)\n  let v = Buffer.alloc(32, 1)\n\n  // Step D\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ZERO1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step F\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ONE1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest()\n\n  let T = v\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (!isPrivate(T) || !checkSig(T)) {\n    k = createHmac('sha256', k)\n      .update(v)\n      .update(ZERO1)\n      .digest()\n\n    v = createHmac('sha256', k).update(v).digest()\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest()\n    T = v\n  }\n\n  return T\n}\n\nmodule.exports = deterministicGenerateK\n"]},"metadata":{},"sourceType":"script"}