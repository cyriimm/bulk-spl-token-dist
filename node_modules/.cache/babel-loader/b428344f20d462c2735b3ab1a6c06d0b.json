{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\n\nvar assert = require('assert');\n\nvar ethjsUtil = require('ethjs-util');\n\nvar secp256k1 = require('./secp256k1v3-adapter');\n\nvar BN = require(\"bn.js\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\n\n\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\n\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\n\n\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\n\n\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccak(prefix + address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\n\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\n\nexports.generateAddress = function (from, nonce) {\n  from = bytes_1.toBuffer(from);\n  var nonceBN = new BN(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\n\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = bytes_1.toBuffer(from);\n  var saltBuf = bytes_1.toBuffer(salt);\n  var initCodeBuf = bytes_1.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\n\n\nexports.isPrecompiled = function (address) {\n  var a = bytes_1.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\n\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  pubKey = bytes_1.toBuffer(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n\n  assert(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return hash_1.keccak(pubKey).slice(-20);\n};\n\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\n\nexports.privateToPublic = function (privateKey) {\n  privateKey = bytes_1.toBuffer(privateKey); // skip the type flag and use the X, Y points\n\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\n\n\nexports.importPublic = function (publicKey) {\n  publicKey = bytes_1.toBuffer(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n\n  return publicKey;\n};","map":{"version":3,"sources":["../src/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\nexports.zeroAddress = function () {\n    var addressLength = 20;\n    var addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (address) {\n    return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\nexports.isZeroAddress = function (address) {\n    var zeroAddr = exports.zeroAddress();\n    return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n    address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n    var hash = hash_1.keccak(prefix + address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    from = bytes_1.toBuffer(from);\n    var nonceBN = new BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    var fromBuf = bytes_1.toBuffer(from);\n    var saltBuf = bytes_1.toBuffer(salt);\n    var initCodeBuf = bytes_1.toBuffer(initCode);\n    assert(fromBuf.length === 20);\n    assert(saltBuf.length === 32);\n    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n    return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\nexports.isPrecompiled = function (address) {\n    var a = bytes_1.unpad(address);\n    return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    pubKey = bytes_1.toBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n    }\n    assert(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    privateKey = bytes_1.toBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    publicKey = bytes_1.toBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n    }\n    return publicKey;\n};\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}