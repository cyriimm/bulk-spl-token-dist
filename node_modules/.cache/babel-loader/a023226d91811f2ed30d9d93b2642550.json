{"ast":null,"code":"import { PublicKey, SystemProgram, Transaction, TransactionInstruction, SYSVAR_RENT_PUBKEY } from '@solana/web3.js';\nimport { TokenInstructions } from '@project-serum/serum';\nimport { assertOwner, closeAccount, initializeAccount, initializeMint, memoInstruction, mintTo, TOKEN_PROGRAM_ID, transferChecked } from './instructions';\nimport { ACCOUNT_LAYOUT, getOwnedAccountsFilters, MINT_LAYOUT, parseTokenAccountData } from './data';\nimport bs58 from 'bs58';\nexport async function getOwnedTokenAccounts(connection, publicKey) {\n  let filters = getOwnedAccountsFilters(publicKey);\n  let resp = await connection._rpcRequest('getProgramAccounts', [TOKEN_PROGRAM_ID.toBase58(), {\n    commitment: connection.commitment,\n    filters\n  }]);\n\n  if (resp.error) {\n    throw new Error('failed to get token accounts owned by ' + publicKey.toBase58() + ': ' + resp.error.message);\n  }\n\n  return resp.result.map(({\n    pubkey,\n    account: {\n      data,\n      executable,\n      owner,\n      lamports\n    }\n  }) => ({\n    publicKey: new PublicKey(pubkey),\n    accountInfo: {\n      data: bs58.decode(data),\n      executable,\n      owner: new PublicKey(owner),\n      lamports\n    }\n  })).filter(({\n    accountInfo\n  }) => {\n    // TODO: remove this check once mainnet is updated\n    return filters.every(filter => {\n      if (filter.dataSize) {\n        return accountInfo.data.length === filter.dataSize;\n      } else if (filter.memcmp) {\n        let filterBytes = bs58.decode(filter.memcmp.bytes);\n        return accountInfo.data.slice(filter.memcmp.offset, filter.memcmp.offset + filterBytes.length).equals(filterBytes);\n      }\n\n      return false;\n    });\n  });\n}\nexport async function signAndSendTransaction(connection, transaction, wallet, signers, skipPreflight = false) {\n  transaction.recentBlockhash = (await connection.getRecentBlockhash('max')).blockhash;\n  transaction.setSigners( // fee payed by the wallet owner\n  wallet.publicKey, ...signers.map(s => s.publicKey));\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  transaction = await wallet.signTransaction(transaction);\n  const rawTransaction = transaction.serialize();\n  return await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight,\n    preflightCommitment: 'single'\n  });\n}\nexport async function nativeTransfer(connection, wallet, destination, amount) {\n  const tx = new Transaction().add(SystemProgram.transfer({\n    fromPubkey: wallet.publicKey,\n    toPubkey: destination,\n    lamports: amount\n  }));\n  return await signAndSendTransaction(connection, tx, wallet, []);\n}\nexport async function createAndInitializeMint({\n  connection,\n  owner,\n  // Wallet for paying fees and allowed to mint new tokens\n  mint,\n  // Account to hold token information\n  amount,\n  // Number of tokens to issue\n  decimals,\n  initialAccount // Account to hold newly issued tokens, if amount > 0\n\n}) {\n  let transaction = new Transaction();\n  transaction.add(SystemProgram.createAccount({\n    fromPubkey: owner.publicKey,\n    newAccountPubkey: mint.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(MINT_LAYOUT.span),\n    space: MINT_LAYOUT.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  transaction.add(initializeMint({\n    mint: mint.publicKey,\n    decimals,\n    mintAuthority: owner.publicKey\n  }));\n  let signers = [mint];\n\n  if (amount > 0) {\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: owner.publicKey,\n      newAccountPubkey: initialAccount.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(ACCOUNT_LAYOUT.span),\n      space: ACCOUNT_LAYOUT.span,\n      programId: TOKEN_PROGRAM_ID\n    }));\n    signers.push(initialAccount);\n    transaction.add(initializeAccount({\n      account: initialAccount.publicKey,\n      mint: mint.publicKey,\n      owner: owner.publicKey\n    }));\n    transaction.add(mintTo({\n      mint: mint.publicKey,\n      destination: initialAccount.publicKey,\n      amount,\n      mintAuthority: owner.publicKey\n    }));\n  }\n\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\nexport async function createAndInitializeTokenAccount({\n  connection,\n  payer,\n  mintPublicKey,\n  newAccount\n}) {\n  let transaction = new Transaction();\n  transaction.add(SystemProgram.createAccount({\n    fromPubkey: payer.publicKey,\n    newAccountPubkey: newAccount.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(ACCOUNT_LAYOUT.span),\n    space: ACCOUNT_LAYOUT.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  transaction.add(initializeAccount({\n    account: newAccount.publicKey,\n    mint: mintPublicKey,\n    owner: payer.publicKey\n  }));\n  let signers = [newAccount];\n  return await signAndSendTransaction(connection, transaction, payer, signers);\n}\nexport async function createAssociatedTokenAccount({\n  connection,\n  wallet,\n  splTokenMintAddress\n}) {\n  const [ix, address] = await createAssociatedTokenAccountIx(wallet.publicKey, wallet.publicKey, splTokenMintAddress);\n  const tx = new Transaction();\n  tx.add(ix);\n  tx.feePayer = wallet.publicKey;\n  const txSig = await signAndSendTransaction(connection, tx, wallet, []);\n  return [address, txSig];\n}\n\nasync function createAssociatedTokenAccountIx(fundingAddress, walletAddress, splTokenMintAddress) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(walletAddress, splTokenMintAddress);\n  const systemProgramId = new PublicKey('11111111111111111111111111111111');\n  const keys = [{\n    pubkey: fundingAddress,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: systemProgramId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: TokenInstructions.TOKEN_PROGRAM_ID,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  const ix = new TransactionInstruction({\n    keys,\n    programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n    data: Buffer.from([])\n  });\n  return [ix, associatedTokenAddress];\n}\n\nexport async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {\n  return (await PublicKey.findProgramAddress([walletAddress.toBuffer(), TokenInstructions.TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID))[0];\n}\nexport const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\nexport async function transferTokens({\n  connection,\n  owner,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n  mint,\n  decimals,\n  overrideDestinationCheck\n}) {\n  const destinationAccountInfo = await connection.getAccountInfo(destinationPublicKey);\n\n  if (!!destinationAccountInfo && destinationAccountInfo.owner.equals(TOKEN_PROGRAM_ID)) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey,\n      amount,\n      memo\n    });\n  }\n\n  if ((!destinationAccountInfo || destinationAccountInfo.lamports === 0) && !overrideDestinationCheck) {\n    throw new Error('Cannot send to address with zero SOL balances');\n  }\n\n  const destinationSplTokenAccount = (await getOwnedTokenAccounts(connection, destinationPublicKey)).map(({\n    publicKey,\n    accountInfo\n  }) => {\n    return {\n      publicKey,\n      parsed: parseTokenAccountData(accountInfo.data)\n    };\n  }).filter(({\n    parsed\n  }) => parsed.mint.equals(mint)).sort((a, b) => {\n    return b.parsed.amount - a.parsed.amount;\n  })[0];\n\n  if (destinationSplTokenAccount) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey: destinationSplTokenAccount.publicKey,\n      amount,\n      memo\n    });\n  }\n\n  return await createAndTransferToAccount({\n    connection,\n    owner,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n    mint,\n    decimals\n  });\n}\n\nfunction createTransferBetweenSplTokenAccountsInstruction({\n  ownerPublicKey,\n  mint,\n  decimals,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo\n}) {\n  let transaction = new Transaction().add(transferChecked({\n    source: sourcePublicKey,\n    mint,\n    decimals,\n    destination: destinationPublicKey,\n    owner: ownerPublicKey,\n    amount\n  }));\n\n  if (memo) {\n    transaction.add(memoInstruction(memo));\n  }\n\n  return transaction;\n}\n\nexport async function transferBetweenSplTokenAccounts({\n  connection,\n  owner,\n  mint,\n  decimals,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo\n}) {\n  const transaction = createTransferBetweenSplTokenAccountsInstruction({\n    ownerPublicKey: owner.publicKey,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo\n  });\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nasync function createAndTransferToAccount({\n  connection,\n  owner,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n  mint,\n  decimals\n}) {\n  const [createAccountInstruction, newAddress] = await createAssociatedTokenAccountIx(owner.publicKey, destinationPublicKey, mint);\n  let transaction = new Transaction();\n  transaction.add(assertOwner({\n    account: destinationPublicKey,\n    owner: SystemProgram.programId\n  }));\n  transaction.add(createAccountInstruction);\n  const transferBetweenAccountsTxn = createTransferBetweenSplTokenAccountsInstruction({\n    ownerPublicKey: owner.publicKey,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey: newAddress,\n    amount,\n    memo\n  });\n  transaction.add(transferBetweenAccountsTxn);\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nexport async function closeTokenAccount({\n  connection,\n  owner,\n  sourcePublicKey,\n  skipPreflight\n}) {\n  let transaction = new Transaction().add(closeAccount({\n    source: sourcePublicKey,\n    destination: owner.publicKey,\n    owner: owner.publicKey\n  }));\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers, skipPreflight);\n}","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/tokens/index.js"],"names":["PublicKey","SystemProgram","Transaction","TransactionInstruction","SYSVAR_RENT_PUBKEY","TokenInstructions","assertOwner","closeAccount","initializeAccount","initializeMint","memoInstruction","mintTo","TOKEN_PROGRAM_ID","transferChecked","ACCOUNT_LAYOUT","getOwnedAccountsFilters","MINT_LAYOUT","parseTokenAccountData","bs58","getOwnedTokenAccounts","connection","publicKey","filters","resp","_rpcRequest","toBase58","commitment","error","Error","message","result","map","pubkey","account","data","executable","owner","lamports","accountInfo","decode","filter","every","dataSize","length","memcmp","filterBytes","bytes","slice","offset","equals","signAndSendTransaction","transaction","wallet","signers","skipPreflight","recentBlockhash","getRecentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","rawTransaction","serialize","sendRawTransaction","preflightCommitment","nativeTransfer","destination","amount","tx","add","transfer","fromPubkey","toPubkey","createAndInitializeMint","mint","decimals","initialAccount","createAccount","newAccountPubkey","getMinimumBalanceForRentExemption","span","space","programId","mintAuthority","push","createAndInitializeTokenAccount","payer","mintPublicKey","newAccount","createAssociatedTokenAccount","splTokenMintAddress","ix","address","createAssociatedTokenAccountIx","feePayer","txSig","fundingAddress","walletAddress","associatedTokenAddress","findAssociatedTokenAddress","systemProgramId","keys","isSigner","isWritable","ASSOCIATED_TOKEN_PROGRAM_ID","Buffer","from","tokenMintAddress","findProgramAddress","toBuffer","transferTokens","sourcePublicKey","destinationPublicKey","memo","overrideDestinationCheck","destinationAccountInfo","getAccountInfo","transferBetweenSplTokenAccounts","destinationSplTokenAccount","parsed","sort","a","b","createAndTransferToAccount","createTransferBetweenSplTokenAccountsInstruction","ownerPublicKey","source","createAccountInstruction","newAddress","transferBetweenAccountsTxn","closeTokenAccount"],"mappings":"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","sourcesContent":["import {\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n  SYSVAR_RENT_PUBKEY,\n} from '@solana/web3.js';\nimport { TokenInstructions } from '@project-serum/serum';\nimport {\n  assertOwner,\n  closeAccount,\n  initializeAccount,\n  initializeMint,\n  memoInstruction,\n  mintTo,\n  TOKEN_PROGRAM_ID,\n  transferChecked,\n} from './instructions';\nimport {\n  ACCOUNT_LAYOUT,\n  getOwnedAccountsFilters,\n  MINT_LAYOUT,\n  parseTokenAccountData,\n} from './data';\nimport bs58 from 'bs58';\n\nexport async function getOwnedTokenAccounts(connection, publicKey) {\n  let filters = getOwnedAccountsFilters(publicKey);\n  let resp = await connection._rpcRequest('getProgramAccounts', [\n    TOKEN_PROGRAM_ID.toBase58(),\n    {\n      commitment: connection.commitment,\n      filters,\n    },\n  ]);\n  if (resp.error) {\n    throw new Error(\n      'failed to get token accounts owned by ' +\n        publicKey.toBase58() +\n        ': ' +\n        resp.error.message,\n    );\n  }\n  return resp.result\n    .map(({ pubkey, account: { data, executable, owner, lamports } }) => ({\n      publicKey: new PublicKey(pubkey),\n      accountInfo: {\n        data: bs58.decode(data),\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n      },\n    }))\n    .filter(({ accountInfo }) => {\n      // TODO: remove this check once mainnet is updated\n      return filters.every((filter) => {\n        if (filter.dataSize) {\n          return accountInfo.data.length === filter.dataSize;\n        } else if (filter.memcmp) {\n          let filterBytes = bs58.decode(filter.memcmp.bytes);\n          return accountInfo.data\n            .slice(\n              filter.memcmp.offset,\n              filter.memcmp.offset + filterBytes.length,\n            )\n            .equals(filterBytes);\n        }\n        return false;\n      });\n    });\n}\n\nexport async function signAndSendTransaction(\n  connection,\n  transaction,\n  wallet,\n  signers,\n  skipPreflight = false,\n) {\n  transaction.recentBlockhash = (\n    await connection.getRecentBlockhash('max')\n  ).blockhash;\n  transaction.setSigners(\n    // fee payed by the wallet owner\n    wallet.publicKey,\n    ...signers.map((s) => s.publicKey),\n  );\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  transaction = await wallet.signTransaction(transaction);\n  const rawTransaction = transaction.serialize();\n  return await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight,\n    preflightCommitment: 'single',\n  });\n}\n\nexport async function nativeTransfer(connection, wallet, destination, amount) {\n  const tx = new Transaction().add(\n    SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: destination,\n      lamports: amount,\n    }),\n  );\n  return await signAndSendTransaction(connection, tx, wallet, []);\n}\n\nexport async function createAndInitializeMint({\n  connection,\n  owner, // Wallet for paying fees and allowed to mint new tokens\n  mint, // Account to hold token information\n  amount, // Number of tokens to issue\n  decimals,\n  initialAccount, // Account to hold newly issued tokens, if amount > 0\n}) {\n  let transaction = new Transaction();\n  transaction.add(\n    SystemProgram.createAccount({\n      fromPubkey: owner.publicKey,\n      newAccountPubkey: mint.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(\n        MINT_LAYOUT.span,\n      ),\n      space: MINT_LAYOUT.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  transaction.add(\n    initializeMint({\n      mint: mint.publicKey,\n      decimals,\n      mintAuthority: owner.publicKey,\n    }),\n  );\n  let signers = [mint];\n  if (amount > 0) {\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: owner.publicKey,\n        newAccountPubkey: initialAccount.publicKey,\n        lamports: await connection.getMinimumBalanceForRentExemption(\n          ACCOUNT_LAYOUT.span,\n        ),\n        space: ACCOUNT_LAYOUT.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n    signers.push(initialAccount);\n    transaction.add(\n      initializeAccount({\n        account: initialAccount.publicKey,\n        mint: mint.publicKey,\n        owner: owner.publicKey,\n      }),\n    );\n    transaction.add(\n      mintTo({\n        mint: mint.publicKey,\n        destination: initialAccount.publicKey,\n        amount,\n        mintAuthority: owner.publicKey,\n      }),\n    );\n  }\n\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nexport async function createAndInitializeTokenAccount({\n  connection,\n  payer,\n  mintPublicKey,\n  newAccount,\n}) {\n  let transaction = new Transaction();\n  transaction.add(\n    SystemProgram.createAccount({\n      fromPubkey: payer.publicKey,\n      newAccountPubkey: newAccount.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(\n        ACCOUNT_LAYOUT.span,\n      ),\n      space: ACCOUNT_LAYOUT.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  transaction.add(\n    initializeAccount({\n      account: newAccount.publicKey,\n      mint: mintPublicKey,\n      owner: payer.publicKey,\n    }),\n  );\n\n  let signers = [newAccount];\n  return await signAndSendTransaction(connection, transaction, payer, signers);\n}\n\nexport async function createAssociatedTokenAccount({\n  connection,\n  wallet,\n  splTokenMintAddress,\n}) {\n  const [ix, address] = await createAssociatedTokenAccountIx(\n    wallet.publicKey,\n    wallet.publicKey,\n    splTokenMintAddress,\n  );\n  const tx = new Transaction();\n  tx.add(ix);\n  tx.feePayer = wallet.publicKey;\n  const txSig = await signAndSendTransaction(connection, tx, wallet, []);\n\n  return [address, txSig];\n}\nasync function createAssociatedTokenAccountIx(\n  fundingAddress,\n  walletAddress,\n  splTokenMintAddress,\n) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(\n    walletAddress,\n    splTokenMintAddress,\n  );\n  const systemProgramId = new PublicKey('11111111111111111111111111111111');\n  const keys = [\n    {\n      pubkey: fundingAddress,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: systemProgramId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TokenInstructions.TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  const ix = new TransactionInstruction({\n    keys,\n    programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n  return [ix, associatedTokenAddress];\n}\n\nexport async function findAssociatedTokenAddress(\n  walletAddress,\n  tokenMintAddress,\n) {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        walletAddress.toBuffer(),\n        TokenInstructions.TOKEN_PROGRAM_ID.toBuffer(),\n        tokenMintAddress.toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n    )\n  )[0];\n}\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey(\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n);\n\nexport async function transferTokens({\n  connection,\n  owner,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n  mint,\n  decimals,\n  overrideDestinationCheck,\n}) {\n  const destinationAccountInfo = await connection.getAccountInfo(\n    destinationPublicKey,\n  );\n  if (\n    !!destinationAccountInfo &&\n    destinationAccountInfo.owner.equals(TOKEN_PROGRAM_ID)\n  ) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey,\n      amount,\n      memo,\n    });\n  }\n\n  if (\n    (!destinationAccountInfo || destinationAccountInfo.lamports === 0) &&\n    !overrideDestinationCheck\n  ) {\n    throw new Error('Cannot send to address with zero SOL balances');\n  }\n  const destinationSplTokenAccount = (\n    await getOwnedTokenAccounts(connection, destinationPublicKey)\n  )\n    .map(({ publicKey, accountInfo }) => {\n      return { publicKey, parsed: parseTokenAccountData(accountInfo.data) };\n    })\n    .filter(({ parsed }) => parsed.mint.equals(mint))\n    .sort((a, b) => {\n      return b.parsed.amount - a.parsed.amount;\n    })[0];\n  if (destinationSplTokenAccount) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey: destinationSplTokenAccount.publicKey,\n      amount,\n      memo,\n    });\n  }\n  return await createAndTransferToAccount({\n    connection,\n    owner,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n    mint,\n    decimals,\n  });\n}\n\nfunction createTransferBetweenSplTokenAccountsInstruction({\n  ownerPublicKey,\n  mint,\n  decimals,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n}) {\n  let transaction = new Transaction().add(\n    transferChecked({\n      source: sourcePublicKey,\n      mint,\n      decimals,\n      destination: destinationPublicKey,\n      owner: ownerPublicKey,\n      amount,\n    }),\n  );\n  if (memo) {\n    transaction.add(memoInstruction(memo));\n  }\n  return transaction;\n}\n\nexport async function transferBetweenSplTokenAccounts({\n  connection,\n  owner,\n  mint,\n  decimals,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n}) {\n  const transaction = createTransferBetweenSplTokenAccountsInstruction({\n    ownerPublicKey: owner.publicKey,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n  });\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nasync function createAndTransferToAccount({\n  connection,\n  owner,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n  mint,\n  decimals,\n}) {\n  const [\n    createAccountInstruction,\n    newAddress,\n  ] = await createAssociatedTokenAccountIx(\n    owner.publicKey,\n    destinationPublicKey,\n    mint,\n  );\n  let transaction = new Transaction();\n  transaction.add(\n    assertOwner({\n      account: destinationPublicKey,\n      owner: SystemProgram.programId,\n    }),\n  );\n  transaction.add(createAccountInstruction);\n  const transferBetweenAccountsTxn = createTransferBetweenSplTokenAccountsInstruction(\n    {\n      ownerPublicKey: owner.publicKey,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey: newAddress,\n      amount,\n      memo,\n    },\n  );\n  transaction.add(transferBetweenAccountsTxn);\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nexport async function closeTokenAccount({\n  connection,\n  owner,\n  sourcePublicKey,\n  skipPreflight,\n}) {\n  let transaction = new Transaction().add(\n    closeAccount({\n      source: sourcePublicKey,\n      destination: owner.publicKey,\n      owner: owner.publicKey,\n    }),\n  );\n  let signers = [];\n  return await signAndSendTransaction(\n    connection,\n    transaction,\n    owner,\n    signers,\n    skipPreflight,\n  );\n}\n"]},"metadata":{},"sourceType":"module"}