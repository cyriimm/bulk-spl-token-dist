{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMintDecimals = exports.Orderbook = exports.ORDERBOOK_LAYOUT = exports.OpenOrders = exports._OPEN_ORDERS_LAYOUT_V2 = exports._OPEN_ORDERS_LAYOUT_V1 = exports.Market = exports._MARKET_STATE_LAYOUT_V2 = exports._MARKET_STAT_LAYOUT_V1 = void 0;\n\nconst buffer_layout_1 = require(\"buffer-layout\");\n\nconst layout_1 = require(\"./layout\");\n\nconst slab_1 = require(\"./slab\");\n\nconst instructions_1 = require(\"./instructions\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst queue_1 = require(\"./queue\");\n\nconst buffer_1 = require(\"buffer\");\n\nconst fees_1 = require(\"./fees\");\n\nconst token_instructions_1 = require(\"./token-instructions\");\n\nconst tokens_and_markets_1 = require(\"./tokens_and_markets\");\n\nexports._MARKET_STAT_LAYOUT_V1 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('ownAddress'), layout_1.u64('vaultSignerNonce'), layout_1.publicKeyLayout('baseMint'), layout_1.publicKeyLayout('quoteMint'), layout_1.publicKeyLayout('baseVault'), layout_1.u64('baseDepositsTotal'), layout_1.u64('baseFeesAccrued'), layout_1.publicKeyLayout('quoteVault'), layout_1.u64('quoteDepositsTotal'), layout_1.u64('quoteFeesAccrued'), layout_1.u64('quoteDustThreshold'), layout_1.publicKeyLayout('requestQueue'), layout_1.publicKeyLayout('eventQueue'), layout_1.publicKeyLayout('bids'), layout_1.publicKeyLayout('asks'), layout_1.u64('baseLotSize'), layout_1.u64('quoteLotSize'), layout_1.u64('feeRateBps'), buffer_layout_1.blob(7)]);\nexports._MARKET_STATE_LAYOUT_V2 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('ownAddress'), layout_1.u64('vaultSignerNonce'), layout_1.publicKeyLayout('baseMint'), layout_1.publicKeyLayout('quoteMint'), layout_1.publicKeyLayout('baseVault'), layout_1.u64('baseDepositsTotal'), layout_1.u64('baseFeesAccrued'), layout_1.publicKeyLayout('quoteVault'), layout_1.u64('quoteDepositsTotal'), layout_1.u64('quoteFeesAccrued'), layout_1.u64('quoteDustThreshold'), layout_1.publicKeyLayout('requestQueue'), layout_1.publicKeyLayout('eventQueue'), layout_1.publicKeyLayout('bids'), layout_1.publicKeyLayout('asks'), layout_1.u64('baseLotSize'), layout_1.u64('quoteLotSize'), layout_1.u64('feeRateBps'), layout_1.u64('referrerRebatesAccrued'), buffer_layout_1.blob(7)]);\n\nclass Market {\n  constructor(decoded, baseMintDecimals, quoteMintDecimals, options = {}, programId) {\n    const {\n      skipPreflight = false,\n      commitment = 'recent'\n    } = options;\n\n    if (!decoded.accountFlags.initialized || !decoded.accountFlags.market) {\n      throw new Error('Invalid market state');\n    }\n\n    this._decoded = decoded;\n    this._baseSplTokenDecimals = baseMintDecimals;\n    this._quoteSplTokenDecimals = quoteMintDecimals;\n    this._skipPreflight = skipPreflight;\n    this._commitment = commitment;\n    this._programId = programId;\n    this._openOrdersAccountsCache = {};\n    this._feeDiscountKeysCache = {};\n  }\n\n  static getLayout(programId) {\n    if (tokens_and_markets_1.getLayoutVersion(programId) === 1) {\n      return exports._MARKET_STAT_LAYOUT_V1;\n    }\n\n    return exports._MARKET_STATE_LAYOUT_V2;\n  }\n\n  static async findAccountsByMints(connection, baseMintAddress, quoteMintAddress, programId) {\n    const filters = [{\n      memcmp: {\n        offset: this.getLayout(programId).offsetOf('baseMint'),\n        bytes: baseMintAddress.toBase58()\n      }\n    }, {\n      memcmp: {\n        offset: Market.getLayout(programId).offsetOf('quoteMint'),\n        bytes: quoteMintAddress.toBase58()\n      }\n    }];\n    return getFilteredProgramAccounts(connection, programId, filters);\n  }\n\n  static async load(connection, address, options = {}, programId) {\n    const {\n      owner,\n      data\n    } = throwIfNull(await connection.getAccountInfo(address), 'Market not found');\n\n    if (!owner.equals(programId)) {\n      throw new Error('Address not owned by program: ' + owner.toBase58());\n    }\n\n    const decoded = this.getLayout(programId).decode(data);\n\n    if (!decoded.accountFlags.initialized || !decoded.accountFlags.market || !decoded.ownAddress.equals(address)) {\n      throw new Error('Invalid market');\n    }\n\n    const [baseMintDecimals, quoteMintDecimals] = await Promise.all([getMintDecimals(connection, decoded.baseMint), getMintDecimals(connection, decoded.quoteMint)]);\n    return new Market(decoded, baseMintDecimals, quoteMintDecimals, options, programId);\n  }\n\n  get programId() {\n    return this._programId;\n  }\n\n  get address() {\n    return this._decoded.ownAddress;\n  }\n\n  get publicKey() {\n    return this.address;\n  }\n\n  get baseMintAddress() {\n    return this._decoded.baseMint;\n  }\n\n  get quoteMintAddress() {\n    return this._decoded.quoteMint;\n  }\n\n  get bidsAddress() {\n    return this._decoded.bids;\n  }\n\n  get asksAddress() {\n    return this._decoded.asks;\n  }\n\n  async loadBids(connection) {\n    const {\n      data\n    } = throwIfNull(await connection.getAccountInfo(this._decoded.bids));\n    return Orderbook.decode(this, data);\n  }\n\n  async loadAsks(connection) {\n    const {\n      data\n    } = throwIfNull(await connection.getAccountInfo(this._decoded.asks));\n    return Orderbook.decode(this, data);\n  }\n\n  async loadOrdersForOwner(connection, ownerAddress, cacheDurationMs = 0) {\n    const [bids, asks, openOrdersAccounts] = await Promise.all([this.loadBids(connection), this.loadAsks(connection), this.findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs)]);\n    return this.filterForOpenOrders(bids, asks, openOrdersAccounts);\n  }\n\n  filterForOpenOrders(bids, asks, openOrdersAccounts) {\n    return [...bids, ...asks].filter(order => openOrdersAccounts.some(openOrders => order.openOrdersAddress.equals(openOrders.address)));\n  }\n\n  async findBaseTokenAccountsForOwner(connection, ownerAddress, includeUnwrappedSol = false) {\n    if (this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && includeUnwrappedSol) {\n      const [wrapped, unwrapped] = await Promise.all([this.findBaseTokenAccountsForOwner(connection, ownerAddress, false), connection.getAccountInfo(ownerAddress)]);\n\n      if (unwrapped !== null) {\n        return [{\n          pubkey: ownerAddress,\n          account: unwrapped\n        }, ...wrapped];\n      }\n\n      return wrapped;\n    }\n\n    return await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, this.baseMintAddress);\n  }\n\n  async getTokenAccountsByOwnerForMint(connection, ownerAddress, mintAddress) {\n    return (await connection.getTokenAccountsByOwner(ownerAddress, {\n      mint: mintAddress\n    })).value;\n  }\n\n  async findQuoteTokenAccountsForOwner(connection, ownerAddress, includeUnwrappedSol = false) {\n    if (this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && includeUnwrappedSol) {\n      const [wrapped, unwrapped] = await Promise.all([this.findQuoteTokenAccountsForOwner(connection, ownerAddress, false), connection.getAccountInfo(ownerAddress)]);\n\n      if (unwrapped !== null) {\n        return [{\n          pubkey: ownerAddress,\n          account: unwrapped\n        }, ...wrapped];\n      }\n\n      return wrapped;\n    }\n\n    return await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, this.quoteMintAddress);\n  }\n\n  async findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs = 0) {\n    const strOwner = ownerAddress.toBase58();\n    const now = new Date().getTime();\n\n    if (strOwner in this._openOrdersAccountsCache && now - this._openOrdersAccountsCache[strOwner].ts < cacheDurationMs) {\n      return this._openOrdersAccountsCache[strOwner].accounts;\n    }\n\n    const openOrdersAccountsForOwner = await OpenOrders.findForMarketAndOwner(connection, this.address, ownerAddress, this._programId);\n    this._openOrdersAccountsCache[strOwner] = {\n      accounts: openOrdersAccountsForOwner,\n      ts: now\n    };\n    return openOrdersAccountsForOwner;\n  }\n\n  async placeOrder(connection, {\n    owner,\n    payer,\n    side,\n    price,\n    size,\n    orderType = 'limit',\n    clientId,\n    openOrdersAddressKey,\n    openOrdersAccount,\n    feeDiscountPubkey\n  }) {\n    const {\n      transaction,\n      signers\n    } = await this.makePlaceOrderTransaction(connection, {\n      owner,\n      payer,\n      side,\n      price,\n      size,\n      orderType,\n      clientId,\n      openOrdersAddressKey,\n      openOrdersAccount,\n      feeDiscountPubkey\n    });\n    return await this._sendTransaction(connection, transaction, [owner, ...signers]);\n  }\n\n  getSplTokenBalanceFromAccountInfo(accountInfo, decimals) {\n    return divideBnToNumber(new bn_js_1.default(accountInfo.data.slice(64, 72), 10, 'le'), new bn_js_1.default(10).pow(new bn_js_1.default(decimals)));\n  }\n\n  get supportsSrmFeeDiscounts() {\n    return fees_1.supportsSrmFeeDiscounts(this._programId);\n  }\n\n  get supportsReferralFees() {\n    return tokens_and_markets_1.getLayoutVersion(this._programId) > 1;\n  }\n\n  get usesRequestQueue() {\n    return tokens_and_markets_1.getLayoutVersion(this._programId) <= 2;\n  }\n\n  async findFeeDiscountKeys(connection, ownerAddress, cacheDurationMs = 0) {\n    let sortedAccounts = [];\n    const now = new Date().getTime();\n    const strOwner = ownerAddress.toBase58();\n\n    if (strOwner in this._feeDiscountKeysCache && now - this._feeDiscountKeysCache[strOwner].ts < cacheDurationMs) {\n      return this._feeDiscountKeysCache[strOwner].accounts;\n    }\n\n    if (this.supportsSrmFeeDiscounts) {\n      // Fee discounts based on (M)SRM holdings supported in newer versions\n      const msrmAccounts = (await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, token_instructions_1.MSRM_MINT)).map(({\n        pubkey,\n        account\n      }) => {\n        const balance = this.getSplTokenBalanceFromAccountInfo(account, token_instructions_1.MSRM_DECIMALS);\n        return {\n          pubkey,\n          mint: token_instructions_1.MSRM_MINT,\n          balance,\n          feeTier: fees_1.getFeeTier(balance, 0)\n        };\n      });\n      const srmAccounts = (await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, token_instructions_1.SRM_MINT)).map(({\n        pubkey,\n        account\n      }) => {\n        const balance = this.getSplTokenBalanceFromAccountInfo(account, token_instructions_1.SRM_DECIMALS);\n        return {\n          pubkey,\n          mint: token_instructions_1.SRM_MINT,\n          balance,\n          feeTier: fees_1.getFeeTier(0, balance)\n        };\n      });\n      sortedAccounts = msrmAccounts.concat(srmAccounts).sort((a, b) => {\n        if (a.feeTier > b.feeTier) {\n          return -1;\n        } else if (a.feeTier < b.feeTier) {\n          return 1;\n        } else {\n          if (a.balance > b.balance) {\n            return -1;\n          } else if (a.balance < b.balance) {\n            return 1;\n          } else {\n            return 0;\n          }\n        }\n      });\n    }\n\n    this._feeDiscountKeysCache[strOwner] = {\n      accounts: sortedAccounts,\n      ts: now\n    };\n    return sortedAccounts;\n  }\n\n  async findBestFeeDiscountKey(connection, ownerAddress, cacheDurationMs = 30000) {\n    const accounts = await this.findFeeDiscountKeys(connection, ownerAddress, cacheDurationMs);\n\n    if (accounts.length > 0) {\n      return {\n        pubkey: accounts[0].pubkey,\n        feeTier: accounts[0].feeTier\n      };\n    }\n\n    return {\n      pubkey: null,\n      feeTier: 0\n    };\n  }\n\n  async makePlaceOrderTransaction(connection, {\n    owner,\n    payer,\n    side,\n    price,\n    size,\n    orderType = 'limit',\n    clientId,\n    openOrdersAddressKey,\n    openOrdersAccount,\n    feeDiscountPubkey = undefined,\n    selfTradeBehavior = 'decrementTake'\n  }, cacheDurationMs = 0, feeDiscountPubkeyCacheDurationMs = 0) {\n    var _a, _b; // @ts-ignore\n\n\n    const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;\n    const openOrdersAccounts = await this.findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs);\n    const transaction = new web3_js_1.Transaction();\n    const signers = []; // Fetch an SRM fee discount key if the market supports discounts and it is not supplied\n\n    let useFeeDiscountPubkey;\n\n    if (feeDiscountPubkey) {\n      useFeeDiscountPubkey = feeDiscountPubkey;\n    } else if (feeDiscountPubkey === undefined && this.supportsSrmFeeDiscounts) {\n      useFeeDiscountPubkey = (await this.findBestFeeDiscountKey(connection, ownerAddress, feeDiscountPubkeyCacheDurationMs)).pubkey;\n    } else {\n      useFeeDiscountPubkey = null;\n    }\n\n    let openOrdersAddress;\n\n    if (openOrdersAccounts.length === 0) {\n      let account;\n\n      if (openOrdersAccount) {\n        account = openOrdersAccount;\n      } else {\n        account = new web3_js_1.Account();\n      }\n\n      transaction.add(await OpenOrders.makeCreateAccountTransaction(connection, this.address, ownerAddress, account.publicKey, this._programId));\n      openOrdersAddress = account.publicKey;\n      signers.push(account); // refresh the cache of open order accounts on next fetch\n\n      this._openOrdersAccountsCache[ownerAddress.toBase58()].ts = 0;\n    } else if (openOrdersAccount) {\n      openOrdersAddress = openOrdersAccount.publicKey;\n    } else if (openOrdersAddressKey) {\n      openOrdersAddress = openOrdersAddressKey;\n    } else {\n      openOrdersAddress = openOrdersAccounts[0].address;\n    }\n\n    let wrappedSolAccount = null;\n\n    if (payer.equals(ownerAddress)) {\n      if (side === 'buy' && this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) || side === 'sell' && this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n        wrappedSolAccount = new web3_js_1.Account();\n        let lamports;\n\n        if (side === 'buy') {\n          lamports = Math.round(price * size * 1.01 * web3_js_1.LAMPORTS_PER_SOL);\n\n          if (openOrdersAccounts.length > 0) {\n            lamports -= openOrdersAccounts[0].quoteTokenFree.toNumber();\n          }\n        } else {\n          lamports = Math.round(size * web3_js_1.LAMPORTS_PER_SOL);\n\n          if (openOrdersAccounts.length > 0) {\n            lamports -= openOrdersAccounts[0].baseTokenFree.toNumber();\n          }\n        }\n\n        lamports = Math.max(lamports, 0) + 1e7;\n        transaction.add(web3_js_1.SystemProgram.createAccount({\n          fromPubkey: ownerAddress,\n          newAccountPubkey: wrappedSolAccount.publicKey,\n          lamports,\n          space: 165,\n          programId: token_instructions_1.TOKEN_PROGRAM_ID\n        }));\n        transaction.add(token_instructions_1.initializeAccount({\n          account: wrappedSolAccount.publicKey,\n          mint: token_instructions_1.WRAPPED_SOL_MINT,\n          owner: ownerAddress\n        }));\n        signers.push(wrappedSolAccount);\n      } else {\n        throw new Error('Invalid payer account');\n      }\n    }\n\n    const placeOrderInstruction = this.makePlaceOrderInstruction(connection, {\n      owner,\n      payer: (_b = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _b !== void 0 ? _b : payer,\n      side,\n      price,\n      size,\n      orderType,\n      clientId,\n      openOrdersAddressKey: openOrdersAddress,\n      feeDiscountPubkey: useFeeDiscountPubkey,\n      selfTradeBehavior\n    });\n    transaction.add(placeOrderInstruction);\n\n    if (wrappedSolAccount) {\n      transaction.add(token_instructions_1.closeAccount({\n        source: wrappedSolAccount.publicKey,\n        destination: ownerAddress,\n        owner: ownerAddress\n      }));\n    }\n\n    return {\n      transaction,\n      signers,\n      payer: owner\n    };\n  }\n\n  makePlaceOrderInstruction(connection, {\n    owner,\n    payer,\n    side,\n    price,\n    size,\n    orderType = 'limit',\n    clientId,\n    openOrdersAddressKey,\n    openOrdersAccount,\n    feeDiscountPubkey = null,\n    selfTradeBehavior = 'decrementTake'\n  }) {\n    var _a; // @ts-ignore\n\n\n    const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;\n\n    if (this.baseSizeNumberToLots(size).lte(new bn_js_1.default(0))) {\n      throw new Error('size too small');\n    }\n\n    if (this.priceNumberToLots(price).lte(new bn_js_1.default(0))) {\n      throw new Error('invalid price');\n    }\n\n    if (!this.supportsSrmFeeDiscounts) {\n      feeDiscountPubkey = null;\n    }\n\n    if (this.usesRequestQueue) {\n      return instructions_1.DexInstructions.newOrder({\n        market: this.address,\n        requestQueue: this._decoded.requestQueue,\n        baseVault: this._decoded.baseVault,\n        quoteVault: this._decoded.quoteVault,\n        openOrders: openOrdersAccount ? openOrdersAccount.publicKey : openOrdersAddressKey,\n        owner: ownerAddress,\n        payer,\n        side,\n        limitPrice: this.priceNumberToLots(price),\n        maxQuantity: this.baseSizeNumberToLots(size),\n        orderType,\n        clientId,\n        programId: this._programId,\n        feeDiscountPubkey\n      });\n    } else {\n      return instructions_1.DexInstructions.newOrderV3({\n        market: this.address,\n        bids: this._decoded.bids,\n        asks: this._decoded.asks,\n        requestQueue: this._decoded.requestQueue,\n        eventQueue: this._decoded.eventQueue,\n        baseVault: this._decoded.baseVault,\n        quoteVault: this._decoded.quoteVault,\n        openOrders: openOrdersAccount ? openOrdersAccount.publicKey : openOrdersAddressKey,\n        owner: ownerAddress,\n        payer,\n        side,\n        limitPrice: this.priceNumberToLots(price),\n        maxBaseQuantity: this.baseSizeNumberToLots(size),\n        maxQuoteQuantity: new bn_js_1.default(this._decoded.quoteLotSize.toNumber()).mul(this.baseSizeNumberToLots(size).mul(this.priceNumberToLots(price))),\n        orderType,\n        clientId,\n        programId: this._programId,\n        selfTradeBehavior,\n        feeDiscountPubkey\n      });\n    }\n  }\n\n  async _sendTransaction(connection, transaction, signers) {\n    const signature = await connection.sendTransaction(transaction, signers, {\n      skipPreflight: this._skipPreflight\n    });\n    const {\n      value\n    } = await connection.confirmTransaction(signature, this._commitment);\n\n    if (value === null || value === void 0 ? void 0 : value.err) {\n      throw new Error(JSON.stringify(value.err));\n    }\n\n    return signature;\n  }\n\n  async cancelOrderByClientId(connection, owner, openOrders, clientId) {\n    const transaction = await this.makeCancelOrderByClientIdTransaction(connection, owner.publicKey, openOrders, clientId);\n    return await this._sendTransaction(connection, transaction, [owner]);\n  }\n\n  async makeCancelOrderByClientIdTransaction(connection, owner, openOrders, clientId) {\n    const transaction = new web3_js_1.Transaction();\n\n    if (this.usesRequestQueue) {\n      transaction.add(instructions_1.DexInstructions.cancelOrderByClientId({\n        market: this.address,\n        owner,\n        openOrders,\n        requestQueue: this._decoded.requestQueue,\n        clientId,\n        programId: this._programId\n      }));\n    } else {\n      transaction.add(instructions_1.DexInstructions.cancelOrderByClientIdV2({\n        market: this.address,\n        openOrders,\n        owner,\n        bids: this._decoded.bids,\n        asks: this._decoded.asks,\n        eventQueue: this._decoded.eventQueue,\n        clientId,\n        programId: this._programId\n      }));\n    }\n\n    return transaction;\n  }\n\n  async cancelOrder(connection, owner, order) {\n    const transaction = await this.makeCancelOrderTransaction(connection, owner.publicKey, order);\n    return await this._sendTransaction(connection, transaction, [owner]);\n  }\n\n  async makeCancelOrderTransaction(connection, owner, order) {\n    const transaction = new web3_js_1.Transaction();\n    transaction.add(this.makeCancelOrderInstruction(connection, owner, order));\n    return transaction;\n  }\n\n  makeCancelOrderInstruction(connection, owner, order) {\n    if (this.usesRequestQueue) {\n      return instructions_1.DexInstructions.cancelOrder({\n        market: this.address,\n        owner,\n        openOrders: order.openOrdersAddress,\n        requestQueue: this._decoded.requestQueue,\n        side: order.side,\n        orderId: order.orderId,\n        openOrdersSlot: order.openOrdersSlot,\n        programId: this._programId\n      });\n    } else {\n      return instructions_1.DexInstructions.cancelOrderV2({\n        market: this.address,\n        owner,\n        openOrders: order.openOrdersAddress,\n        bids: this._decoded.bids,\n        asks: this._decoded.asks,\n        eventQueue: this._decoded.eventQueue,\n        side: order.side,\n        orderId: order.orderId,\n        openOrdersSlot: order.openOrdersSlot,\n        programId: this._programId\n      });\n    }\n  }\n\n  async settleFunds(connection, owner, openOrders, baseWallet, quoteWallet, referrerQuoteWallet = null) {\n    if (!openOrders.owner.equals(owner.publicKey)) {\n      throw new Error('Invalid open orders account');\n    }\n\n    if (referrerQuoteWallet && !this.supportsReferralFees) {\n      throw new Error('This program ID does not support referrerQuoteWallet');\n    }\n\n    const {\n      transaction,\n      signers\n    } = await this.makeSettleFundsTransaction(connection, openOrders, baseWallet, quoteWallet, referrerQuoteWallet);\n    return await this._sendTransaction(connection, transaction, [owner, ...signers]);\n  }\n\n  async makeSettleFundsTransaction(connection, openOrders, baseWallet, quoteWallet, referrerQuoteWallet = null) {\n    // @ts-ignore\n    const vaultSigner = await web3_js_1.PublicKey.createProgramAddress([this.address.toBuffer(), this._decoded.vaultSignerNonce.toArrayLike(buffer_1.Buffer, 'le', 8)], this._programId);\n    const transaction = new web3_js_1.Transaction();\n    const signers = [];\n    let wrappedSolAccount = null;\n\n    if (this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && baseWallet.equals(openOrders.owner) || this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && quoteWallet.equals(openOrders.owner)) {\n      wrappedSolAccount = new web3_js_1.Account();\n      transaction.add(web3_js_1.SystemProgram.createAccount({\n        fromPubkey: openOrders.owner,\n        newAccountPubkey: wrappedSolAccount.publicKey,\n        lamports: await connection.getMinimumBalanceForRentExemption(165),\n        space: 165,\n        programId: token_instructions_1.TOKEN_PROGRAM_ID\n      }));\n      transaction.add(token_instructions_1.initializeAccount({\n        account: wrappedSolAccount.publicKey,\n        mint: token_instructions_1.WRAPPED_SOL_MINT,\n        owner: openOrders.owner\n      }));\n      signers.push(wrappedSolAccount);\n    }\n\n    transaction.add(instructions_1.DexInstructions.settleFunds({\n      market: this.address,\n      openOrders: openOrders.address,\n      owner: openOrders.owner,\n      baseVault: this._decoded.baseVault,\n      quoteVault: this._decoded.quoteVault,\n      baseWallet: baseWallet.equals(openOrders.owner) && wrappedSolAccount ? wrappedSolAccount.publicKey : baseWallet,\n      quoteWallet: quoteWallet.equals(openOrders.owner) && wrappedSolAccount ? wrappedSolAccount.publicKey : quoteWallet,\n      vaultSigner,\n      programId: this._programId,\n      referrerQuoteWallet\n    }));\n\n    if (wrappedSolAccount) {\n      transaction.add(token_instructions_1.closeAccount({\n        source: wrappedSolAccount.publicKey,\n        destination: openOrders.owner,\n        owner: openOrders.owner\n      }));\n    }\n\n    return {\n      transaction,\n      signers,\n      payer: openOrders.owner\n    };\n  }\n\n  async matchOrders(connection, feePayer, limit) {\n    const tx = this.makeMatchOrdersTransaction(limit);\n    return await this._sendTransaction(connection, tx, [feePayer]);\n  }\n\n  makeMatchOrdersTransaction(limit) {\n    const tx = new web3_js_1.Transaction();\n    tx.add(instructions_1.DexInstructions.matchOrders({\n      market: this.address,\n      requestQueue: this._decoded.requestQueue,\n      eventQueue: this._decoded.eventQueue,\n      bids: this._decoded.bids,\n      asks: this._decoded.asks,\n      baseVault: this._decoded.baseVault,\n      quoteVault: this._decoded.quoteVault,\n      limit,\n      programId: this._programId\n    }));\n    return tx;\n  }\n\n  async loadRequestQueue(connection) {\n    const {\n      data\n    } = throwIfNull(await connection.getAccountInfo(this._decoded.requestQueue));\n    return queue_1.decodeRequestQueue(data);\n  }\n\n  async loadEventQueue(connection) {\n    const {\n      data\n    } = throwIfNull(await connection.getAccountInfo(this._decoded.eventQueue));\n    return queue_1.decodeEventQueue(data);\n  }\n\n  async loadFills(connection, limit = 100) {\n    // TODO: once there's a separate source of fills use that instead\n    const {\n      data\n    } = throwIfNull(await connection.getAccountInfo(this._decoded.eventQueue));\n    const events = queue_1.decodeEventQueue(data, limit);\n    return events.filter(event => event.eventFlags.fill && event.nativeQuantityPaid.gtn(0)).map(this.parseFillEvent.bind(this));\n  }\n\n  parseFillEvent(event) {\n    let size, price, side, priceBeforeFees;\n\n    if (event.eventFlags.bid) {\n      side = 'buy';\n      priceBeforeFees = event.eventFlags.maker ? event.nativeQuantityPaid.add(event.nativeFeeOrRebate) : event.nativeQuantityPaid.sub(event.nativeFeeOrRebate);\n      price = divideBnToNumber(priceBeforeFees.mul(this._baseSplTokenMultiplier), this._quoteSplTokenMultiplier.mul(event.nativeQuantityReleased));\n      size = divideBnToNumber(event.nativeQuantityReleased, this._baseSplTokenMultiplier);\n    } else {\n      side = 'sell';\n      priceBeforeFees = event.eventFlags.maker ? event.nativeQuantityReleased.sub(event.nativeFeeOrRebate) : event.nativeQuantityReleased.add(event.nativeFeeOrRebate);\n      price = divideBnToNumber(priceBeforeFees.mul(this._baseSplTokenMultiplier), this._quoteSplTokenMultiplier.mul(event.nativeQuantityPaid));\n      size = divideBnToNumber(event.nativeQuantityPaid, this._baseSplTokenMultiplier);\n    }\n\n    return { ...event,\n      side,\n      price,\n      feeCost: this.quoteSplSizeToNumber(event.nativeFeeOrRebate) * (event.eventFlags.maker ? -1 : 1),\n      size\n    };\n  }\n\n  get _baseSplTokenMultiplier() {\n    return new bn_js_1.default(10).pow(new bn_js_1.default(this._baseSplTokenDecimals));\n  }\n\n  get _quoteSplTokenMultiplier() {\n    return new bn_js_1.default(10).pow(new bn_js_1.default(this._quoteSplTokenDecimals));\n  }\n\n  priceLotsToNumber(price) {\n    return divideBnToNumber(price.mul(this._decoded.quoteLotSize).mul(this._baseSplTokenMultiplier), this._decoded.baseLotSize.mul(this._quoteSplTokenMultiplier));\n  }\n\n  priceNumberToLots(price) {\n    return new bn_js_1.default(Math.round(price * Math.pow(10, this._quoteSplTokenDecimals) * this._decoded.baseLotSize.toNumber() / (Math.pow(10, this._baseSplTokenDecimals) * this._decoded.quoteLotSize.toNumber())));\n  }\n\n  baseSplSizeToNumber(size) {\n    return divideBnToNumber(size, this._baseSplTokenMultiplier);\n  }\n\n  quoteSplSizeToNumber(size) {\n    return divideBnToNumber(size, this._quoteSplTokenMultiplier);\n  }\n\n  baseSizeLotsToNumber(size) {\n    return divideBnToNumber(size.mul(this._decoded.baseLotSize), this._baseSplTokenMultiplier);\n  }\n\n  baseSizeNumberToLots(size) {\n    const native = new bn_js_1.default(Math.round(size * Math.pow(10, this._baseSplTokenDecimals))); // rounds down to the nearest lot size\n\n    return native.div(this._decoded.baseLotSize);\n  }\n\n  quoteSizeLotsToNumber(size) {\n    return divideBnToNumber(size.mul(this._decoded.quoteLotSize), this._quoteSplTokenMultiplier);\n  }\n\n  quoteSizeNumberToLots(size) {\n    const native = new bn_js_1.default(Math.round(size * Math.pow(10, this._quoteSplTokenDecimals))); // rounds down to the nearest lot size\n\n    return native.div(this._decoded.quoteLotSize);\n  }\n\n  get minOrderSize() {\n    return this.baseSizeLotsToNumber(new bn_js_1.default(1));\n  }\n\n  get tickSize() {\n    return this.priceLotsToNumber(new bn_js_1.default(1));\n  }\n\n}\n\nexports.Market = Market;\nexports._OPEN_ORDERS_LAYOUT_V1 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('market'), layout_1.publicKeyLayout('owner'), // These are in spl-token (i.e. not lot) units\nlayout_1.u64('baseTokenFree'), layout_1.u64('baseTokenTotal'), layout_1.u64('quoteTokenFree'), layout_1.u64('quoteTokenTotal'), layout_1.u128('freeSlotBits'), layout_1.u128('isBidBits'), buffer_layout_1.seq(layout_1.u128(), 128, 'orders'), buffer_layout_1.seq(layout_1.u64(), 128, 'clientIds'), buffer_layout_1.blob(7)]);\nexports._OPEN_ORDERS_LAYOUT_V2 = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), layout_1.publicKeyLayout('market'), layout_1.publicKeyLayout('owner'), // These are in spl-token (i.e. not lot) units\nlayout_1.u64('baseTokenFree'), layout_1.u64('baseTokenTotal'), layout_1.u64('quoteTokenFree'), layout_1.u64('quoteTokenTotal'), layout_1.u128('freeSlotBits'), layout_1.u128('isBidBits'), buffer_layout_1.seq(layout_1.u128(), 128, 'orders'), buffer_layout_1.seq(layout_1.u64(), 128, 'clientIds'), layout_1.u64('referrerRebatesAccrued'), buffer_layout_1.blob(7)]);\n\nclass OpenOrders {\n  constructor(address, decoded, programId) {\n    this.address = address;\n    this._programId = programId;\n    Object.assign(this, decoded);\n  }\n\n  static getLayout(programId) {\n    if (tokens_and_markets_1.getLayoutVersion(programId) === 1) {\n      return exports._OPEN_ORDERS_LAYOUT_V1;\n    }\n\n    return exports._OPEN_ORDERS_LAYOUT_V2;\n  }\n\n  static async findForOwner(connection, ownerAddress, programId) {\n    const filters = [{\n      memcmp: {\n        offset: this.getLayout(programId).offsetOf('owner'),\n        bytes: ownerAddress.toBase58()\n      }\n    }, {\n      dataSize: this.getLayout(programId).span\n    }];\n    const accounts = await getFilteredProgramAccounts(connection, programId, filters);\n    return accounts.map(({\n      publicKey,\n      accountInfo\n    }) => OpenOrders.fromAccountInfo(publicKey, accountInfo, programId));\n  }\n\n  static async findForMarketAndOwner(connection, marketAddress, ownerAddress, programId) {\n    const filters = [{\n      memcmp: {\n        offset: this.getLayout(programId).offsetOf('market'),\n        bytes: marketAddress.toBase58()\n      }\n    }, {\n      memcmp: {\n        offset: this.getLayout(programId).offsetOf('owner'),\n        bytes: ownerAddress.toBase58()\n      }\n    }, {\n      dataSize: this.getLayout(programId).span\n    }];\n    const accounts = await getFilteredProgramAccounts(connection, programId, filters);\n    return accounts.map(({\n      publicKey,\n      accountInfo\n    }) => OpenOrders.fromAccountInfo(publicKey, accountInfo, programId));\n  }\n\n  static async load(connection, address, programId) {\n    const accountInfo = await connection.getAccountInfo(address);\n\n    if (accountInfo === null) {\n      throw new Error('Open orders account not found');\n    }\n\n    return OpenOrders.fromAccountInfo(address, accountInfo, programId);\n  }\n\n  static fromAccountInfo(address, accountInfo, programId) {\n    const {\n      owner,\n      data\n    } = accountInfo;\n\n    if (!owner.equals(programId)) {\n      throw new Error('Address not owned by program');\n    }\n\n    const decoded = this.getLayout(programId).decode(data);\n\n    if (!decoded.accountFlags.initialized || !decoded.accountFlags.openOrders) {\n      throw new Error('Invalid open orders account');\n    }\n\n    return new OpenOrders(address, decoded, programId);\n  }\n\n  static async makeCreateAccountTransaction(connection, marketAddress, ownerAddress, newAccountAddress, programId) {\n    return web3_js_1.SystemProgram.createAccount({\n      fromPubkey: ownerAddress,\n      newAccountPubkey: newAccountAddress,\n      lamports: await connection.getMinimumBalanceForRentExemption(this.getLayout(programId).span),\n      space: this.getLayout(programId).span,\n      programId\n    });\n  }\n\n  get publicKey() {\n    return this.address;\n  }\n\n}\n\nexports.OpenOrders = OpenOrders;\nexports.ORDERBOOK_LAYOUT = buffer_layout_1.struct([buffer_layout_1.blob(5), layout_1.accountFlagsLayout('accountFlags'), slab_1.SLAB_LAYOUT.replicate('slab'), buffer_layout_1.blob(7)]);\n\nclass Orderbook {\n  constructor(market, accountFlags, slab) {\n    if (!accountFlags.initialized || !(accountFlags.bids ^ accountFlags.asks)) {\n      throw new Error('Invalid orderbook');\n    }\n\n    this.market = market;\n    this.isBids = accountFlags.bids;\n    this.slab = slab;\n  }\n\n  static get LAYOUT() {\n    return exports.ORDERBOOK_LAYOUT;\n  }\n\n  static decode(market, buffer) {\n    const {\n      accountFlags,\n      slab\n    } = exports.ORDERBOOK_LAYOUT.decode(buffer);\n    return new Orderbook(market, accountFlags, slab);\n  }\n\n  getL2(depth) {\n    const descending = this.isBids;\n    const levels = []; // (price, size)\n\n    for (const {\n      key,\n      quantity\n    } of this.slab.items(descending)) {\n      const price = getPriceFromKey(key);\n\n      if (levels.length > 0 && levels[levels.length - 1][0].eq(price)) {\n        levels[levels.length - 1][1].iadd(quantity);\n      } else if (levels.length === depth) {\n        break;\n      } else {\n        levels.push([price, quantity]);\n      }\n    }\n\n    return levels.map(([priceLots, sizeLots]) => [this.market.priceLotsToNumber(priceLots), this.market.baseSizeLotsToNumber(sizeLots), priceLots, sizeLots]);\n  }\n\n  [Symbol.iterator]() {\n    return this.items(false);\n  }\n\n  *items(descending = false) {\n    for (const {\n      key,\n      ownerSlot,\n      owner,\n      quantity,\n      feeTier,\n      clientOrderId\n    } of this.slab.items(descending)) {\n      const price = getPriceFromKey(key);\n      yield {\n        orderId: key,\n        clientId: clientOrderId,\n        openOrdersAddress: owner,\n        openOrdersSlot: ownerSlot,\n        feeTier,\n        price: this.market.priceLotsToNumber(price),\n        priceLots: price,\n        size: this.market.baseSizeLotsToNumber(quantity),\n        sizeLots: quantity,\n        side: this.isBids ? 'buy' : 'sell'\n      };\n    }\n  }\n\n}\n\nexports.Orderbook = Orderbook;\n\nfunction getPriceFromKey(key) {\n  return key.ushrn(64);\n}\n\nfunction divideBnToNumber(numerator, denominator) {\n  const quotient = numerator.div(denominator).toNumber();\n  const rem = numerator.umod(denominator);\n  const gcd = rem.gcd(denominator);\n  return quotient + rem.div(gcd).toNumber() / denominator.div(gcd).toNumber();\n}\n\nconst MINT_LAYOUT = buffer_layout_1.struct([buffer_layout_1.blob(44), buffer_layout_1.u8('decimals'), buffer_layout_1.blob(37)]);\n\nasync function getMintDecimals(connection, mint) {\n  if (mint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n    return 9;\n  }\n\n  const {\n    data\n  } = throwIfNull(await connection.getAccountInfo(mint), 'mint not found');\n  const {\n    decimals\n  } = MINT_LAYOUT.decode(data);\n  return decimals;\n}\n\nexports.getMintDecimals = getMintDecimals;\n\nasync function getFilteredProgramAccounts(connection, programId, filters) {\n  // @ts-ignore\n  const resp = await connection._rpcRequest('getProgramAccounts', [programId.toBase58(), {\n    commitment: connection.commitment,\n    filters,\n    encoding: 'base64'\n  }]);\n\n  if (resp.error) {\n    throw new Error(resp.error.message);\n  }\n\n  return resp.result.map(({\n    pubkey,\n    account: {\n      data,\n      executable,\n      owner,\n      lamports\n    }\n  }) => ({\n    publicKey: new web3_js_1.PublicKey(pubkey),\n    accountInfo: {\n      data: buffer_1.Buffer.from(data[0], 'base64'),\n      executable,\n      owner: new web3_js_1.PublicKey(owner),\n      lamports\n    }\n  }));\n}\n\nfunction throwIfNull(value, message = 'account not found') {\n  if (value === null) {\n    throw new Error(message);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["../src/market.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getMintDecimals = exports.Orderbook = exports.ORDERBOOK_LAYOUT = exports.OpenOrders = exports._OPEN_ORDERS_LAYOUT_V2 = exports._OPEN_ORDERS_LAYOUT_V1 = exports.Market = exports._MARKET_STATE_LAYOUT_V2 = exports._MARKET_STAT_LAYOUT_V1 = void 0;\nconst buffer_layout_1 = require(\"buffer-layout\");\nconst layout_1 = require(\"./layout\");\nconst slab_1 = require(\"./slab\");\nconst instructions_1 = require(\"./instructions\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst queue_1 = require(\"./queue\");\nconst buffer_1 = require(\"buffer\");\nconst fees_1 = require(\"./fees\");\nconst token_instructions_1 = require(\"./token-instructions\");\nconst tokens_and_markets_1 = require(\"./tokens_and_markets\");\nexports._MARKET_STAT_LAYOUT_V1 = buffer_layout_1.struct([\n    buffer_layout_1.blob(5),\n    layout_1.accountFlagsLayout('accountFlags'),\n    layout_1.publicKeyLayout('ownAddress'),\n    layout_1.u64('vaultSignerNonce'),\n    layout_1.publicKeyLayout('baseMint'),\n    layout_1.publicKeyLayout('quoteMint'),\n    layout_1.publicKeyLayout('baseVault'),\n    layout_1.u64('baseDepositsTotal'),\n    layout_1.u64('baseFeesAccrued'),\n    layout_1.publicKeyLayout('quoteVault'),\n    layout_1.u64('quoteDepositsTotal'),\n    layout_1.u64('quoteFeesAccrued'),\n    layout_1.u64('quoteDustThreshold'),\n    layout_1.publicKeyLayout('requestQueue'),\n    layout_1.publicKeyLayout('eventQueue'),\n    layout_1.publicKeyLayout('bids'),\n    layout_1.publicKeyLayout('asks'),\n    layout_1.u64('baseLotSize'),\n    layout_1.u64('quoteLotSize'),\n    layout_1.u64('feeRateBps'),\n    buffer_layout_1.blob(7),\n]);\nexports._MARKET_STATE_LAYOUT_V2 = buffer_layout_1.struct([\n    buffer_layout_1.blob(5),\n    layout_1.accountFlagsLayout('accountFlags'),\n    layout_1.publicKeyLayout('ownAddress'),\n    layout_1.u64('vaultSignerNonce'),\n    layout_1.publicKeyLayout('baseMint'),\n    layout_1.publicKeyLayout('quoteMint'),\n    layout_1.publicKeyLayout('baseVault'),\n    layout_1.u64('baseDepositsTotal'),\n    layout_1.u64('baseFeesAccrued'),\n    layout_1.publicKeyLayout('quoteVault'),\n    layout_1.u64('quoteDepositsTotal'),\n    layout_1.u64('quoteFeesAccrued'),\n    layout_1.u64('quoteDustThreshold'),\n    layout_1.publicKeyLayout('requestQueue'),\n    layout_1.publicKeyLayout('eventQueue'),\n    layout_1.publicKeyLayout('bids'),\n    layout_1.publicKeyLayout('asks'),\n    layout_1.u64('baseLotSize'),\n    layout_1.u64('quoteLotSize'),\n    layout_1.u64('feeRateBps'),\n    layout_1.u64('referrerRebatesAccrued'),\n    buffer_layout_1.blob(7),\n]);\nclass Market {\n    constructor(decoded, baseMintDecimals, quoteMintDecimals, options = {}, programId) {\n        const { skipPreflight = false, commitment = 'recent' } = options;\n        if (!decoded.accountFlags.initialized || !decoded.accountFlags.market) {\n            throw new Error('Invalid market state');\n        }\n        this._decoded = decoded;\n        this._baseSplTokenDecimals = baseMintDecimals;\n        this._quoteSplTokenDecimals = quoteMintDecimals;\n        this._skipPreflight = skipPreflight;\n        this._commitment = commitment;\n        this._programId = programId;\n        this._openOrdersAccountsCache = {};\n        this._feeDiscountKeysCache = {};\n    }\n    static getLayout(programId) {\n        if (tokens_and_markets_1.getLayoutVersion(programId) === 1) {\n            return exports._MARKET_STAT_LAYOUT_V1;\n        }\n        return exports._MARKET_STATE_LAYOUT_V2;\n    }\n    static async findAccountsByMints(connection, baseMintAddress, quoteMintAddress, programId) {\n        const filters = [\n            {\n                memcmp: {\n                    offset: this.getLayout(programId).offsetOf('baseMint'),\n                    bytes: baseMintAddress.toBase58(),\n                },\n            },\n            {\n                memcmp: {\n                    offset: Market.getLayout(programId).offsetOf('quoteMint'),\n                    bytes: quoteMintAddress.toBase58(),\n                },\n            },\n        ];\n        return getFilteredProgramAccounts(connection, programId, filters);\n    }\n    static async load(connection, address, options = {}, programId) {\n        const { owner, data } = throwIfNull(await connection.getAccountInfo(address), 'Market not found');\n        if (!owner.equals(programId)) {\n            throw new Error('Address not owned by program: ' + owner.toBase58());\n        }\n        const decoded = this.getLayout(programId).decode(data);\n        if (!decoded.accountFlags.initialized ||\n            !decoded.accountFlags.market ||\n            !decoded.ownAddress.equals(address)) {\n            throw new Error('Invalid market');\n        }\n        const [baseMintDecimals, quoteMintDecimals] = await Promise.all([\n            getMintDecimals(connection, decoded.baseMint),\n            getMintDecimals(connection, decoded.quoteMint),\n        ]);\n        return new Market(decoded, baseMintDecimals, quoteMintDecimals, options, programId);\n    }\n    get programId() {\n        return this._programId;\n    }\n    get address() {\n        return this._decoded.ownAddress;\n    }\n    get publicKey() {\n        return this.address;\n    }\n    get baseMintAddress() {\n        return this._decoded.baseMint;\n    }\n    get quoteMintAddress() {\n        return this._decoded.quoteMint;\n    }\n    get bidsAddress() {\n        return this._decoded.bids;\n    }\n    get asksAddress() {\n        return this._decoded.asks;\n    }\n    async loadBids(connection) {\n        const { data } = throwIfNull(await connection.getAccountInfo(this._decoded.bids));\n        return Orderbook.decode(this, data);\n    }\n    async loadAsks(connection) {\n        const { data } = throwIfNull(await connection.getAccountInfo(this._decoded.asks));\n        return Orderbook.decode(this, data);\n    }\n    async loadOrdersForOwner(connection, ownerAddress, cacheDurationMs = 0) {\n        const [bids, asks, openOrdersAccounts] = await Promise.all([\n            this.loadBids(connection),\n            this.loadAsks(connection),\n            this.findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs),\n        ]);\n        return this.filterForOpenOrders(bids, asks, openOrdersAccounts);\n    }\n    filterForOpenOrders(bids, asks, openOrdersAccounts) {\n        return [...bids, ...asks].filter((order) => openOrdersAccounts.some((openOrders) => order.openOrdersAddress.equals(openOrders.address)));\n    }\n    async findBaseTokenAccountsForOwner(connection, ownerAddress, includeUnwrappedSol = false) {\n        if (this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && includeUnwrappedSol) {\n            const [wrapped, unwrapped] = await Promise.all([\n                this.findBaseTokenAccountsForOwner(connection, ownerAddress, false),\n                connection.getAccountInfo(ownerAddress),\n            ]);\n            if (unwrapped !== null) {\n                return [{ pubkey: ownerAddress, account: unwrapped }, ...wrapped];\n            }\n            return wrapped;\n        }\n        return await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, this.baseMintAddress);\n    }\n    async getTokenAccountsByOwnerForMint(connection, ownerAddress, mintAddress) {\n        return (await connection.getTokenAccountsByOwner(ownerAddress, {\n            mint: mintAddress,\n        })).value;\n    }\n    async findQuoteTokenAccountsForOwner(connection, ownerAddress, includeUnwrappedSol = false) {\n        if (this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) && includeUnwrappedSol) {\n            const [wrapped, unwrapped] = await Promise.all([\n                this.findQuoteTokenAccountsForOwner(connection, ownerAddress, false),\n                connection.getAccountInfo(ownerAddress),\n            ]);\n            if (unwrapped !== null) {\n                return [{ pubkey: ownerAddress, account: unwrapped }, ...wrapped];\n            }\n            return wrapped;\n        }\n        return await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, this.quoteMintAddress);\n    }\n    async findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs = 0) {\n        const strOwner = ownerAddress.toBase58();\n        const now = new Date().getTime();\n        if (strOwner in this._openOrdersAccountsCache &&\n            now - this._openOrdersAccountsCache[strOwner].ts < cacheDurationMs) {\n            return this._openOrdersAccountsCache[strOwner].accounts;\n        }\n        const openOrdersAccountsForOwner = await OpenOrders.findForMarketAndOwner(connection, this.address, ownerAddress, this._programId);\n        this._openOrdersAccountsCache[strOwner] = {\n            accounts: openOrdersAccountsForOwner,\n            ts: now,\n        };\n        return openOrdersAccountsForOwner;\n    }\n    async placeOrder(connection, { owner, payer, side, price, size, orderType = 'limit', clientId, openOrdersAddressKey, openOrdersAccount, feeDiscountPubkey, }) {\n        const { transaction, signers, } = await this.makePlaceOrderTransaction(connection, {\n            owner,\n            payer,\n            side,\n            price,\n            size,\n            orderType,\n            clientId,\n            openOrdersAddressKey,\n            openOrdersAccount,\n            feeDiscountPubkey,\n        });\n        return await this._sendTransaction(connection, transaction, [\n            owner,\n            ...signers,\n        ]);\n    }\n    getSplTokenBalanceFromAccountInfo(accountInfo, decimals) {\n        return divideBnToNumber(new bn_js_1.default(accountInfo.data.slice(64, 72), 10, 'le'), new bn_js_1.default(10).pow(new bn_js_1.default(decimals)));\n    }\n    get supportsSrmFeeDiscounts() {\n        return fees_1.supportsSrmFeeDiscounts(this._programId);\n    }\n    get supportsReferralFees() {\n        return tokens_and_markets_1.getLayoutVersion(this._programId) > 1;\n    }\n    get usesRequestQueue() {\n        return tokens_and_markets_1.getLayoutVersion(this._programId) <= 2;\n    }\n    async findFeeDiscountKeys(connection, ownerAddress, cacheDurationMs = 0) {\n        let sortedAccounts = [];\n        const now = new Date().getTime();\n        const strOwner = ownerAddress.toBase58();\n        if (strOwner in this._feeDiscountKeysCache &&\n            now - this._feeDiscountKeysCache[strOwner].ts < cacheDurationMs) {\n            return this._feeDiscountKeysCache[strOwner].accounts;\n        }\n        if (this.supportsSrmFeeDiscounts) {\n            // Fee discounts based on (M)SRM holdings supported in newer versions\n            const msrmAccounts = (await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, token_instructions_1.MSRM_MINT)).map(({ pubkey, account }) => {\n                const balance = this.getSplTokenBalanceFromAccountInfo(account, token_instructions_1.MSRM_DECIMALS);\n                return {\n                    pubkey,\n                    mint: token_instructions_1.MSRM_MINT,\n                    balance,\n                    feeTier: fees_1.getFeeTier(balance, 0),\n                };\n            });\n            const srmAccounts = (await this.getTokenAccountsByOwnerForMint(connection, ownerAddress, token_instructions_1.SRM_MINT)).map(({ pubkey, account }) => {\n                const balance = this.getSplTokenBalanceFromAccountInfo(account, token_instructions_1.SRM_DECIMALS);\n                return {\n                    pubkey,\n                    mint: token_instructions_1.SRM_MINT,\n                    balance,\n                    feeTier: fees_1.getFeeTier(0, balance),\n                };\n            });\n            sortedAccounts = msrmAccounts.concat(srmAccounts).sort((a, b) => {\n                if (a.feeTier > b.feeTier) {\n                    return -1;\n                }\n                else if (a.feeTier < b.feeTier) {\n                    return 1;\n                }\n                else {\n                    if (a.balance > b.balance) {\n                        return -1;\n                    }\n                    else if (a.balance < b.balance) {\n                        return 1;\n                    }\n                    else {\n                        return 0;\n                    }\n                }\n            });\n        }\n        this._feeDiscountKeysCache[strOwner] = {\n            accounts: sortedAccounts,\n            ts: now,\n        };\n        return sortedAccounts;\n    }\n    async findBestFeeDiscountKey(connection, ownerAddress, cacheDurationMs = 30000) {\n        const accounts = await this.findFeeDiscountKeys(connection, ownerAddress, cacheDurationMs);\n        if (accounts.length > 0) {\n            return {\n                pubkey: accounts[0].pubkey,\n                feeTier: accounts[0].feeTier,\n            };\n        }\n        return {\n            pubkey: null,\n            feeTier: 0,\n        };\n    }\n    async makePlaceOrderTransaction(connection, { owner, payer, side, price, size, orderType = 'limit', clientId, openOrdersAddressKey, openOrdersAccount, feeDiscountPubkey = undefined, selfTradeBehavior = 'decrementTake', }, cacheDurationMs = 0, feeDiscountPubkeyCacheDurationMs = 0) {\n        var _a, _b;\n        // @ts-ignore\n        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;\n        const openOrdersAccounts = await this.findOpenOrdersAccountsForOwner(connection, ownerAddress, cacheDurationMs);\n        const transaction = new web3_js_1.Transaction();\n        const signers = [];\n        // Fetch an SRM fee discount key if the market supports discounts and it is not supplied\n        let useFeeDiscountPubkey;\n        if (feeDiscountPubkey) {\n            useFeeDiscountPubkey = feeDiscountPubkey;\n        }\n        else if (feeDiscountPubkey === undefined &&\n            this.supportsSrmFeeDiscounts) {\n            useFeeDiscountPubkey = (await this.findBestFeeDiscountKey(connection, ownerAddress, feeDiscountPubkeyCacheDurationMs)).pubkey;\n        }\n        else {\n            useFeeDiscountPubkey = null;\n        }\n        let openOrdersAddress;\n        if (openOrdersAccounts.length === 0) {\n            let account;\n            if (openOrdersAccount) {\n                account = openOrdersAccount;\n            }\n            else {\n                account = new web3_js_1.Account();\n            }\n            transaction.add(await OpenOrders.makeCreateAccountTransaction(connection, this.address, ownerAddress, account.publicKey, this._programId));\n            openOrdersAddress = account.publicKey;\n            signers.push(account);\n            // refresh the cache of open order accounts on next fetch\n            this._openOrdersAccountsCache[ownerAddress.toBase58()].ts = 0;\n        }\n        else if (openOrdersAccount) {\n            openOrdersAddress = openOrdersAccount.publicKey;\n        }\n        else if (openOrdersAddressKey) {\n            openOrdersAddress = openOrdersAddressKey;\n        }\n        else {\n            openOrdersAddress = openOrdersAccounts[0].address;\n        }\n        let wrappedSolAccount = null;\n        if (payer.equals(ownerAddress)) {\n            if ((side === 'buy' && this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT)) ||\n                (side === 'sell' && this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT))) {\n                wrappedSolAccount = new web3_js_1.Account();\n                let lamports;\n                if (side === 'buy') {\n                    lamports = Math.round(price * size * 1.01 * web3_js_1.LAMPORTS_PER_SOL);\n                    if (openOrdersAccounts.length > 0) {\n                        lamports -= openOrdersAccounts[0].quoteTokenFree.toNumber();\n                    }\n                }\n                else {\n                    lamports = Math.round(size * web3_js_1.LAMPORTS_PER_SOL);\n                    if (openOrdersAccounts.length > 0) {\n                        lamports -= openOrdersAccounts[0].baseTokenFree.toNumber();\n                    }\n                }\n                lamports = Math.max(lamports, 0) + 1e7;\n                transaction.add(web3_js_1.SystemProgram.createAccount({\n                    fromPubkey: ownerAddress,\n                    newAccountPubkey: wrappedSolAccount.publicKey,\n                    lamports,\n                    space: 165,\n                    programId: token_instructions_1.TOKEN_PROGRAM_ID,\n                }));\n                transaction.add(token_instructions_1.initializeAccount({\n                    account: wrappedSolAccount.publicKey,\n                    mint: token_instructions_1.WRAPPED_SOL_MINT,\n                    owner: ownerAddress,\n                }));\n                signers.push(wrappedSolAccount);\n            }\n            else {\n                throw new Error('Invalid payer account');\n            }\n        }\n        const placeOrderInstruction = this.makePlaceOrderInstruction(connection, {\n            owner,\n            payer: (_b = wrappedSolAccount === null || wrappedSolAccount === void 0 ? void 0 : wrappedSolAccount.publicKey) !== null && _b !== void 0 ? _b : payer,\n            side,\n            price,\n            size,\n            orderType,\n            clientId,\n            openOrdersAddressKey: openOrdersAddress,\n            feeDiscountPubkey: useFeeDiscountPubkey,\n            selfTradeBehavior,\n        });\n        transaction.add(placeOrderInstruction);\n        if (wrappedSolAccount) {\n            transaction.add(token_instructions_1.closeAccount({\n                source: wrappedSolAccount.publicKey,\n                destination: ownerAddress,\n                owner: ownerAddress,\n            }));\n        }\n        return { transaction, signers, payer: owner };\n    }\n    makePlaceOrderInstruction(connection, { owner, payer, side, price, size, orderType = 'limit', clientId, openOrdersAddressKey, openOrdersAccount, feeDiscountPubkey = null, selfTradeBehavior = 'decrementTake', }) {\n        var _a;\n        // @ts-ignore\n        const ownerAddress = (_a = owner.publicKey) !== null && _a !== void 0 ? _a : owner;\n        if (this.baseSizeNumberToLots(size).lte(new bn_js_1.default(0))) {\n            throw new Error('size too small');\n        }\n        if (this.priceNumberToLots(price).lte(new bn_js_1.default(0))) {\n            throw new Error('invalid price');\n        }\n        if (!this.supportsSrmFeeDiscounts) {\n            feeDiscountPubkey = null;\n        }\n        if (this.usesRequestQueue) {\n            return instructions_1.DexInstructions.newOrder({\n                market: this.address,\n                requestQueue: this._decoded.requestQueue,\n                baseVault: this._decoded.baseVault,\n                quoteVault: this._decoded.quoteVault,\n                openOrders: openOrdersAccount\n                    ? openOrdersAccount.publicKey\n                    : openOrdersAddressKey,\n                owner: ownerAddress,\n                payer,\n                side,\n                limitPrice: this.priceNumberToLots(price),\n                maxQuantity: this.baseSizeNumberToLots(size),\n                orderType,\n                clientId,\n                programId: this._programId,\n                feeDiscountPubkey,\n            });\n        }\n        else {\n            return instructions_1.DexInstructions.newOrderV3({\n                market: this.address,\n                bids: this._decoded.bids,\n                asks: this._decoded.asks,\n                requestQueue: this._decoded.requestQueue,\n                eventQueue: this._decoded.eventQueue,\n                baseVault: this._decoded.baseVault,\n                quoteVault: this._decoded.quoteVault,\n                openOrders: openOrdersAccount\n                    ? openOrdersAccount.publicKey\n                    : openOrdersAddressKey,\n                owner: ownerAddress,\n                payer,\n                side,\n                limitPrice: this.priceNumberToLots(price),\n                maxBaseQuantity: this.baseSizeNumberToLots(size),\n                maxQuoteQuantity: new bn_js_1.default(this._decoded.quoteLotSize.toNumber()).mul(this.baseSizeNumberToLots(size).mul(this.priceNumberToLots(price))),\n                orderType,\n                clientId,\n                programId: this._programId,\n                selfTradeBehavior,\n                feeDiscountPubkey,\n            });\n        }\n    }\n    async _sendTransaction(connection, transaction, signers) {\n        const signature = await connection.sendTransaction(transaction, signers, {\n            skipPreflight: this._skipPreflight,\n        });\n        const { value } = await connection.confirmTransaction(signature, this._commitment);\n        if (value === null || value === void 0 ? void 0 : value.err) {\n            throw new Error(JSON.stringify(value.err));\n        }\n        return signature;\n    }\n    async cancelOrderByClientId(connection, owner, openOrders, clientId) {\n        const transaction = await this.makeCancelOrderByClientIdTransaction(connection, owner.publicKey, openOrders, clientId);\n        return await this._sendTransaction(connection, transaction, [owner]);\n    }\n    async makeCancelOrderByClientIdTransaction(connection, owner, openOrders, clientId) {\n        const transaction = new web3_js_1.Transaction();\n        if (this.usesRequestQueue) {\n            transaction.add(instructions_1.DexInstructions.cancelOrderByClientId({\n                market: this.address,\n                owner,\n                openOrders,\n                requestQueue: this._decoded.requestQueue,\n                clientId,\n                programId: this._programId,\n            }));\n        }\n        else {\n            transaction.add(instructions_1.DexInstructions.cancelOrderByClientIdV2({\n                market: this.address,\n                openOrders,\n                owner,\n                bids: this._decoded.bids,\n                asks: this._decoded.asks,\n                eventQueue: this._decoded.eventQueue,\n                clientId,\n                programId: this._programId,\n            }));\n        }\n        return transaction;\n    }\n    async cancelOrder(connection, owner, order) {\n        const transaction = await this.makeCancelOrderTransaction(connection, owner.publicKey, order);\n        return await this._sendTransaction(connection, transaction, [owner]);\n    }\n    async makeCancelOrderTransaction(connection, owner, order) {\n        const transaction = new web3_js_1.Transaction();\n        transaction.add(this.makeCancelOrderInstruction(connection, owner, order));\n        return transaction;\n    }\n    makeCancelOrderInstruction(connection, owner, order) {\n        if (this.usesRequestQueue) {\n            return instructions_1.DexInstructions.cancelOrder({\n                market: this.address,\n                owner,\n                openOrders: order.openOrdersAddress,\n                requestQueue: this._decoded.requestQueue,\n                side: order.side,\n                orderId: order.orderId,\n                openOrdersSlot: order.openOrdersSlot,\n                programId: this._programId,\n            });\n        }\n        else {\n            return instructions_1.DexInstructions.cancelOrderV2({\n                market: this.address,\n                owner,\n                openOrders: order.openOrdersAddress,\n                bids: this._decoded.bids,\n                asks: this._decoded.asks,\n                eventQueue: this._decoded.eventQueue,\n                side: order.side,\n                orderId: order.orderId,\n                openOrdersSlot: order.openOrdersSlot,\n                programId: this._programId,\n            });\n        }\n    }\n    async settleFunds(connection, owner, openOrders, baseWallet, quoteWallet, referrerQuoteWallet = null) {\n        if (!openOrders.owner.equals(owner.publicKey)) {\n            throw new Error('Invalid open orders account');\n        }\n        if (referrerQuoteWallet && !this.supportsReferralFees) {\n            throw new Error('This program ID does not support referrerQuoteWallet');\n        }\n        const { transaction, signers } = await this.makeSettleFundsTransaction(connection, openOrders, baseWallet, quoteWallet, referrerQuoteWallet);\n        return await this._sendTransaction(connection, transaction, [\n            owner,\n            ...signers,\n        ]);\n    }\n    async makeSettleFundsTransaction(connection, openOrders, baseWallet, quoteWallet, referrerQuoteWallet = null) {\n        // @ts-ignore\n        const vaultSigner = await web3_js_1.PublicKey.createProgramAddress([\n            this.address.toBuffer(),\n            this._decoded.vaultSignerNonce.toArrayLike(buffer_1.Buffer, 'le', 8),\n        ], this._programId);\n        const transaction = new web3_js_1.Transaction();\n        const signers = [];\n        let wrappedSolAccount = null;\n        if ((this.baseMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) &&\n            baseWallet.equals(openOrders.owner)) ||\n            (this.quoteMintAddress.equals(token_instructions_1.WRAPPED_SOL_MINT) &&\n                quoteWallet.equals(openOrders.owner))) {\n            wrappedSolAccount = new web3_js_1.Account();\n            transaction.add(web3_js_1.SystemProgram.createAccount({\n                fromPubkey: openOrders.owner,\n                newAccountPubkey: wrappedSolAccount.publicKey,\n                lamports: await connection.getMinimumBalanceForRentExemption(165),\n                space: 165,\n                programId: token_instructions_1.TOKEN_PROGRAM_ID,\n            }));\n            transaction.add(token_instructions_1.initializeAccount({\n                account: wrappedSolAccount.publicKey,\n                mint: token_instructions_1.WRAPPED_SOL_MINT,\n                owner: openOrders.owner,\n            }));\n            signers.push(wrappedSolAccount);\n        }\n        transaction.add(instructions_1.DexInstructions.settleFunds({\n            market: this.address,\n            openOrders: openOrders.address,\n            owner: openOrders.owner,\n            baseVault: this._decoded.baseVault,\n            quoteVault: this._decoded.quoteVault,\n            baseWallet: baseWallet.equals(openOrders.owner) && wrappedSolAccount\n                ? wrappedSolAccount.publicKey\n                : baseWallet,\n            quoteWallet: quoteWallet.equals(openOrders.owner) && wrappedSolAccount\n                ? wrappedSolAccount.publicKey\n                : quoteWallet,\n            vaultSigner,\n            programId: this._programId,\n            referrerQuoteWallet,\n        }));\n        if (wrappedSolAccount) {\n            transaction.add(token_instructions_1.closeAccount({\n                source: wrappedSolAccount.publicKey,\n                destination: openOrders.owner,\n                owner: openOrders.owner,\n            }));\n        }\n        return { transaction, signers, payer: openOrders.owner };\n    }\n    async matchOrders(connection, feePayer, limit) {\n        const tx = this.makeMatchOrdersTransaction(limit);\n        return await this._sendTransaction(connection, tx, [feePayer]);\n    }\n    makeMatchOrdersTransaction(limit) {\n        const tx = new web3_js_1.Transaction();\n        tx.add(instructions_1.DexInstructions.matchOrders({\n            market: this.address,\n            requestQueue: this._decoded.requestQueue,\n            eventQueue: this._decoded.eventQueue,\n            bids: this._decoded.bids,\n            asks: this._decoded.asks,\n            baseVault: this._decoded.baseVault,\n            quoteVault: this._decoded.quoteVault,\n            limit,\n            programId: this._programId,\n        }));\n        return tx;\n    }\n    async loadRequestQueue(connection) {\n        const { data } = throwIfNull(await connection.getAccountInfo(this._decoded.requestQueue));\n        return queue_1.decodeRequestQueue(data);\n    }\n    async loadEventQueue(connection) {\n        const { data } = throwIfNull(await connection.getAccountInfo(this._decoded.eventQueue));\n        return queue_1.decodeEventQueue(data);\n    }\n    async loadFills(connection, limit = 100) {\n        // TODO: once there's a separate source of fills use that instead\n        const { data } = throwIfNull(await connection.getAccountInfo(this._decoded.eventQueue));\n        const events = queue_1.decodeEventQueue(data, limit);\n        return events\n            .filter((event) => event.eventFlags.fill && event.nativeQuantityPaid.gtn(0))\n            .map(this.parseFillEvent.bind(this));\n    }\n    parseFillEvent(event) {\n        let size, price, side, priceBeforeFees;\n        if (event.eventFlags.bid) {\n            side = 'buy';\n            priceBeforeFees = event.eventFlags.maker\n                ? event.nativeQuantityPaid.add(event.nativeFeeOrRebate)\n                : event.nativeQuantityPaid.sub(event.nativeFeeOrRebate);\n            price = divideBnToNumber(priceBeforeFees.mul(this._baseSplTokenMultiplier), this._quoteSplTokenMultiplier.mul(event.nativeQuantityReleased));\n            size = divideBnToNumber(event.nativeQuantityReleased, this._baseSplTokenMultiplier);\n        }\n        else {\n            side = 'sell';\n            priceBeforeFees = event.eventFlags.maker\n                ? event.nativeQuantityReleased.sub(event.nativeFeeOrRebate)\n                : event.nativeQuantityReleased.add(event.nativeFeeOrRebate);\n            price = divideBnToNumber(priceBeforeFees.mul(this._baseSplTokenMultiplier), this._quoteSplTokenMultiplier.mul(event.nativeQuantityPaid));\n            size = divideBnToNumber(event.nativeQuantityPaid, this._baseSplTokenMultiplier);\n        }\n        return {\n            ...event,\n            side,\n            price,\n            feeCost: this.quoteSplSizeToNumber(event.nativeFeeOrRebate) *\n                (event.eventFlags.maker ? -1 : 1),\n            size,\n        };\n    }\n    get _baseSplTokenMultiplier() {\n        return new bn_js_1.default(10).pow(new bn_js_1.default(this._baseSplTokenDecimals));\n    }\n    get _quoteSplTokenMultiplier() {\n        return new bn_js_1.default(10).pow(new bn_js_1.default(this._quoteSplTokenDecimals));\n    }\n    priceLotsToNumber(price) {\n        return divideBnToNumber(price.mul(this._decoded.quoteLotSize).mul(this._baseSplTokenMultiplier), this._decoded.baseLotSize.mul(this._quoteSplTokenMultiplier));\n    }\n    priceNumberToLots(price) {\n        return new bn_js_1.default(Math.round((price *\n            Math.pow(10, this._quoteSplTokenDecimals) *\n            this._decoded.baseLotSize.toNumber()) /\n            (Math.pow(10, this._baseSplTokenDecimals) *\n                this._decoded.quoteLotSize.toNumber())));\n    }\n    baseSplSizeToNumber(size) {\n        return divideBnToNumber(size, this._baseSplTokenMultiplier);\n    }\n    quoteSplSizeToNumber(size) {\n        return divideBnToNumber(size, this._quoteSplTokenMultiplier);\n    }\n    baseSizeLotsToNumber(size) {\n        return divideBnToNumber(size.mul(this._decoded.baseLotSize), this._baseSplTokenMultiplier);\n    }\n    baseSizeNumberToLots(size) {\n        const native = new bn_js_1.default(Math.round(size * Math.pow(10, this._baseSplTokenDecimals)));\n        // rounds down to the nearest lot size\n        return native.div(this._decoded.baseLotSize);\n    }\n    quoteSizeLotsToNumber(size) {\n        return divideBnToNumber(size.mul(this._decoded.quoteLotSize), this._quoteSplTokenMultiplier);\n    }\n    quoteSizeNumberToLots(size) {\n        const native = new bn_js_1.default(Math.round(size * Math.pow(10, this._quoteSplTokenDecimals)));\n        // rounds down to the nearest lot size\n        return native.div(this._decoded.quoteLotSize);\n    }\n    get minOrderSize() {\n        return this.baseSizeLotsToNumber(new bn_js_1.default(1));\n    }\n    get tickSize() {\n        return this.priceLotsToNumber(new bn_js_1.default(1));\n    }\n}\nexports.Market = Market;\nexports._OPEN_ORDERS_LAYOUT_V1 = buffer_layout_1.struct([\n    buffer_layout_1.blob(5),\n    layout_1.accountFlagsLayout('accountFlags'),\n    layout_1.publicKeyLayout('market'),\n    layout_1.publicKeyLayout('owner'),\n    // These are in spl-token (i.e. not lot) units\n    layout_1.u64('baseTokenFree'),\n    layout_1.u64('baseTokenTotal'),\n    layout_1.u64('quoteTokenFree'),\n    layout_1.u64('quoteTokenTotal'),\n    layout_1.u128('freeSlotBits'),\n    layout_1.u128('isBidBits'),\n    buffer_layout_1.seq(layout_1.u128(), 128, 'orders'),\n    buffer_layout_1.seq(layout_1.u64(), 128, 'clientIds'),\n    buffer_layout_1.blob(7),\n]);\nexports._OPEN_ORDERS_LAYOUT_V2 = buffer_layout_1.struct([\n    buffer_layout_1.blob(5),\n    layout_1.accountFlagsLayout('accountFlags'),\n    layout_1.publicKeyLayout('market'),\n    layout_1.publicKeyLayout('owner'),\n    // These are in spl-token (i.e. not lot) units\n    layout_1.u64('baseTokenFree'),\n    layout_1.u64('baseTokenTotal'),\n    layout_1.u64('quoteTokenFree'),\n    layout_1.u64('quoteTokenTotal'),\n    layout_1.u128('freeSlotBits'),\n    layout_1.u128('isBidBits'),\n    buffer_layout_1.seq(layout_1.u128(), 128, 'orders'),\n    buffer_layout_1.seq(layout_1.u64(), 128, 'clientIds'),\n    layout_1.u64('referrerRebatesAccrued'),\n    buffer_layout_1.blob(7),\n]);\nclass OpenOrders {\n    constructor(address, decoded, programId) {\n        this.address = address;\n        this._programId = programId;\n        Object.assign(this, decoded);\n    }\n    static getLayout(programId) {\n        if (tokens_and_markets_1.getLayoutVersion(programId) === 1) {\n            return exports._OPEN_ORDERS_LAYOUT_V1;\n        }\n        return exports._OPEN_ORDERS_LAYOUT_V2;\n    }\n    static async findForOwner(connection, ownerAddress, programId) {\n        const filters = [\n            {\n                memcmp: {\n                    offset: this.getLayout(programId).offsetOf('owner'),\n                    bytes: ownerAddress.toBase58(),\n                },\n            },\n            {\n                dataSize: this.getLayout(programId).span,\n            },\n        ];\n        const accounts = await getFilteredProgramAccounts(connection, programId, filters);\n        return accounts.map(({ publicKey, accountInfo }) => OpenOrders.fromAccountInfo(publicKey, accountInfo, programId));\n    }\n    static async findForMarketAndOwner(connection, marketAddress, ownerAddress, programId) {\n        const filters = [\n            {\n                memcmp: {\n                    offset: this.getLayout(programId).offsetOf('market'),\n                    bytes: marketAddress.toBase58(),\n                },\n            },\n            {\n                memcmp: {\n                    offset: this.getLayout(programId).offsetOf('owner'),\n                    bytes: ownerAddress.toBase58(),\n                },\n            },\n            {\n                dataSize: this.getLayout(programId).span,\n            },\n        ];\n        const accounts = await getFilteredProgramAccounts(connection, programId, filters);\n        return accounts.map(({ publicKey, accountInfo }) => OpenOrders.fromAccountInfo(publicKey, accountInfo, programId));\n    }\n    static async load(connection, address, programId) {\n        const accountInfo = await connection.getAccountInfo(address);\n        if (accountInfo === null) {\n            throw new Error('Open orders account not found');\n        }\n        return OpenOrders.fromAccountInfo(address, accountInfo, programId);\n    }\n    static fromAccountInfo(address, accountInfo, programId) {\n        const { owner, data } = accountInfo;\n        if (!owner.equals(programId)) {\n            throw new Error('Address not owned by program');\n        }\n        const decoded = this.getLayout(programId).decode(data);\n        if (!decoded.accountFlags.initialized || !decoded.accountFlags.openOrders) {\n            throw new Error('Invalid open orders account');\n        }\n        return new OpenOrders(address, decoded, programId);\n    }\n    static async makeCreateAccountTransaction(connection, marketAddress, ownerAddress, newAccountAddress, programId) {\n        return web3_js_1.SystemProgram.createAccount({\n            fromPubkey: ownerAddress,\n            newAccountPubkey: newAccountAddress,\n            lamports: await connection.getMinimumBalanceForRentExemption(this.getLayout(programId).span),\n            space: this.getLayout(programId).span,\n            programId,\n        });\n    }\n    get publicKey() {\n        return this.address;\n    }\n}\nexports.OpenOrders = OpenOrders;\nexports.ORDERBOOK_LAYOUT = buffer_layout_1.struct([\n    buffer_layout_1.blob(5),\n    layout_1.accountFlagsLayout('accountFlags'),\n    slab_1.SLAB_LAYOUT.replicate('slab'),\n    buffer_layout_1.blob(7),\n]);\nclass Orderbook {\n    constructor(market, accountFlags, slab) {\n        if (!accountFlags.initialized || !(accountFlags.bids ^ accountFlags.asks)) {\n            throw new Error('Invalid orderbook');\n        }\n        this.market = market;\n        this.isBids = accountFlags.bids;\n        this.slab = slab;\n    }\n    static get LAYOUT() {\n        return exports.ORDERBOOK_LAYOUT;\n    }\n    static decode(market, buffer) {\n        const { accountFlags, slab } = exports.ORDERBOOK_LAYOUT.decode(buffer);\n        return new Orderbook(market, accountFlags, slab);\n    }\n    getL2(depth) {\n        const descending = this.isBids;\n        const levels = []; // (price, size)\n        for (const { key, quantity } of this.slab.items(descending)) {\n            const price = getPriceFromKey(key);\n            if (levels.length > 0 && levels[levels.length - 1][0].eq(price)) {\n                levels[levels.length - 1][1].iadd(quantity);\n            }\n            else if (levels.length === depth) {\n                break;\n            }\n            else {\n                levels.push([price, quantity]);\n            }\n        }\n        return levels.map(([priceLots, sizeLots]) => [\n            this.market.priceLotsToNumber(priceLots),\n            this.market.baseSizeLotsToNumber(sizeLots),\n            priceLots,\n            sizeLots,\n        ]);\n    }\n    [Symbol.iterator]() {\n        return this.items(false);\n    }\n    *items(descending = false) {\n        for (const { key, ownerSlot, owner, quantity, feeTier, clientOrderId, } of this.slab.items(descending)) {\n            const price = getPriceFromKey(key);\n            yield {\n                orderId: key,\n                clientId: clientOrderId,\n                openOrdersAddress: owner,\n                openOrdersSlot: ownerSlot,\n                feeTier,\n                price: this.market.priceLotsToNumber(price),\n                priceLots: price,\n                size: this.market.baseSizeLotsToNumber(quantity),\n                sizeLots: quantity,\n                side: (this.isBids ? 'buy' : 'sell'),\n            };\n        }\n    }\n}\nexports.Orderbook = Orderbook;\nfunction getPriceFromKey(key) {\n    return key.ushrn(64);\n}\nfunction divideBnToNumber(numerator, denominator) {\n    const quotient = numerator.div(denominator).toNumber();\n    const rem = numerator.umod(denominator);\n    const gcd = rem.gcd(denominator);\n    return quotient + rem.div(gcd).toNumber() / denominator.div(gcd).toNumber();\n}\nconst MINT_LAYOUT = buffer_layout_1.struct([buffer_layout_1.blob(44), buffer_layout_1.u8('decimals'), buffer_layout_1.blob(37)]);\nasync function getMintDecimals(connection, mint) {\n    if (mint.equals(token_instructions_1.WRAPPED_SOL_MINT)) {\n        return 9;\n    }\n    const { data } = throwIfNull(await connection.getAccountInfo(mint), 'mint not found');\n    const { decimals } = MINT_LAYOUT.decode(data);\n    return decimals;\n}\nexports.getMintDecimals = getMintDecimals;\nasync function getFilteredProgramAccounts(connection, programId, filters) {\n    // @ts-ignore\n    const resp = await connection._rpcRequest('getProgramAccounts', [\n        programId.toBase58(),\n        {\n            commitment: connection.commitment,\n            filters,\n            encoding: 'base64',\n        },\n    ]);\n    if (resp.error) {\n        throw new Error(resp.error.message);\n    }\n    return resp.result.map(({ pubkey, account: { data, executable, owner, lamports } }) => ({\n        publicKey: new web3_js_1.PublicKey(pubkey),\n        accountInfo: {\n            data: buffer_1.Buffer.from(data[0], 'base64'),\n            executable,\n            owner: new web3_js_1.PublicKey(owner),\n            lamports,\n        },\n    }));\n}\nfunction throwIfNull(value, message = 'account not found') {\n    if (value === null) {\n        throw new Error(message);\n    }\n    return value;\n}\n//# sourceMappingURL=market.js.map"]},"metadata":{},"sourceType":"script"}