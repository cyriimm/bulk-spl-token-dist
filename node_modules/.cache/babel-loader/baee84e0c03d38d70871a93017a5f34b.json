{"ast":null,"code":"var _jsxFileName = \"/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/wallet.js\",\n    _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$();\n\nimport React, { useContext, useEffect, useMemo, useState } from 'react';\nimport * as bs58 from 'bs58';\nimport { Account, PublicKey } from '@solana/web3.js';\nimport nacl from 'tweetnacl';\nimport { setInitialAccountInfo, useAccountInfo, useConnection } from './connection';\nimport { closeTokenAccount, createAndInitializeTokenAccount, createAssociatedTokenAccount, getOwnedTokenAccounts, nativeTransfer, transferTokens } from './tokens';\nimport { TOKEN_PROGRAM_ID } from './tokens/instructions';\nimport { ACCOUNT_LAYOUT, parseMintData, parseTokenAccountData } from './tokens/data';\nimport { useListener, useLocalStorageState, useRefEqual } from './utils';\nimport { useTokenInfo } from './tokens/names';\nimport { refreshCache, useAsyncData } from './fetch-loop';\nimport { useUnlockedMnemonicAndSeed, walletSeedChanged } from './wallet-seed';\nimport { WalletProviderFactory } from './walletProvider/factory';\nimport { getAccountFromSeed } from './walletProvider/localStorage';\nimport { useSnackbar } from 'notistack';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DEFAULT_WALLET_SELECTOR = {\n  walletIndex: 0,\n  importedPubkey: undefined,\n  ledger: false\n};\nexport class Wallet {\n  constructor(connection, type, args) {\n    this.getTokenAccountInfo = async () => {\n      let accounts = await getOwnedTokenAccounts(this.connection, this.publicKey);\n      return accounts.map(({\n        publicKey,\n        accountInfo\n      }) => {\n        setInitialAccountInfo(this.connection, publicKey, accountInfo);\n        return {\n          publicKey,\n          parsed: parseTokenAccountData(accountInfo.data)\n        };\n      }).sort((account1, account2) => account1.parsed.mint.toBase58().localeCompare(account2.parsed.mint.toBase58()));\n    };\n\n    this.createTokenAccount = async tokenAddress => {\n      return await createAndInitializeTokenAccount({\n        connection: this.connection,\n        payer: this,\n        mintPublicKey: tokenAddress,\n        newAccount: new Account()\n      });\n    };\n\n    this.createAssociatedTokenAccount = async splTokenMintAddress => {\n      return await createAssociatedTokenAccount({\n        connection: this.connection,\n        wallet: this,\n        splTokenMintAddress\n      });\n    };\n\n    this.tokenAccountCost = async () => {\n      return this.connection.getMinimumBalanceForRentExemption(ACCOUNT_LAYOUT.span);\n    };\n\n    this.transferToken = async (source, destination, amount, mint, decimals, memo = null, overrideDestinationCheck = false) => {\n      if (source.equals(this.publicKey)) {\n        if (memo) {\n          throw new Error('Memo not implemented');\n        }\n\n        return this.transferSol(destination, amount);\n      }\n\n      return await transferTokens({\n        connection: this.connection,\n        owner: this,\n        sourcePublicKey: source,\n        destinationPublicKey: destination,\n        amount,\n        memo,\n        mint,\n        decimals,\n        overrideDestinationCheck\n      });\n    };\n\n    this.transferSol = async (destination, amount) => {\n      return nativeTransfer(this.connection, this, destination, amount);\n    };\n\n    this.closeTokenAccount = async (publicKey, skipPreflight = false) => {\n      return await closeTokenAccount({\n        connection: this.connection,\n        owner: this,\n        sourcePublicKey: publicKey,\n        skipPreflight\n      });\n    };\n\n    this.signTransaction = async transaction => {\n      return this.provider.signTransaction(transaction);\n    };\n\n    this.createSignature = async message => {\n      return this.provider.createSignature(message);\n    };\n\n    this.connection = connection;\n    this.type = type;\n    this.provider = WalletProviderFactory.getProvider(type, args);\n  }\n\n  get publicKey() {\n    return this.provider.publicKey;\n  }\n\n  get allowsExport() {\n    return this.type === 'local';\n  }\n\n}\n\nWallet.create = async (connection, type, args) => {\n  const instance = new Wallet(connection, type, args);\n  await instance.provider.init();\n  return instance;\n};\n\nconst WalletContext = /*#__PURE__*/React.createContext(null);\nexport function WalletProvider({\n  children\n}) {\n  _s();\n\n  useListener(walletSeedChanged, 'change');\n  const [{\n    mnemonic,\n    seed,\n    importsEncryptionKey,\n    derivationPath\n  }] = useUnlockedMnemonicAndSeed();\n  const {\n    enqueueSnackbar\n  } = useSnackbar();\n  const connection = useConnection();\n  const [wallet, setWallet] = useState(); // `privateKeyImports` are accounts imported *in addition* to HD wallets\n\n  const [privateKeyImports, setPrivateKeyImports] = useLocalStorageState('walletPrivateKeyImports', {}); // `walletSelector` identifies which wallet to use.\n\n  let [walletSelector, setWalletSelector] = useLocalStorageState('walletSelector', DEFAULT_WALLET_SELECTOR);\n  const [_hardwareWalletAccount, setHardwareWalletAccount] = useState(null); // `walletCount` is the number of HD wallets.\n\n  const [walletCount, setWalletCount] = useLocalStorageState('walletCount', 1);\n\n  if (walletSelector.ledger && !_hardwareWalletAccount) {\n    walletSelector = DEFAULT_WALLET_SELECTOR;\n    setWalletSelector(DEFAULT_WALLET_SELECTOR);\n  }\n\n  useEffect(() => {\n    (async () => {\n      if (!seed) {\n        return null;\n      }\n\n      let wallet;\n\n      if (walletSelector.ledger) {\n        try {\n          const onDisconnect = () => {\n            setWalletSelector(DEFAULT_WALLET_SELECTOR);\n            setHardwareWalletAccount(null);\n          };\n\n          const args = {\n            onDisconnect,\n            derivationPath: walletSelector.derivationPath,\n            account: walletSelector.account,\n            change: walletSelector.change\n          };\n          wallet = await Wallet.create(connection, 'ledger', args);\n        } catch (e) {\n          console.log(`received error using ledger wallet: ${e}`);\n          let message = 'Received error unlocking ledger';\n\n          if (e.statusCode) {\n            message += `: ${e.statusCode}`;\n          }\n\n          enqueueSnackbar(message, {\n            variant: 'error'\n          });\n          setWalletSelector(DEFAULT_WALLET_SELECTOR);\n          setHardwareWalletAccount(null);\n          return;\n        }\n      }\n\n      if (!wallet) {\n        const account = walletSelector.walletIndex !== undefined ? getAccountFromSeed(Buffer.from(seed, 'hex'), walletSelector.walletIndex, derivationPath) : new Account((() => {\n          const {\n            nonce,\n            ciphertext\n          } = privateKeyImports[walletSelector.importedPubkey];\n          return nacl.secretbox.open(bs58.decode(ciphertext), bs58.decode(nonce), importsEncryptionKey);\n        })());\n        wallet = await Wallet.create(connection, 'local', {\n          account\n        });\n      }\n\n      setWallet(wallet);\n    })();\n  }, [connection, seed, walletSelector, privateKeyImports, importsEncryptionKey, setWalletSelector, enqueueSnackbar, derivationPath]);\n\n  function addAccount({\n    name,\n    importedAccount,\n    ledger\n  }) {\n    if (importedAccount === undefined) {\n      name && localStorage.setItem(`name${walletCount}`, name);\n      setWalletCount(walletCount + 1);\n    } else {\n      const nonce = nacl.randomBytes(nacl.secretbox.nonceLength);\n      const plaintext = importedAccount.secretKey;\n      const ciphertext = nacl.secretbox(plaintext, nonce, importsEncryptionKey); // `useLocalStorageState` requires a new object.\n\n      let newPrivateKeyImports = { ...privateKeyImports\n      };\n      newPrivateKeyImports[importedAccount.publicKey.toString()] = {\n        name,\n        ciphertext: bs58.encode(ciphertext),\n        nonce: bs58.encode(nonce)\n      };\n      setPrivateKeyImports(newPrivateKeyImports);\n    }\n  }\n\n  const getWalletNames = () => {\n    return JSON.stringify([...Array(walletCount).keys()].map(idx => localStorage.getItem(`name${idx}`)));\n  };\n\n  const [walletNames, setWalletNames] = useState(getWalletNames());\n\n  function setAccountName(selector, newName) {\n    if (selector.importedPubkey && !selector.ledger) {\n      let newPrivateKeyImports = { ...privateKeyImports\n      };\n      newPrivateKeyImports[selector.importedPubkey.toString()].name = newName;\n      setPrivateKeyImports(newPrivateKeyImports);\n    } else {\n      localStorage.setItem(`name${selector.walletIndex}`, newName);\n      setWalletNames(getWalletNames());\n    }\n  }\n\n  const [accounts, derivedAccounts] = useMemo(() => {\n    if (!seed) {\n      return [[], []];\n    }\n\n    const seedBuffer = Buffer.from(seed, 'hex');\n    const derivedAccounts = [...Array(walletCount).keys()].map(idx => {\n      let address = getAccountFromSeed(seedBuffer, idx, derivationPath).publicKey;\n      let name = localStorage.getItem(`name${idx}`);\n      return {\n        selector: {\n          walletIndex: idx,\n          importedPubkey: undefined,\n          ledger: false\n        },\n        isSelected: walletSelector.walletIndex === idx,\n        address,\n        name: idx === 0 ? 'Main account' : name || `Account ${idx}`\n      };\n    });\n    const importedAccounts = Object.keys(privateKeyImports).map(pubkey => {\n      const {\n        name\n      } = privateKeyImports[pubkey];\n      return {\n        selector: {\n          walletIndex: undefined,\n          importedPubkey: pubkey,\n          ledger: false\n        },\n        address: new PublicKey(bs58.decode(pubkey)),\n        name: `${name} (imported)`,\n        // TODO: do this in the Component with styling.\n        isSelected: walletSelector.importedPubkey === pubkey\n      };\n    });\n    const accounts = derivedAccounts.concat(importedAccounts);\n    return [accounts, derivedAccounts]; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [seed, walletCount, walletSelector, privateKeyImports, walletNames]);\n  let hardwareWalletAccount;\n\n  if (_hardwareWalletAccount) {\n    hardwareWalletAccount = { ..._hardwareWalletAccount,\n      selector: {\n        walletIndex: undefined,\n        ledger: true,\n        importedPubkey: _hardwareWalletAccount.publicKey,\n        derivationPath: _hardwareWalletAccount.derivationPath,\n        account: _hardwareWalletAccount.account,\n        change: _hardwareWalletAccount.change\n      },\n      address: _hardwareWalletAccount.publicKey,\n      isSelected: walletSelector.ledger\n    };\n  }\n\n  return /*#__PURE__*/_jsxDEV(WalletContext.Provider, {\n    value: {\n      wallet,\n      seed,\n      mnemonic,\n      importsEncryptionKey,\n      walletSelector,\n      setWalletSelector,\n      privateKeyImports,\n      setPrivateKeyImports,\n      accounts,\n      derivedAccounts,\n      addAccount,\n      setAccountName,\n      derivationPath,\n      hardwareWalletAccount,\n      setHardwareWalletAccount\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 339,\n    columnNumber: 5\n  }, this);\n}\n\n_s(WalletProvider, \"GHPWEdZTBcuvEHCro7ClvBzOw04=\", false, function () {\n  return [useListener, useUnlockedMnemonicAndSeed, useSnackbar, useConnection, useLocalStorageState, useLocalStorageState, useLocalStorageState];\n});\n\n_c = WalletProvider;\nexport function useWallet() {\n  _s2();\n\n  return useContext(WalletContext).wallet;\n}\n\n_s2(useWallet, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nexport function useWalletPublicKeys() {\n  _s3();\n\n  let wallet = useWallet();\n  let [tokenAccountInfo, loaded] = useAsyncData(wallet.getTokenAccountInfo, wallet.getTokenAccountInfo);\n  let publicKeys = [wallet.publicKey, ...(tokenAccountInfo ? tokenAccountInfo.map(({\n    publicKey\n  }) => publicKey) : [])]; // Prevent users from re-rendering unless the list of public keys actually changes\n\n  publicKeys = useRefEqual(publicKeys, (oldKeys, newKeys) => oldKeys.length === newKeys.length && oldKeys.every((key, i) => key.equals(newKeys[i])));\n  return [publicKeys, loaded];\n}\n\n_s3(useWalletPublicKeys, \"/f2l+IjXtFj5xZmqrVIz8yp75ao=\", false, function () {\n  return [useWallet, useAsyncData, useRefEqual];\n});\n\nexport function useWalletTokenAccounts() {\n  _s4();\n\n  let wallet = useWallet();\n  return useAsyncData(wallet.getTokenAccountInfo, wallet.getTokenAccountInfo);\n}\n\n_s4(useWalletTokenAccounts, \"8m8N76N4BxXnpOJRxMxOT9bnrXM=\", false, function () {\n  return [useWallet, useAsyncData];\n});\n\nexport function refreshWalletPublicKeys(wallet) {\n  refreshCache(wallet.getTokenAccountInfo);\n}\nexport function useWalletAddressForMint(mint) {\n  _s5();\n\n  const [walletAccounts] = useWalletTokenAccounts();\n  return useMemo(() => {\n    var _walletAccounts$find;\n\n    return mint ? walletAccounts === null || walletAccounts === void 0 ? void 0 : (_walletAccounts$find = walletAccounts.find(account => {\n      var _account$parsed, _account$parsed$mint;\n\n      return (_account$parsed = account.parsed) === null || _account$parsed === void 0 ? void 0 : (_account$parsed$mint = _account$parsed.mint) === null || _account$parsed$mint === void 0 ? void 0 : _account$parsed$mint.equals(mint);\n    })) === null || _walletAccounts$find === void 0 ? void 0 : _walletAccounts$find.publicKey.toBase58() : null;\n  }, [walletAccounts, mint]);\n}\n\n_s5(useWalletAddressForMint, \"3DOOc5+FtqxzctOueXjDAfa0g2Y=\", false, function () {\n  return [useWalletTokenAccounts];\n});\n\nexport function useBalanceInfo(publicKey) {\n  _s6();\n\n  let [accountInfo, accountInfoLoaded] = useAccountInfo(publicKey);\n  let {\n    mint,\n    owner,\n    amount\n  } = (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner.equals(TOKEN_PROGRAM_ID)) ? parseTokenAccountData(accountInfo.data) : {};\n  let [mintInfo, mintInfoLoaded] = useAccountInfo(mint);\n  let {\n    name,\n    symbol,\n    logoUri\n  } = useTokenInfo(mint);\n\n  if (!accountInfoLoaded) {\n    return null;\n  }\n\n  if (mint && mintInfoLoaded) {\n    try {\n      let {\n        decimals\n      } = parseMintData(mintInfo.data);\n      return {\n        amount,\n        decimals,\n        mint,\n        owner,\n        tokenName: name,\n        tokenSymbol: symbol,\n        tokenLogoUri: logoUri,\n        valid: true\n      };\n    } catch (e) {\n      return {\n        amount,\n        decimals: 0,\n        mint,\n        owner,\n        tokenName: 'Invalid',\n        tokenSymbol: 'INVALID',\n        tokenLogoUri: null,\n        valid: false\n      };\n    }\n  }\n\n  if (!mint) {\n    var _accountInfo$lamports;\n\n    return {\n      amount: (_accountInfo$lamports = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.lamports) !== null && _accountInfo$lamports !== void 0 ? _accountInfo$lamports : 0,\n      decimals: 9,\n      mint: null,\n      owner: publicKey,\n      tokenName: 'SOL',\n      tokenSymbol: 'SOL',\n      valid: true\n    };\n  }\n\n  return null;\n}\n\n_s6(useBalanceInfo, \"gsz/tPIdrcJ0jbBk5RpX6vUoN1c=\", false, function () {\n  return [useAccountInfo, useAccountInfo, useTokenInfo];\n});\n\nexport function useBalanceInfoMin(publicKey) {\n  _s7();\n\n  let [accountInfo, accountInfoLoaded] = useAccountInfo(publicKey);\n  let {\n    mint,\n    owner,\n    amount\n  } = (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.owner.equals(TOKEN_PROGRAM_ID)) ? parseTokenAccountData(accountInfo.data) : {};\n  let [mintInfo, mintInfoLoaded] = useAccountInfo(mint); // let { name, symbol, logoUri } = useTokenInfo(mint);\n\n  if (!accountInfoLoaded) {\n    return null;\n  }\n\n  if (mint && mintInfoLoaded) {\n    try {\n      let {\n        decimals\n      } = parseMintData(mintInfo.data);\n      return {\n        amount,\n        decimals,\n        mint,\n        owner,\n        valid: true\n      };\n    } catch (e) {\n      return {\n        amount,\n        decimals: 0,\n        mint,\n        owner,\n        tokenName: 'Invalid',\n        tokenSymbol: 'INVALID',\n        tokenLogoUri: null,\n        valid: false\n      };\n    }\n  }\n\n  if (!mint) {\n    var _accountInfo$lamports2;\n\n    return {\n      amount: (_accountInfo$lamports2 = accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.lamports) !== null && _accountInfo$lamports2 !== void 0 ? _accountInfo$lamports2 : 0,\n      decimals: 9,\n      mint: null,\n      owner: publicKey,\n      tokenName: 'SOL',\n      tokenSymbol: 'SOL',\n      valid: true\n    };\n  }\n\n  return null;\n}\n\n_s7(useBalanceInfoMin, \"Vpg/xT5W6UOgxMjdhbm/6eMD3gM=\", false, function () {\n  return [useAccountInfo, useAccountInfo];\n});\n\nexport function useWalletSelector() {\n  _s8();\n\n  const {\n    accounts,\n    derivedAccounts,\n    addAccount,\n    setWalletSelector,\n    setAccountName,\n    hardwareWalletAccount,\n    setHardwareWalletAccount\n  } = useContext(WalletContext);\n  return {\n    accounts,\n    derivedAccounts,\n    setWalletSelector,\n    addAccount,\n    setAccountName,\n    hardwareWalletAccount,\n    setHardwareWalletAccount\n  };\n}\n\n_s8(useWalletSelector, \"WxSyDLenzGXMZsYHBwzoP3QiFl8=\");\n\nvar _c;\n\n$RefreshReg$(_c, \"WalletProvider\");","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/wallet.js"],"names":["React","useContext","useEffect","useMemo","useState","bs58","Account","PublicKey","nacl","setInitialAccountInfo","useAccountInfo","useConnection","closeTokenAccount","createAndInitializeTokenAccount","createAssociatedTokenAccount","getOwnedTokenAccounts","nativeTransfer","transferTokens","TOKEN_PROGRAM_ID","ACCOUNT_LAYOUT","parseMintData","parseTokenAccountData","useListener","useLocalStorageState","useRefEqual","useTokenInfo","refreshCache","useAsyncData","useUnlockedMnemonicAndSeed","walletSeedChanged","WalletProviderFactory","getAccountFromSeed","useSnackbar","DEFAULT_WALLET_SELECTOR","walletIndex","importedPubkey","undefined","ledger","Wallet","constructor","connection","type","args","getTokenAccountInfo","accounts","publicKey","map","accountInfo","parsed","data","sort","account1","account2","mint","toBase58","localeCompare","createTokenAccount","tokenAddress","payer","mintPublicKey","newAccount","splTokenMintAddress","wallet","tokenAccountCost","getMinimumBalanceForRentExemption","span","transferToken","source","destination","amount","decimals","memo","overrideDestinationCheck","equals","Error","transferSol","owner","sourcePublicKey","destinationPublicKey","skipPreflight","signTransaction","transaction","provider","createSignature","message","getProvider","allowsExport","create","instance","init","WalletContext","createContext","WalletProvider","children","mnemonic","seed","importsEncryptionKey","derivationPath","enqueueSnackbar","setWallet","privateKeyImports","setPrivateKeyImports","walletSelector","setWalletSelector","_hardwareWalletAccount","setHardwareWalletAccount","walletCount","setWalletCount","onDisconnect","account","change","e","console","log","statusCode","variant","Buffer","from","nonce","ciphertext","secretbox","open","decode","addAccount","name","importedAccount","localStorage","setItem","randomBytes","nonceLength","plaintext","secretKey","newPrivateKeyImports","toString","encode","getWalletNames","JSON","stringify","Array","keys","idx","getItem","walletNames","setWalletNames","setAccountName","selector","newName","derivedAccounts","seedBuffer","address","isSelected","importedAccounts","Object","pubkey","concat","hardwareWalletAccount","useWallet","useWalletPublicKeys","tokenAccountInfo","loaded","publicKeys","oldKeys","newKeys","length","every","key","i","useWalletTokenAccounts","refreshWalletPublicKeys","useWalletAddressForMint","walletAccounts","find","useBalanceInfo","accountInfoLoaded","mintInfo","mintInfoLoaded","symbol","logoUri","tokenName","tokenSymbol","tokenLogoUri","valid","lamports","useBalanceInfoMin","useWalletSelector"],"mappings":"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","sourcesContent":["import React, { useContext, useEffect, useMemo, useState } from 'react';\nimport * as bs58 from 'bs58';\nimport { Account, PublicKey } from '@solana/web3.js';\nimport nacl from 'tweetnacl';\nimport {\n  setInitialAccountInfo,\n  useAccountInfo,\n  useConnection,\n} from './connection';\nimport {\n  closeTokenAccount,\n  createAndInitializeTokenAccount,\n  createAssociatedTokenAccount,\n  getOwnedTokenAccounts,\n  nativeTransfer,\n  transferTokens,\n} from './tokens';\nimport { TOKEN_PROGRAM_ID } from './tokens/instructions';\nimport {\n  ACCOUNT_LAYOUT,\n  parseMintData,\n  parseTokenAccountData,\n} from './tokens/data';\nimport { useListener, useLocalStorageState, useRefEqual } from './utils';\nimport { useTokenInfo } from './tokens/names';\nimport { refreshCache, useAsyncData } from './fetch-loop';\nimport { useUnlockedMnemonicAndSeed, walletSeedChanged } from './wallet-seed';\nimport { WalletProviderFactory } from './walletProvider/factory';\nimport { getAccountFromSeed } from './walletProvider/localStorage';\nimport { useSnackbar } from 'notistack';\n\nconst DEFAULT_WALLET_SELECTOR = {\n  walletIndex: 0,\n  importedPubkey: undefined,\n  ledger: false,\n};\n\nexport class Wallet {\n  constructor(connection, type, args) {\n    this.connection = connection;\n    this.type = type;\n    this.provider = WalletProviderFactory.getProvider(type, args);\n  }\n\n  static create = async (connection, type, args) => {\n    const instance = new Wallet(connection, type, args);\n    await instance.provider.init();\n    return instance;\n  };\n\n  get publicKey() {\n    return this.provider.publicKey;\n  }\n\n  get allowsExport() {\n    return this.type === 'local';\n  }\n\n  getTokenAccountInfo = async () => {\n    let accounts = await getOwnedTokenAccounts(this.connection, this.publicKey);\n    return accounts\n      .map(({ publicKey, accountInfo }) => {\n        setInitialAccountInfo(this.connection, publicKey, accountInfo);\n        return { publicKey, parsed: parseTokenAccountData(accountInfo.data) };\n      })\n      .sort((account1, account2) =>\n        account1.parsed.mint\n          .toBase58()\n          .localeCompare(account2.parsed.mint.toBase58()),\n      );\n  };\n\n  createTokenAccount = async (tokenAddress) => {\n    return await createAndInitializeTokenAccount({\n      connection: this.connection,\n      payer: this,\n      mintPublicKey: tokenAddress,\n      newAccount: new Account(),\n    });\n  };\n\n  createAssociatedTokenAccount = async (splTokenMintAddress) => {\n    return await createAssociatedTokenAccount({\n      connection: this.connection,\n      wallet: this,\n      splTokenMintAddress,\n    });\n  };\n\n  tokenAccountCost = async () => {\n    return this.connection.getMinimumBalanceForRentExemption(\n      ACCOUNT_LAYOUT.span,\n    );\n  };\n\n  transferToken = async (\n    source,\n    destination,\n    amount,\n    mint,\n    decimals,\n    memo = null,\n    overrideDestinationCheck = false,\n  ) => {\n    if (source.equals(this.publicKey)) {\n      if (memo) {\n        throw new Error('Memo not implemented');\n      }\n      return this.transferSol(destination, amount);\n    }\n    return await transferTokens({\n      connection: this.connection,\n      owner: this,\n      sourcePublicKey: source,\n      destinationPublicKey: destination,\n      amount,\n      memo,\n      mint,\n      decimals,\n      overrideDestinationCheck,\n    });\n  };\n\n  transferSol = async (destination, amount) => {\n    return nativeTransfer(this.connection, this, destination, amount);\n  };\n\n  closeTokenAccount = async (publicKey, skipPreflight = false) => {\n    return await closeTokenAccount({\n      connection: this.connection,\n      owner: this,\n      sourcePublicKey: publicKey,\n      skipPreflight,\n    });\n  };\n\n  signTransaction = async (transaction) => {\n    return this.provider.signTransaction(transaction);\n  };\n\n  createSignature = async (message) => {\n    return this.provider.createSignature(message);\n  };\n}\n\nconst WalletContext = React.createContext(null);\n\nexport function WalletProvider({ children }) {\n  useListener(walletSeedChanged, 'change');\n  const [\n    { mnemonic, seed, importsEncryptionKey, derivationPath },\n  ] = useUnlockedMnemonicAndSeed();\n  const { enqueueSnackbar } = useSnackbar();\n  const connection = useConnection();\n  const [wallet, setWallet] = useState();\n\n  // `privateKeyImports` are accounts imported *in addition* to HD wallets\n  const [privateKeyImports, setPrivateKeyImports] = useLocalStorageState(\n    'walletPrivateKeyImports',\n    {},\n  );\n  // `walletSelector` identifies which wallet to use.\n  let [walletSelector, setWalletSelector] = useLocalStorageState(\n    'walletSelector',\n    DEFAULT_WALLET_SELECTOR,\n  );\n  const [_hardwareWalletAccount, setHardwareWalletAccount] = useState(null);\n\n  // `walletCount` is the number of HD wallets.\n  const [walletCount, setWalletCount] = useLocalStorageState('walletCount', 1);\n\n  if (walletSelector.ledger && !_hardwareWalletAccount) {\n    walletSelector = DEFAULT_WALLET_SELECTOR;\n    setWalletSelector(DEFAULT_WALLET_SELECTOR);\n  }\n\n  useEffect(() => {\n    (async () => {\n      if (!seed) {\n        return null;\n      }\n      let wallet;\n      if (walletSelector.ledger) {\n        try {\n          const onDisconnect = () => {\n            setWalletSelector(DEFAULT_WALLET_SELECTOR);\n            setHardwareWalletAccount(null);\n          };\n          const args = {\n            onDisconnect,\n            derivationPath: walletSelector.derivationPath,\n            account: walletSelector.account,\n            change: walletSelector.change,\n          };\n          wallet = await Wallet.create(connection, 'ledger', args);\n        } catch (e) {\n          console.log(`received error using ledger wallet: ${e}`);\n          let message = 'Received error unlocking ledger';\n          if (e.statusCode) {\n            message += `: ${e.statusCode}`;\n          }\n          enqueueSnackbar(message, { variant: 'error' });\n          setWalletSelector(DEFAULT_WALLET_SELECTOR);\n          setHardwareWalletAccount(null);\n          return;\n        }\n      }\n      if (!wallet) {\n        const account =\n          walletSelector.walletIndex !== undefined\n            ? getAccountFromSeed(\n                Buffer.from(seed, 'hex'),\n                walletSelector.walletIndex,\n                derivationPath,\n              )\n            : new Account(\n                (() => {\n                  const { nonce, ciphertext } = privateKeyImports[\n                    walletSelector.importedPubkey\n                  ];\n                  return nacl.secretbox.open(\n                    bs58.decode(ciphertext),\n                    bs58.decode(nonce),\n                    importsEncryptionKey,\n                  );\n                })(),\n              );\n        wallet = await Wallet.create(connection, 'local', { account });\n      }\n      setWallet(wallet);\n    })();\n  }, [\n    connection,\n    seed,\n    walletSelector,\n    privateKeyImports,\n    importsEncryptionKey,\n    setWalletSelector,\n    enqueueSnackbar,\n    derivationPath,\n  ]);\n  function addAccount({ name, importedAccount, ledger }) {\n    if (importedAccount === undefined) {\n      name && localStorage.setItem(`name${walletCount}`, name);\n      setWalletCount(walletCount + 1);\n    } else {\n      const nonce = nacl.randomBytes(nacl.secretbox.nonceLength);\n      const plaintext = importedAccount.secretKey;\n      const ciphertext = nacl.secretbox(plaintext, nonce, importsEncryptionKey);\n      // `useLocalStorageState` requires a new object.\n      let newPrivateKeyImports = { ...privateKeyImports };\n      newPrivateKeyImports[importedAccount.publicKey.toString()] = {\n        name,\n        ciphertext: bs58.encode(ciphertext),\n        nonce: bs58.encode(nonce),\n      };\n      setPrivateKeyImports(newPrivateKeyImports);\n    }\n  }\n\n  const getWalletNames = () => {\n    return JSON.stringify(\n      [...Array(walletCount).keys()].map((idx) =>\n        localStorage.getItem(`name${idx}`),\n      ),\n    );\n  };\n  const [walletNames, setWalletNames] = useState(getWalletNames());\n  function setAccountName(selector, newName) {\n    if (selector.importedPubkey && !selector.ledger) {\n      let newPrivateKeyImports = { ...privateKeyImports };\n      newPrivateKeyImports[selector.importedPubkey.toString()].name = newName;\n      setPrivateKeyImports(newPrivateKeyImports);\n    } else {\n      localStorage.setItem(`name${selector.walletIndex}`, newName);\n      setWalletNames(getWalletNames());\n    }\n  }\n\n  const [accounts, derivedAccounts] = useMemo(() => {\n    if (!seed) {\n      return [[], []];\n    }\n\n    const seedBuffer = Buffer.from(seed, 'hex');\n    const derivedAccounts = [...Array(walletCount).keys()].map((idx) => {\n      let address = getAccountFromSeed(seedBuffer, idx, derivationPath)\n        .publicKey;\n      let name = localStorage.getItem(`name${idx}`);\n      return {\n        selector: {\n          walletIndex: idx,\n          importedPubkey: undefined,\n          ledger: false,\n        },\n        isSelected: walletSelector.walletIndex === idx,\n        address,\n        name: idx === 0 ? 'Main account' : name || `Account ${idx}`,\n      };\n    });\n\n    const importedAccounts = Object.keys(privateKeyImports).map((pubkey) => {\n      const { name } = privateKeyImports[pubkey];\n      return {\n        selector: {\n          walletIndex: undefined,\n          importedPubkey: pubkey,\n          ledger: false,\n        },\n        address: new PublicKey(bs58.decode(pubkey)),\n        name: `${name} (imported)`, // TODO: do this in the Component with styling.\n        isSelected: walletSelector.importedPubkey === pubkey,\n      };\n    });\n\n    const accounts = derivedAccounts.concat(importedAccounts);\n    return [accounts, derivedAccounts];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [seed, walletCount, walletSelector, privateKeyImports, walletNames]);\n\n  let hardwareWalletAccount;\n  if (_hardwareWalletAccount) {\n    hardwareWalletAccount = {\n      ..._hardwareWalletAccount,\n      selector: {\n        walletIndex: undefined,\n        ledger: true,\n        importedPubkey: _hardwareWalletAccount.publicKey,\n        derivationPath: _hardwareWalletAccount.derivationPath,\n        account: _hardwareWalletAccount.account,\n        change: _hardwareWalletAccount.change,\n      },\n      address: _hardwareWalletAccount.publicKey,\n      isSelected: walletSelector.ledger,\n    };\n  }\n\n  return (\n    <WalletContext.Provider\n      value={{\n        wallet,\n        seed,\n        mnemonic,\n        importsEncryptionKey,\n        walletSelector,\n        setWalletSelector,\n        privateKeyImports,\n        setPrivateKeyImports,\n        accounts,\n        derivedAccounts,\n        addAccount,\n        setAccountName,\n        derivationPath,\n        hardwareWalletAccount,\n        setHardwareWalletAccount,\n      }}\n    >\n      {children}\n    </WalletContext.Provider>\n  );\n}\n\nexport function useWallet() {\n  return useContext(WalletContext).wallet;\n}\n\nexport function useWalletPublicKeys() {\n  let wallet = useWallet();\n  let [tokenAccountInfo, loaded] = useAsyncData(\n    wallet.getTokenAccountInfo,\n    wallet.getTokenAccountInfo,\n  );\n  let publicKeys = [\n    wallet.publicKey,\n    ...(tokenAccountInfo\n      ? tokenAccountInfo.map(({ publicKey }) => publicKey)\n      : []),\n  ];\n  // Prevent users from re-rendering unless the list of public keys actually changes\n  publicKeys = useRefEqual(\n    publicKeys,\n    (oldKeys, newKeys) =>\n      oldKeys.length === newKeys.length &&\n      oldKeys.every((key, i) => key.equals(newKeys[i])),\n  );\n  return [publicKeys, loaded];\n}\n\nexport function useWalletTokenAccounts() {\n  let wallet = useWallet();\n  return useAsyncData(wallet.getTokenAccountInfo, wallet.getTokenAccountInfo);\n}\n\nexport function refreshWalletPublicKeys(wallet) {\n  refreshCache(wallet.getTokenAccountInfo);\n}\n\nexport function useWalletAddressForMint(mint) {\n  const [walletAccounts] = useWalletTokenAccounts();\n  return useMemo(\n    () =>\n      mint\n        ? walletAccounts\n            ?.find((account) => account.parsed?.mint?.equals(mint))\n            ?.publicKey.toBase58()\n        : null,\n    [walletAccounts, mint],\n  );\n}\n\nexport function useBalanceInfo(publicKey) {\n  let [accountInfo, accountInfoLoaded] = useAccountInfo(publicKey);\n\n  let { mint, owner, amount } = accountInfo?.owner.equals(TOKEN_PROGRAM_ID)\n    ? parseTokenAccountData(accountInfo.data)\n    : {};\n  let [mintInfo, mintInfoLoaded] = useAccountInfo(mint);\n\n  let { name, symbol, logoUri } = useTokenInfo(mint);\n\n  if (!accountInfoLoaded) {\n    return null;\n  }\n\n  if (mint && mintInfoLoaded) {\n    try {\n      let { decimals } = parseMintData(mintInfo.data);\n      return {\n        amount,\n        decimals,\n        mint,\n        owner,\n        tokenName: name,\n        tokenSymbol: symbol,\n        tokenLogoUri: logoUri,\n        valid: true,\n      };\n    } catch (e) {\n      return {\n        amount,\n        decimals: 0,\n        mint,\n        owner,\n        tokenName: 'Invalid',\n        tokenSymbol: 'INVALID',\n        tokenLogoUri: null,\n        valid: false,\n      };\n    }\n  }\n\n  if (!mint) {\n    return {\n      amount: accountInfo?.lamports ?? 0,\n      decimals: 9,\n      mint: null,\n      owner: publicKey,\n      tokenName: 'SOL',\n      tokenSymbol: 'SOL',\n      valid: true,\n    };\n  }\n\n  return null;\n}\nexport function useBalanceInfoMin(publicKey) {\n  let [accountInfo, accountInfoLoaded] = useAccountInfo(publicKey);\n\n  let { mint, owner, amount } = accountInfo?.owner.equals(TOKEN_PROGRAM_ID)\n    ? parseTokenAccountData(accountInfo.data)\n    : {};\n  let [mintInfo, mintInfoLoaded] = useAccountInfo(mint);\n\n  // let { name, symbol, logoUri } = useTokenInfo(mint);\n\n  if (!accountInfoLoaded) {\n    return null;\n  }\n\n  if (mint && mintInfoLoaded) {\n    try {\n      let { decimals } = parseMintData(mintInfo.data);\n      return {\n        amount,\n        decimals,\n        mint,\n        owner,\n        valid: true,\n      };\n    } catch (e) {\n      return {\n        amount,\n        decimals: 0,\n        mint,\n        owner,\n        tokenName: 'Invalid',\n        tokenSymbol: 'INVALID',\n        tokenLogoUri: null,\n        valid: false,\n      };\n    }\n  }\n\n  if (!mint) {\n    return {\n      amount: accountInfo?.lamports ?? 0,\n      decimals: 9,\n      mint: null,\n      owner: publicKey,\n      tokenName: 'SOL',\n      tokenSymbol: 'SOL',\n      valid: true,\n    };\n  }\n\n  return null;\n}\n\nexport function useWalletSelector() {\n  const {\n    accounts,\n    derivedAccounts,\n    addAccount,\n    setWalletSelector,\n    setAccountName,\n    hardwareWalletAccount,\n    setHardwareWalletAccount,\n  } = useContext(WalletContext);\n\n  return {\n    accounts,\n    derivedAccounts,\n    setWalletSelector,\n    addAccount,\n    setAccountName,\n    hardwareWalletAccount,\n    setHardwareWalletAccount,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}