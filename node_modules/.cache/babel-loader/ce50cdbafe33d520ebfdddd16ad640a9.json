{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"./utils\");\n/**\r\n * Returns true if the bloom is a valid bloom\r\n * @param bloom The bloom\r\n */\n\n\nfunction isBloom(bloom) {\n  if (typeof bloom !== 'string') {\n    return false;\n  }\n\n  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isBloom = isBloom;\n/**\r\n * Returns true if the value is part of the given bloom\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param value The value\r\n */\n\nfunction isInBloom(bloom, value) {\n  if (typeof value === 'object' && value.constructor === Uint8Array) {\n    value = utils_1.bytesToHex(value);\n  }\n\n  const hash = utils_1.keccak256(value).replace('0x', '');\n\n  for (let i = 0; i < 12; i += 4) {\n    // calculate bit position in bloom filter that must be active\n    const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047; // test if bitpos in bloom is active\n\n    const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n    const offset = 1 << bitpos % 4;\n\n    if ((code & offset) !== offset) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isInBloom = isInBloom;\n/**\r\n * Code points to int\r\n * @param codePoint The code point\r\n */\n\nfunction codePointToInt(codePoint) {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n\n  throw new Error('invalid bloom');\n}\n/**\r\n * Returns true if the ethereum users address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param address the address to test\r\n */\n\n\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n\n  if (!isAddress(ethereumAddress)) {\n    throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n  } // you have to pad the ethereum address to 32 bytes\n  // else the bloom filter does not work\n  // this is only if your matching the USERS\n  // ethereum address. Contract address do not need this\n  // hence why we have 2 methods\n  // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n\n\n  const address = utils_1.padLeft(ethereumAddress, 64);\n  return isInBloom(bloom, address);\n}\n\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\r\n * Returns true if the contract address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param contractAddress the contract address to test\r\n */\n\nfunction isContractAddressInBloom(bloom, contractAddress) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n\n  if (!isAddress(contractAddress)) {\n    throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n  }\n\n  return isInBloom(bloom, contractAddress);\n}\n\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\r\n * Returns true if the topic is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param topic the topic encoded hex\r\n */\n\nfunction isTopicInBloom(bloom, topic) {\n  if (!isBloom(bloom)) {\n    throw new Error('Invalid bloom given');\n  }\n\n  if (!isTopic(topic)) {\n    throw new Error('Invalid topic');\n  }\n\n  return isInBloom(bloom, topic);\n}\n\nexports.isTopicInBloom = isTopicInBloom;\n/**\r\n * Checks if its a valid topic\r\n * @param topic encoded hex topic\r\n */\n\nfunction isTopic(topic) {\n  if (typeof topic !== 'string') {\n    return false;\n  }\n\n  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isTopic = isTopic;\n/**\r\n * Is valid address\r\n * @param address The address\r\n */\n\nfunction isAddress(address) {\n  if (typeof address !== 'string') {\n    return false;\n  }\n\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    return true;\n  }\n\n  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isAddress = isAddress;","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/node_modules/ethereum-bloom-filters/dist/index.js"],"names":["Object","defineProperty","exports","value","utils_1","require","isBloom","bloom","test","isInBloom","constructor","Uint8Array","bytesToHex","hash","keccak256","replace","i","bitpos","parseInt","substr","code","codePointToInt","charCodeAt","length","Math","floor","offset","codePoint","Error","isUserEthereumAddressInBloom","ethereumAddress","isAddress","address","padLeft","isContractAddressInBloom","contractAddress","isTopicInBloom","topic","isTopic","match"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;AACA;AACA;AACA;AACA;;;AACA,SAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACpB,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAO,KAAP;AACH;;AACD,MAAI,CAAC,wBAAwBC,IAAxB,CAA6BD,KAA7B,CAAL,EAA0C;AACtC,WAAO,KAAP;AACH;;AACD,MAAI,uBAAuBC,IAAvB,CAA4BD,KAA5B,KACA,uBAAuBC,IAAvB,CAA4BD,KAA5B,CADJ,EACwC;AACpC,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AACDL,OAAO,CAACI,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASG,SAAT,CAAmBF,KAAnB,EAA0BJ,KAA1B,EAAiC;AAC7B,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACO,WAAN,KAAsBC,UAAvD,EAAmE;AAC/DR,IAAAA,KAAK,GAAGC,OAAO,CAACQ,UAAR,CAAmBT,KAAnB,CAAR;AACH;;AACD,QAAMU,IAAI,GAAGT,OAAO,CAACU,SAAR,CAAkBX,KAAlB,EAAyBY,OAAzB,CAAiC,IAAjC,EAAuC,EAAvC,CAAb;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwBA,CAAC,IAAI,CAA7B,EAAgC;AAC5B;AACA,UAAMC,MAAM,GAAI,CAACC,QAAQ,CAACL,IAAI,CAACM,MAAL,CAAYH,CAAZ,EAAe,CAAf,CAAD,EAAoB,EAApB,CAAR,IAAmC,CAApC,IACZE,QAAQ,CAACL,IAAI,CAACM,MAAL,CAAYH,CAAC,GAAG,CAAhB,EAAmB,CAAnB,CAAD,EAAwB,EAAxB,CADG,GAEX,IAFJ,CAF4B,CAK5B;;AACA,UAAMI,IAAI,GAAGC,cAAc,CAACd,KAAK,CAACe,UAAN,CAAiBf,KAAK,CAACgB,MAAN,GAAe,CAAf,GAAmBC,IAAI,CAACC,KAAL,CAAWR,MAAM,GAAG,CAApB,CAApC,CAAD,CAA3B;AACA,UAAMS,MAAM,GAAG,KAAKT,MAAM,GAAG,CAA7B;;AACA,QAAI,CAACG,IAAI,GAAGM,MAAR,MAAoBA,MAAxB,EAAgC;AAC5B,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;;AACDxB,OAAO,CAACO,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;;AACA,SAASY,cAAT,CAAwBM,SAAxB,EAAmC;AAC/B,MAAIA,SAAS,IAAI,EAAb,IAAmBA,SAAS,IAAI,EAApC,EAAwC;AACpC;AACA,WAAOA,SAAS,GAAG,EAAnB;AACH;;AACD,MAAIA,SAAS,IAAI,EAAb,IAAmBA,SAAS,IAAI,EAApC,EAAwC;AACpC;AACA,WAAOA,SAAS,GAAG,EAAnB;AACH;;AACD,MAAIA,SAAS,IAAI,EAAb,IAAmBA,SAAS,IAAI,GAApC,EAAyC;AACrC;AACA,WAAOA,SAAS,GAAG,EAAnB;AACH;;AACD,QAAM,IAAIC,KAAJ,CAAU,eAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,4BAAT,CAAsCtB,KAAtC,EAA6CuB,eAA7C,EAA8D;AAC1D,MAAI,CAACxB,OAAO,CAACC,KAAD,CAAZ,EAAqB;AACjB,UAAM,IAAIqB,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,MAAI,CAACG,SAAS,CAACD,eAAD,CAAd,EAAiC;AAC7B,UAAM,IAAIF,KAAJ,CAAW,oCAAmCE,eAAgB,GAA9D,CAAN;AACH,GANyD,CAO1D;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAME,OAAO,GAAG5B,OAAO,CAAC6B,OAAR,CAAgBH,eAAhB,EAAiC,EAAjC,CAAhB;AACA,SAAOrB,SAAS,CAACF,KAAD,EAAQyB,OAAR,CAAhB;AACH;;AACD9B,OAAO,CAAC2B,4BAAR,GAAuCA,4BAAvC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASK,wBAAT,CAAkC3B,KAAlC,EAAyC4B,eAAzC,EAA0D;AACtD,MAAI,CAAC7B,OAAO,CAACC,KAAD,CAAZ,EAAqB;AACjB,UAAM,IAAIqB,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,MAAI,CAACG,SAAS,CAACI,eAAD,CAAd,EAAiC;AAC7B,UAAM,IAAIP,KAAJ,CAAW,oCAAmCO,eAAgB,GAA9D,CAAN;AACH;;AACD,SAAO1B,SAAS,CAACF,KAAD,EAAQ4B,eAAR,CAAhB;AACH;;AACDjC,OAAO,CAACgC,wBAAR,GAAmCA,wBAAnC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,cAAT,CAAwB7B,KAAxB,EAA+B8B,KAA/B,EAAsC;AAClC,MAAI,CAAC/B,OAAO,CAACC,KAAD,CAAZ,EAAqB;AACjB,UAAM,IAAIqB,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,MAAI,CAACU,OAAO,CAACD,KAAD,CAAZ,EAAqB;AACjB,UAAM,IAAIT,KAAJ,CAAU,eAAV,CAAN;AACH;;AACD,SAAOnB,SAAS,CAACF,KAAD,EAAQ8B,KAAR,CAAhB;AACH;;AACDnC,OAAO,CAACkC,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;;AACA,SAASE,OAAT,CAAiBD,KAAjB,EAAwB;AACpB,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,WAAO,KAAP;AACH;;AACD,MAAI,CAAC,uBAAuB7B,IAAvB,CAA4B6B,KAA5B,CAAL,EAAyC;AACrC,WAAO,KAAP;AACH,GAFD,MAGK,IAAI,sBAAsB7B,IAAtB,CAA2B6B,KAA3B,KACL,sBAAsB7B,IAAtB,CAA2B6B,KAA3B,CADC,EACkC;AACnC,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AACDnC,OAAO,CAACoC,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;;AACA,SAASP,SAAT,CAAmBC,OAAnB,EAA4B;AACxB,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,WAAO,KAAP;AACH;;AACD,MAAIA,OAAO,CAACO,KAAR,CAAc,wBAAd,CAAJ,EAA6C;AACzC,WAAO,IAAP;AACH;;AACD,MAAIP,OAAO,CAACO,KAAR,CAAc,gCAAd,CAAJ,EAAqD;AACjD,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AACDrC,OAAO,CAAC6B,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils_1 = require(\"./utils\");\r\n/**\r\n * Returns true if the bloom is a valid bloom\r\n * @param bloom The bloom\r\n */\r\nfunction isBloom(bloom) {\r\n    if (typeof bloom !== 'string') {\r\n        return false;\r\n    }\r\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\r\n        return false;\r\n    }\r\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) ||\r\n        /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isBloom = isBloom;\r\n/**\r\n * Returns true if the value is part of the given bloom\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param value The value\r\n */\r\nfunction isInBloom(bloom, value) {\r\n    if (typeof value === 'object' && value.constructor === Uint8Array) {\r\n        value = utils_1.bytesToHex(value);\r\n    }\r\n    const hash = utils_1.keccak256(value).replace('0x', '');\r\n    for (let i = 0; i < 12; i += 4) {\r\n        // calculate bit position in bloom filter that must be active\r\n        const bitpos = ((parseInt(hash.substr(i, 2), 16) << 8) +\r\n            parseInt(hash.substr(i + 2, 2), 16)) &\r\n            2047;\r\n        // test if bitpos in bloom is active\r\n        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\r\n        const offset = 1 << bitpos % 4;\r\n        if ((code & offset) !== offset) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.isInBloom = isInBloom;\r\n/**\r\n * Code points to int\r\n * @param codePoint The code point\r\n */\r\nfunction codePointToInt(codePoint) {\r\n    if (codePoint >= 48 && codePoint <= 57) {\r\n        /* ['0'..'9'] -> [0..9] */\r\n        return codePoint - 48;\r\n    }\r\n    if (codePoint >= 65 && codePoint <= 70) {\r\n        /* ['A'..'F'] -> [10..15] */\r\n        return codePoint - 55;\r\n    }\r\n    if (codePoint >= 97 && codePoint <= 102) {\r\n        /* ['a'..'f'] -> [10..15] */\r\n        return codePoint - 87;\r\n    }\r\n    throw new Error('invalid bloom');\r\n}\r\n/**\r\n * Returns true if the ethereum users address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param address the address to test\r\n */\r\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\r\n    if (!isBloom(bloom)) {\r\n        throw new Error('Invalid bloom given');\r\n    }\r\n    if (!isAddress(ethereumAddress)) {\r\n        throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\r\n    }\r\n    // you have to pad the ethereum address to 32 bytes\r\n    // else the bloom filter does not work\r\n    // this is only if your matching the USERS\r\n    // ethereum address. Contract address do not need this\r\n    // hence why we have 2 methods\r\n    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\r\n    const address = utils_1.padLeft(ethereumAddress, 64);\r\n    return isInBloom(bloom, address);\r\n}\r\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\r\n/**\r\n * Returns true if the contract address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param contractAddress the contract address to test\r\n */\r\nfunction isContractAddressInBloom(bloom, contractAddress) {\r\n    if (!isBloom(bloom)) {\r\n        throw new Error('Invalid bloom given');\r\n    }\r\n    if (!isAddress(contractAddress)) {\r\n        throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\r\n    }\r\n    return isInBloom(bloom, contractAddress);\r\n}\r\nexports.isContractAddressInBloom = isContractAddressInBloom;\r\n/**\r\n * Returns true if the topic is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param topic the topic encoded hex\r\n */\r\nfunction isTopicInBloom(bloom, topic) {\r\n    if (!isBloom(bloom)) {\r\n        throw new Error('Invalid bloom given');\r\n    }\r\n    if (!isTopic(topic)) {\r\n        throw new Error('Invalid topic');\r\n    }\r\n    return isInBloom(bloom, topic);\r\n}\r\nexports.isTopicInBloom = isTopicInBloom;\r\n/**\r\n * Checks if its a valid topic\r\n * @param topic encoded hex topic\r\n */\r\nfunction isTopic(topic) {\r\n    if (typeof topic !== 'string') {\r\n        return false;\r\n    }\r\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\r\n        return false;\r\n    }\r\n    else if (/^(0x)?[0-9a-f]{64}$/.test(topic) ||\r\n        /^(0x)?[0-9A-F]{64}$/.test(topic)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isTopic = isTopic;\r\n/**\r\n * Is valid address\r\n * @param address The address\r\n */\r\nfunction isAddress(address) {\r\n    if (typeof address !== 'string') {\r\n        return false;\r\n    }\r\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\r\n        return true;\r\n    }\r\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isAddress = isAddress;\r\n"]},"metadata":{},"sourceType":"script"}