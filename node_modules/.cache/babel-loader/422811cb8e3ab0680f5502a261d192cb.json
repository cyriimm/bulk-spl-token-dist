{"ast":null,"code":"'use strict';\n\nconst uuid = require('uuid/v4');\n\nconst generateRequest = require('../../generateRequest');\n/**\n * Constructor for a Jayson Browser Client that does not depend any node.js core libraries\n * @class ClientBrowser\n * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback\n * @param {Object} [options]\n * @param {Function} [options.reviver] Reviver function for JSON\n * @param {Function} [options.replacer] Replacer function for JSON\n * @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n * @param {Function} [options.generator] Function to use for generating request IDs\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n * @return {ClientBrowser}\n */\n\n\nconst ClientBrowser = function (callServer, options) {\n  if (!(this instanceof ClientBrowser)) {\n    return new ClientBrowser(callServer, options);\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  this.options = {\n    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,\n    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,\n    generator: typeof options.generator !== 'undefined' ? options.generator : function () {\n      return uuid();\n    },\n    version: typeof options.version !== 'undefined' ? options.version : 2,\n    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false\n  };\n  this.callServer = callServer;\n};\n\nmodule.exports = ClientBrowser;\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} [params] Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\n\nClientBrowser.prototype.request = function (method, params, id, callback) {\n  const self = this;\n  let request = null; // is this a batch request?\n\n  const isBatch = Array.isArray(method) && typeof params === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  } // is this a raw request?\n\n\n  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';\n\n  if (isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if (typeof id === 'function') {\n      callback = id; // specifically undefined because \"null\" is a notification request\n\n      id = undefined;\n    }\n\n    const hasCallback = typeof callback === 'function';\n\n    try {\n      request = generateRequest(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull\n      });\n    } catch (err) {\n      if (hasCallback) {\n        return callback(err);\n      }\n\n      throw err;\n    } // no callback means we should just return a raw request\n\n\n    if (!hasCallback) {\n      return request;\n    }\n  }\n\n  let message;\n\n  try {\n    message = JSON.stringify(request, this.options.replacer);\n  } catch (err) {\n    return callback(err);\n  }\n\n  this.callServer(message, function (err, response) {\n    self._parseResponse(err, response, callback);\n  }); // always return the raw request\n\n  return request;\n};\n/**\n * Parses a response from a server\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {String} responseText JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\n\n\nClientBrowser.prototype._parseResponse = function (err, responseText, callback) {\n  if (err) {\n    callback(err);\n    return;\n  }\n\n  if (!responseText) {\n    // empty response text, assume that is correct because it could be a\n    // notification which jayson does not give any body for\n    return callback();\n  }\n\n  let response;\n\n  try {\n    response = JSON.parse(responseText, this.options.reviver);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n    // is batch response?\n    if (Array.isArray(response)) {\n      // neccesary to split strictly on validity according to spec here\n      const isError = function (res) {\n        return typeof res.error !== 'undefined';\n      };\n\n      const isNotError = function (res) {\n        return !isError(res);\n      };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    } else {\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    }\n  }\n\n  callback(null, response);\n};","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/node_modules/jayson/lib/client/browser/index.js"],"names":["uuid","require","generateRequest","ClientBrowser","callServer","options","reviver","replacer","generator","version","notificationIdNull","module","exports","prototype","request","method","params","id","callback","self","isBatch","Array","isArray","TypeError","isRaw","undefined","hasCallback","err","message","JSON","stringify","response","_parseResponse","responseText","parse","length","isError","res","error","isNotError","filter","result"],"mappings":"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","sourcesContent":["'use strict';\n\nconst uuid = require('uuid/v4');\nconst generateRequest = require('../../generateRequest');\n\n/**\n * Constructor for a Jayson Browser Client that does not depend any node.js core libraries\n * @class ClientBrowser\n * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback\n * @param {Object} [options]\n * @param {Function} [options.reviver] Reviver function for JSON\n * @param {Function} [options.replacer] Replacer function for JSON\n * @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n * @param {Function} [options.generator] Function to use for generating request IDs\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n * @return {ClientBrowser}\n */\nconst ClientBrowser = function(callServer, options) {\n  if(!(this instanceof ClientBrowser)) {\n    return new ClientBrowser(callServer, options);\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  this.options = {\n    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,\n    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,\n    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },\n    version: typeof options.version !== 'undefined' ? options.version : 2,\n    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,\n  };\n\n  this.callServer = callServer;\n};\n\nmodule.exports = ClientBrowser;\n\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} [params] Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\nClientBrowser.prototype.request = function(method, params, id, callback) {\n  const self = this;\n  let request = null;\n\n  // is this a batch request?\n  const isBatch = Array.isArray(method) && typeof params === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  }\n\n  // is this a raw request?\n  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';\n\n  if(isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if(typeof id === 'function') {\n      callback = id;\n      // specifically undefined because \"null\" is a notification request\n      id = undefined;\n    }\n\n    const hasCallback = typeof callback === 'function';\n\n    try {\n      request = generateRequest(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull,\n      });\n    } catch(err) {\n      if(hasCallback) {\n        return callback(err);\n      }\n      throw err;\n    }\n\n    // no callback means we should just return a raw request\n    if(!hasCallback) {\n      return request;\n    }\n\n  }\n\n  let message;\n  try {\n    message = JSON.stringify(request, this.options.replacer);\n  } catch(err) {\n    return callback(err);\n  }\n\n  this.callServer(message, function(err, response) {\n    self._parseResponse(err, response, callback);\n  });\n\n  // always return the raw request\n  return request;\n};\n\n/**\n * Parses a response from a server\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {String} responseText JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\nClientBrowser.prototype._parseResponse = function(err, responseText, callback) {\n  if(err) {\n    callback(err);\n    return;\n  }\n\n  if(!responseText) {\n    // empty response text, assume that is correct because it could be a\n    // notification which jayson does not give any body for\n    return callback();\n  }\n\n  let response;\n  try {\n    response = JSON.parse(responseText, this.options.reviver);\n  } catch(err) {\n    return callback(err);\n  }\n\n  if(callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n\n    // is batch response?\n    if(Array.isArray(response)) {\n\n      // neccesary to split strictly on validity according to spec here\n      const isError = function(res) {\n        return typeof res.error !== 'undefined';\n      };\n\n      const isNotError = function (res) {\n        return !isError(res);\n      };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    \n    } else {\n\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    \n    }\n  \n  }\n\n  callback(null, response);\n};\n"]},"metadata":{},"sourceType":"script"}