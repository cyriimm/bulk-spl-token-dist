{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol':\n      return 'symbol';\n\n    case 'Promise':\n      return 'promise';\n    // Set, Map, WeakSet, WeakMap\n\n    case 'WeakMap':\n      return 'weakmap';\n\n    case 'WeakSet':\n      return 'weakset';\n\n    case 'Map':\n      return 'map';\n\n    case 'Set':\n      return 'set';\n    // 8-bit typed arrays\n\n    case 'Int8Array':\n      return 'int8array';\n\n    case 'Uint8Array':\n      return 'uint8array';\n\n    case 'Uint8ClampedArray':\n      return 'uint8clampedarray';\n    // 16-bit typed arrays\n\n    case 'Int16Array':\n      return 'int16array';\n\n    case 'Uint16Array':\n      return 'uint16array';\n    // 32-bit typed arrays\n\n    case 'Int32Array':\n      return 'int32array';\n\n    case 'Uint32Array':\n      return 'uint32array';\n\n    case 'Float32Array':\n      return 'float32array';\n\n    case 'Float64Array':\n      return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  } // Non-plain objects\n\n\n  type = toString.call(val);\n\n  switch (type) {\n    case '[object Object]':\n      return 'object';\n    // iterators\n\n    case '[object Map Iterator]':\n      return 'mapiterator';\n\n    case '[object Set Iterator]':\n      return 'setiterator';\n\n    case '[object String Iterator]':\n      return 'stringiterator';\n\n    case '[object Array Iterator]':\n      return 'arrayiterator';\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string' && typeof val.ignoreCase === 'boolean' && typeof val.multiline === 'boolean' && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function' && typeof val.return === 'function' && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n\n  return false;\n}\n/**\r\n * Superstruct ships by default with an unopinionated set of scalar types that\r\n * express all of the data types that are built-in to JavaScript.\r\n */\n\n\nvar Types = {\n  /**\r\n   * Matches any value other than `undefined`.\r\n   *\r\n   * ```js\r\n   * 'anything'\r\n   * true\r\n   * ```\r\n   */\n  any: function any(value) {\n    return value !== undefined;\n  },\n\n  /**\r\n   * Matches an `arguments` object.\r\n   *\r\n   * ```js\r\n   * arguments\r\n   * ```\r\n   */\n  arguments: function _arguments(value) {\n    return kindOf(value) === 'arguments';\n  },\n\n  /**\r\n   * Matches an `Array`.\r\n   *\r\n   * ```js\r\n   * [1, 2, 3]\r\n   * ```\r\n   */\n  array: function array(value) {\n    return kindOf(value) === 'array';\n  },\n\n  /**\r\n   * Matches a boolean.\r\n   *\r\n   * ```js\r\n   * true\r\n   * false\r\n   * ```\r\n   */\n  boolean: function boolean(value) {\n    return kindOf(value) === 'boolean';\n  },\n\n  /**\r\n   * Matches a Node.js `Buffer`.\r\n   *\r\n   * ```js\r\n   * Buffer.from('string')\r\n   * ```\r\n   */\n  buffer: function buffer(value) {\n    return kindOf(value) === 'buffer';\n  },\n\n  /**\r\n   * Matches a **valid** `Date` object.\r\n   *\r\n   * ```js\r\n   * new Date()\r\n   * ```\r\n   *\r\n   * Note: Invalid `Date` objects that equal `NaN` are not matched.\r\n   */\n  date: function date(value) {\n    return kindOf(value) === 'date' && !isNaN(value);\n  },\n\n  /**\r\n   * Matches an error object.\r\n   *\r\n   * ```js\r\n   * new Error()\r\n   * ```\r\n   */\n  error: function error(value) {\n    return kindOf(value) === 'error';\n  },\n\n  /**\r\n   * Matches a `Float32Array` object.\r\n   */\n  float32array: function float32array(value) {\n    return kindOf(value) === 'float32array';\n  },\n\n  /**\r\n   * Matches a `Float64Array` object.\r\n   */\n  float64array: function float64array(value) {\n    return kindOf(value) === 'float64array';\n  },\n\n  /**\r\n   * Matches a function.\r\n   *\r\n   * ```js\r\n   * () => {}\r\n   * function () {}\r\n   * ```\r\n   */\n  function: function _function(value) {\n    return kindOf(value) === 'function';\n  },\n\n  /**\r\n   * Matches a generator function.\r\n   *\r\n   * ```js\r\n   * function* () {}\r\n   * ```\r\n   */\n  generatorfunction: function generatorfunction(value) {\n    return kindOf(value) === 'generatorfunction';\n  },\n\n  /**\r\n   * Matches a `Int16Array` object.\r\n   */\n  int16array: function int16array(value) {\n    return kindOf(value) === 'int16array';\n  },\n\n  /**\r\n   * Matches a `Int32Array` object.\r\n   */\n  int32array: function int32array(value) {\n    return kindOf(value) === 'int32array';\n  },\n\n  /**\r\n   * Matches a `Int8Array` object.\r\n   */\n  int8array: function int8array(value) {\n    return kindOf(value) === 'int8array';\n  },\n\n  /**\r\n   * Matches a `Map` object.\r\n   *\r\n   * ```js\r\n   * new Map()\r\n   * ```\r\n   */\n  map: function map(value) {\n    return kindOf(value) === 'map';\n  },\n\n  /**\r\n   * Matches the `null` literal value.\r\n   *\r\n   * ```js\r\n   * null\r\n   * ```\r\n   */\n  null: function _null(value) {\n    return kindOf(value) === 'null';\n  },\n\n  /**\r\n   * Matches a number.\r\n   *\r\n   * ```js\r\n   * 42\r\n   * ```\r\n   */\n  number: function number(value) {\n    return kindOf(value) === 'number';\n  },\n\n  /**\r\n   * Matches a plain object.\r\n   *\r\n   * ```js\r\n   * { key: 'value' }\r\n   * { something: true }\r\n   * ```\r\n   */\n  object: function object(value) {\n    return kindOf(value) === 'object';\n  },\n\n  /**\r\n   * Matches a `Promise` object.\r\n   *\r\n   * ```js\r\n   * Promise.resolve()\r\n   * ```\r\n   */\n  promise: function promise(value) {\n    return kindOf(value) === 'promise';\n  },\n\n  /**\r\n   * Matches a regular expression object.\r\n   *\r\n   * ```js\r\n   * /a-z/g\r\n   * ```\r\n   */\n  regexp: function regexp(value) {\n    return kindOf(value) === 'regexp';\n  },\n\n  /**\r\n   * Matches a `Set` object.\r\n   *\r\n   * ```js\r\n   * new Set()\r\n   * ```\r\n   */\n  set: function set(value) {\n    return kindOf(value) === 'set';\n  },\n\n  /**\r\n   * Matches a string.\r\n   *\r\n   * ```js\r\n   * 'text'\r\n   * ```\r\n   */\n  string: function string(value) {\n    return kindOf(value) === 'string';\n  },\n\n  /**\r\n   * Matches a `Symbol`.\r\n   *\r\n   * ```js\r\n   * Symbol()\r\n   * ```\r\n   */\n  symbol: function symbol(value) {\n    return kindOf(value) === 'symbol';\n  },\n\n  /**\r\n   * Matches a `Uint16Array` object.\r\n   */\n  uint16array: function uint16array(value) {\n    return kindOf(value) === 'uint16array';\n  },\n\n  /**\r\n   * Matches a `Uint32Array` object.\r\n   */\n  uint32array: function uint32array(value) {\n    return kindOf(value) === 'uint32array';\n  },\n\n  /**\r\n   * Matches a `Uint8Array` object.\r\n   */\n  uint8array: function uint8array(value) {\n    return kindOf(value) === 'uint8array';\n  },\n\n  /**\r\n   * Matches a `Uint8ClampedArray` object.\r\n   */\n  uint8clampedarray: function uint8clampedarray(value) {\n    return kindOf(value) === 'uint8clampedarray';\n  },\n\n  /**\r\n   * Matches the `undefined` literal value.\r\n   *\r\n   * ```js\r\n   * undefined\r\n   * ```\r\n   */\n  undefined: function undefined$1(value) {\n    return kindOf(value) === 'undefined';\n  },\n\n  /**\r\n   * Matches a `WeakMap` object.\r\n   *\r\n   * ```js\r\n   * new WeakMap()\r\n   * ```\r\n   */\n  weakmap: function weakmap(value) {\n    return kindOf(value) === 'weakmap';\n  },\n\n  /**\r\n   * Matches a `WeakSet` object.\r\n   *\r\n   * ```js\r\n   * new WeakSet()\r\n   * ```\r\n   */\n  weakset: function weakset(value) {\n    return kindOf(value) === 'weakset';\n  }\n};\nvar isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\n\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n/**\r\n * `StructError` objects are thrown (or returned) by Superstruct when its\r\n * validation fails. The error represents the first error encountered during\r\n * validation. But they also have an `error.failures` property that holds\r\n * information for all of the failures encountered.\r\n */\n\n\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inheritsLoose(StructError, _TypeError);\n\n  function StructError(failures) {\n    var _this;\n\n    invariant(failures.length > 0, \"StructError requires being passed a failure, but received: \" + failures);\n    var first = failures[0];\n\n    var path = first.path,\n        value = first.value,\n        type = first.type,\n        branch = first.branch,\n        rest = _objectWithoutPropertiesLoose(first, [\"path\", \"value\", \"type\", \"branch\"]);\n\n    var message = \"Expected a value of type `\" + type + \"`\" + (path.length ? \" for `\" + path.join('.') + \"`\" : '') + \" but received `\" + JSON.stringify(value) + \"`.\";\n    _this = _TypeError.call(this, message) || this;\n    _this.type = type;\n    _this.value = value;\n    Object.assign(_assertThisInitialized(_this), rest);\n    _this.path = path;\n    _this.branch = branch;\n    _this.failures = failures;\n    _this.stack = new Error().stack;\n    _this.__proto__ = StructError.prototype;\n    return _this;\n  }\n\n  return StructError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n/**\r\n * A symbol to set on `Struct` objects to test them against later.\r\n */\n\n\nvar STRUCT = Symbol('STRUCT');\n/**\r\n * Check if a value is a `Struct` object.\r\n */\n\nvar isStruct = function isStruct(value) {\n  return typeof value === 'function' && value[STRUCT];\n};\n/**\r\n * This abstract `Struct` factory creates a generic struct that validates values\r\n * against a `Validator` function.\r\n */\n\n\nvar createStruct = function createStruct(props) {\n  var struct = props.struct;\n  var Error = struct.Error;\n\n  var Struct = function Struct(value) {\n    return Struct.assert(value);\n  }; // Set a hidden symbol property so that we can check it later to see if an\n  // object is a struct object.\n\n\n  Object.defineProperty(Struct, STRUCT, {\n    value: true\n  });\n  Struct.kind = props.kind;\n  Struct.type = props.type;\n\n  Struct.default = function () {\n    return typeof props.defaults === 'function' ? props.defaults() : props.defaults;\n  };\n\n  Struct.test = function (value) {\n    var _Struct$check = Struct.check(value, [value], []),\n        failures = _Struct$check[0];\n\n    return !failures;\n  };\n\n  Struct.assert = function (value) {\n    var _Struct$check2 = Struct.check(value, [value], []),\n        failures = _Struct$check2[0],\n        result = _Struct$check2[1];\n\n    if (failures) {\n      throw new Error(failures);\n    } else {\n      return result;\n    }\n  };\n\n  Struct.validate = function (value) {\n    var _Struct$check3 = Struct.check(value, [value], []),\n        failures = _Struct$check3[0],\n        result = _Struct$check3[1];\n\n    if (failures) {\n      return [new Error(failures)];\n    } else {\n      return [undefined, result];\n    }\n  };\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var failures = [Struct.fail({\n      value: value,\n      branch: branch,\n      path: path\n    })];\n    return [failures];\n  };\n\n  Struct.fail = function (obj) {\n    return _objectSpread2(_objectSpread2({}, obj), {}, {\n      type: 'type' in obj ? obj.type : Struct.type\n    });\n  };\n\n  return Struct;\n};\n\nvar createArray = function createArray(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 1, \"Array structs must be defined as an array with one element, but you passed: \" + schema);\n  var Element = struct(schema[0], undefined);\n  var Struct = createStruct({\n    kind: 'array',\n    type: Element.type + \"[]\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = [];\n    var failures = [];\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n\n      var _Element$check = Element.check(v, branch.concat(v), path.concat(i)),\n          efs = _Element$check[0],\n          er = _Element$check[1];\n\n      if (efs) {\n        failures.push.apply(failures, efs);\n        continue;\n      }\n\n      result[i] = er;\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createDynamic = function createDynamic(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Dynamic structs must be defined as a function, but you passed: \" + schema);\n  var Dynamic = createStruct({\n    kind: 'dynamic',\n    type: \"dynamic<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Dynamic.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Dynamic.default();\n    }\n\n    var Struct = schema(value, branch, path);\n    return Struct.check(value, branch, path);\n  };\n\n  return Dynamic;\n};\n\nvar createEnum = function createEnum(schema, defaults, struct) {\n  invariant(Array.isArray(schema), \"Enum structs must be defined as an array, but you passed: \" + schema);\n\n  var validator = function validator(value) {\n    return schema.includes(value);\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'enum';\n  Struct.type = schema.map(function (s) {\n    return typeof s === 'string' ? \"\\\"\" + s + \"\\\"\" : \"\" + s;\n  }).join(' | ');\n  return Struct;\n};\n\nvar createFunction = function createFunction(schema, defaults, struct) {\n  var Struct = createStruct({\n    kind: 'function',\n    type: \"function<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var result = schema(value, branch, path);\n\n    if (result === true) {\n      return [undefined, value];\n    }\n\n    var failures = [];\n\n    if (result === false) {\n      failures.push(Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      }));\n    } else if (Array.isArray(result) && result.length > 0) {\n      for (var _iterator = _createForOfIteratorHelperLoose(result), _step; !(_step = _iterator()).done;) {\n        var r = _step.value;\n        failures.push(Struct.fail(_objectSpread2({\n          value: value,\n          branch: branch,\n          path: path\n        }, r)));\n      }\n    } else if (typeof result === 'object') {\n      failures.push(Struct.fail(_objectSpread2({\n        value: value,\n        branch: branch,\n        path: path\n      }, result)));\n    } else {\n      invariant(false, \"Validator functions must return a boolean, a failure object, or an array of failure objects, but you passed: \" + result);\n    }\n\n    return [failures];\n  };\n\n  return Struct;\n};\n\nvar createInstance = function createInstance(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Instance structs must be defined as a function, but you passed: \" + schema);\n\n  var validator = function validator(value) {\n    return value instanceof schema;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'instance';\n  Struct.type = \"instance<\" + schema.name + \">\";\n  return Struct;\n};\n\nvar createInterface = function createInterface(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Interface structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'interface',\n    type: \"interface<{\" + Object.keys(schema).join() + \"}>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var failures = [];\n\n    for (var k in Props) {\n      var Prop = Props[k];\n      var v = value[k];\n\n      var _Prop$check = Prop.check(v, branch.concat(v), path.concat(k)),\n          pfs = _Prop$check[0];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, value];\n  };\n\n  return Struct;\n};\n\nvar createIntersection = function createIntersection(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length !== 0, \"Intersection structs must be defined as a non-empty array, but you passed: \" + schema);\n  var Structs = schema.map(function (sch) {\n    return struct(sch);\n  });\n  var type = Structs.map(function (s) {\n    return s.type;\n  }).join(' & ');\n  var Struct = createStruct({\n    kind: 'intersection',\n    type: type,\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var result = value;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(Structs), _step; !(_step = _iterator()).done;) {\n      var _struct = _step.value;\n\n      var _struct$check = _struct.check(value, branch, path),\n          fs = _struct$check[0],\n          v = _struct$check[1];\n\n      if (fs) {\n        return [[Struct.fail({\n          value: value,\n          branch: branch,\n          path: path\n        })]];\n      } else {\n        result = v;\n      }\n    }\n\n    return [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createLazy = function createLazy(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Lazy structs must be defined as a function, but you passed: \" + schema);\n  var Lazy = createStruct({\n    kind: 'lazy',\n    type: \"lazy<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Lazy.check = function () {\n    Object.assign(Lazy, schema());\n    return Lazy.check.apply(Lazy, arguments);\n  };\n\n  return Lazy;\n};\n\nvar createSize = function createSize(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 2 && schema.every(function (n) {\n    return typeof n === 'number';\n  }), \"Size structs must be defined as an array with two number elements, but you passed: \" + schema);\n  var min = schema[0],\n      max = schema[1];\n\n  var validator = function validator(value) {\n    return value != null && typeof value.length === 'number' && value.length >= min && value.length <= max;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'size';\n  Struct.type = \"size<\" + min + \",\" + max + \">\";\n  return Struct;\n};\n\nvar createLiteral = function createLiteral(schema, defaults, struct) {\n  var validator = function validator(value) {\n    return value === schema;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'literal';\n  Struct.type = typeof schema === 'string' ? \"\\\"\" + schema + \"\\\"\" : \"\" + schema;\n  return Struct;\n};\n\nvar createObject = function createObject(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Object structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'object',\n    type: \"{\" + Object.keys(schema).join() + \"}\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n    var keys = new Set(Object.keys(Props).concat(Object.keys(value)));\n\n    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n      var k = _step.value;\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      if (!(k in Props)) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: value\n        }));\n        continue;\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createPartial = function createPartial(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Partial structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct.union([schema[key], 'undefined']);\n  }\n\n  var Struct = createStruct({\n    kind: 'object',\n    type: \"{\" + Object.keys(schema).join() + \"}\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(value), _step; !(_step = _iterator()).done;) {\n      var k = _step.value;\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      if (!(k in Props)) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: value\n        }));\n        continue;\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createPick = function createPick(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Pick structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'pick',\n    type: \"pick<{\" + Object.keys(schema).join() + \"}>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var k in Props) {\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createRecord = function createRecord(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 2, \"Record structs must be defined as an array with two elements, but you passed: \" + schema);\n  var Key = struct(schema[0]);\n  var Value = struct(schema[1]);\n  var Struct = createStruct({\n    kind: 'record',\n    type: \"record<\" + Key.type + \",\" + Value.type + \">\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    // Record structs have a special default handling behavior, where the defaults\n    // are for the entries themselves, not for the entire value. So we can't use\n    // JavaScript's built-in default handling here.\n    var defs = Struct.default();\n    value = defs ? _objectSpread2(_objectSpread2({}, defs), value) : value;\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var k in value) {\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n\n      var _Key$check = Key.check(k, b, p),\n          kfs = _Key$check[0],\n          kr = _Key$check[1];\n\n      if (kfs) {\n        failures.push.apply(failures, kfs);\n      } else {\n        var _Value$check = Value.check(v, b, p),\n            vfs = _Value$check[0],\n            vr = _Value$check[1];\n\n        if (vfs) {\n          failures.push.apply(failures, vfs);\n        } else {\n          result[kr] = vr;\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createScalar = function createScalar(schema, defaults, struct) {\n  invariant(typeof schema === 'string', \"Scalar structs must be defined as a string, but you passed: \" + schema);\n  var Types = struct.Types;\n  invariant(schema in Types, \"No struct validator function found for type \\\"\" + schema + \"\\\".\");\n  var Struct = struct(Types[schema], defaults);\n  Struct.kind = 'scalar';\n  Struct.type = schema;\n  return Struct;\n};\n\nvar createShorthand = function createShorthand(schema, defaults, struct) {\n  if (isStruct(schema)) {\n    return schema;\n  }\n\n  if (Array.isArray(schema)) {\n    if (schema.length === 1) {\n      var _schema = schema,\n          first = _schema[0];\n      return struct.array([first], defaults);\n    } else if (schema.length > 1) {\n      return struct.tuple(schema, defaults);\n    }\n  }\n\n  if (typeof schema === 'function') {\n    return struct.function(schema, defaults);\n  }\n\n  if (typeof schema === 'object') {\n    return struct.object(schema, defaults);\n  }\n\n  if (typeof schema === 'string') {\n    var optional = false;\n    var Struct;\n\n    if (schema.endsWith('?')) {\n      optional = true;\n      schema = schema.slice(0, -1);\n    }\n\n    if (schema.includes('|')) {\n      var scalars = schema.split(/\\s*\\|\\s*/g);\n      Struct = struct.union(scalars, defaults);\n    } else if (schema.includes('&')) {\n      var _scalars = schema.split(/\\s*&\\s*/g);\n\n      Struct = struct.intersection(_scalars, defaults);\n    } else {\n      Struct = struct.scalar(schema, defaults);\n    }\n\n    if (optional) {\n      Struct = struct.union([Struct, 'undefined'], undefined);\n    }\n\n    return Struct;\n  }\n\n  throw new Error(\"A schema definition must be an object, array, string or function, but you passed: \" + schema);\n};\n\nvar createTuple = function createTuple(schema, defaults, struct) {\n  invariant(Array.isArray(schema), \"Tuple structs must be defined as an array, but you passed: \" + schema);\n  var Elements = schema.map(function (s) {\n    return struct(s);\n  });\n  var Struct = createStruct({\n    kind: 'tuple',\n    type: \"[\" + Elements.map(function (S) {\n      return S.type;\n    }).join() + \"]\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = [];\n    var failures = [];\n    var length = Math.max(value.length, Elements.length);\n\n    for (var i = 0; i < length; i++) {\n      var Element = Elements[i];\n      var v = value[i];\n      var p = path.concat(i);\n      var b = branch.concat(v);\n\n      if (!Element) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: b\n        }));\n      } else {\n        var _Element$check = Element.check(v, b, p),\n            efs = _Element$check[0],\n            er = _Element$check[1];\n\n        if (efs) {\n          failures.push.apply(failures, efs);\n        } else {\n          result[i] = er;\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createUnion = function createUnion(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length !== 0, \"Union structs must be defined as a non-empty array, but you passed: \" + schema);\n  var Structs = schema.map(function (sch) {\n    return struct(sch);\n  });\n  var type = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  var Struct = createStruct({\n    kind: 'union',\n    type: type,\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(Structs), _step; !(_step = _iterator()).done;) {\n      var _struct = _step.value;\n\n      var _struct$check = _struct.check(value, branch, path),\n          fs = _struct$check[0],\n          v = _struct$check[1];\n\n      if (!fs) {\n        return [undefined, v];\n      }\n    }\n\n    return [[Struct.fail({\n      value: value,\n      branch: branch,\n      path: path\n    })]];\n  };\n\n  return Struct;\n};\n/**\r\n * Create a struct singleton with settings that include your own domain-specific\r\n * data `types`, and an optional custom `Error` class.\r\n */\n\n\nvar superstruct = function superstruct(settings) {\n  if (settings === void 0) {\n    settings = {};\n  }\n\n  var struct = function struct(schema, defaults) {\n    return createShorthand(schema, defaults, struct);\n  };\n\n  struct.array = function (schema, defaults) {\n    return createArray(schema, defaults, struct);\n  };\n\n  struct.dynamic = function (schema, defaults) {\n    return createDynamic(schema, defaults, struct);\n  };\n\n  struct.enum = function (schema, defaults) {\n    return createEnum(schema, defaults, struct);\n  };\n\n  struct.function = function (schema, defaults) {\n    return createFunction(schema, defaults, struct);\n  };\n\n  struct.instance = function (schema, defaults) {\n    return createInstance(schema, defaults, struct);\n  };\n\n  struct.interface = function (schema, defaults) {\n    return createInterface(schema, defaults, struct);\n  };\n\n  struct.intersection = function (schema, defaults) {\n    return createIntersection(schema, defaults, struct);\n  };\n\n  struct.lazy = function (schema, defaults) {\n    return createLazy(schema, defaults, struct);\n  };\n\n  struct.literal = function (schema, defaults) {\n    return createLiteral(schema, defaults, struct);\n  };\n\n  struct.object = function (schema, defaults) {\n    return createObject(schema, defaults, struct);\n  };\n\n  struct.optional = function (schema, defaults) {\n    return createUnion([schema, 'undefined'], defaults, struct);\n  };\n\n  struct.partial = function (schema, defaults) {\n    return createPartial(schema, defaults, struct);\n  };\n\n  struct.pick = function (schema, defaults) {\n    return createPick(schema, defaults, struct);\n  };\n\n  struct.record = function (schema, defaults) {\n    return createRecord(schema, defaults, struct);\n  };\n\n  struct.scalar = function (schema, defaults) {\n    return createScalar(schema, defaults, struct);\n  };\n\n  struct.size = function (schema, defaults) {\n    return createSize(schema, defaults, struct);\n  };\n\n  struct.tuple = function (schema, defaults) {\n    return createTuple(schema, defaults, struct);\n  };\n\n  struct.union = function (schema, defaults) {\n    return createUnion(schema, defaults, struct);\n  };\n\n  struct.Error = settings.error || StructError;\n  struct.Types = _objectSpread2(_objectSpread2({}, Types), settings.types);\n  return struct;\n};\n/**\r\n * The singleton instance of Superstruct that is exported by default, configured\r\n * with types for all of the JavaScript built-in data types.\r\n *\r\n * You can use it if you don't need any custom types. However, if you do want to\r\n * define custom types, use the [[superstruct]] factory to configure your own\r\n * [[Superstruct]] instance.\r\n */\n\n\nvar struct = superstruct();\nexport { StructError, Types, isStruct, struct, superstruct };","map":{"version":3,"sources":["../node_modules/kind-of/index.js","../src/types.ts","../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../src/struct-error.ts","../src/struct.ts","../src/structs/array.ts","../src/structs/dynamic.ts","../src/structs/enum.ts","../src/structs/function.ts","../src/structs/instance.ts","../src/structs/interface.ts","../src/structs/intersection.ts","../src/structs/lazy.ts","../src/structs/size.ts","../src/structs/literal.ts","../src/structs/object.ts","../src/structs/partial.ts","../src/structs/pick.ts","../src/structs/record.ts","../src/structs/scalar.ts","../src/structs/shorthand.ts","../src/structs/tuple.ts","../src/structs/union.ts","../src/superstruct.ts","../src/index.ts"],"names":["Types","any","value","arguments","kindOf","array","boolean","buffer","date","isNaN","error","float32array","float64array","function","generatorfunction","int16array","int32array","int8array","map","null","number","object","promise","regexp","set","string","symbol","uint16array","uint32array","uint8array","uint8clampedarray","undefined","weakmap","weakset","StructError","invariant","failures","first","path","type","branch","rest","message","JSON","Object","STRUCT","Symbol","isStruct","createStruct","struct","props","Error","Struct","result","obj","createArray","Array","schema","Element","kind","defaults","i","v","efs","er","createDynamic","Dynamic","createEnum","validator","createFunction","r","createInstance","createInterface","Props","Prop","pfs","createIntersection","Structs","s","fs","createLazy","Lazy","createSize","min","max","createLiteral","createObject","d","keys","k","p","b","pr","createPartial","createPick","createRecord","Key","Value","defs","kfs","kr","vfs","vr","createScalar","createShorthand","optional","scalars","createTuple","Elements","S","length","Math","createUnion","superstruct","settings"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAI,QAAQ,GAAG,MAAM,CAAC,SAAP,CAAiB,QAAhC;;AAEA,IAAA,MAAc,GAAG,SAAS,MAAT,CAAgB,GAAhB,EAAqB;AACpC,MAAI,GAAG,KAAK,KAAK,CAAjB,EAAoB,OAAO,WAAP;AACpB,MAAI,GAAG,KAAK,IAAZ,EAAkB,OAAO,MAAP;AAElB,MAAI,IAAI,GAAG,OAAO,GAAlB;AACA,MAAI,IAAI,KAAK,SAAb,EAAwB,OAAO,SAAP;AACxB,MAAI,IAAI,KAAK,QAAb,EAAuB,OAAO,QAAP;AACvB,MAAI,IAAI,KAAK,QAAb,EAAuB,OAAO,QAAP;AACvB,MAAI,IAAI,KAAK,QAAb,EAAuB,OAAO,QAAP;;AACvB,MAAI,IAAI,KAAK,UAAb,EAAyB;AACvB,WAAO,aAAa,CAAC,GAAD,CAAb,GAAqB,mBAArB,GAA2C,UAAlD;AACD;;AAED,MAAI,OAAO,CAAC,GAAD,CAAX,EAAkB,OAAO,OAAP;AAClB,MAAI,QAAQ,CAAC,GAAD,CAAZ,EAAmB,OAAO,QAAP;AACnB,MAAI,WAAW,CAAC,GAAD,CAAf,EAAsB,OAAO,WAAP;AACtB,MAAI,MAAM,CAAC,GAAD,CAAV,EAAiB,OAAO,MAAP;AACjB,MAAI,OAAO,CAAC,GAAD,CAAX,EAAkB,OAAO,OAAP;AAClB,MAAI,QAAQ,CAAC,GAAD,CAAZ,EAAmB,OAAO,QAAP;;AAEnB,UAAQ,QAAQ,CAAC,GAAD,CAAhB;AACE,SAAK,QAAL;AAAe,aAAO,QAAP;;AACf,SAAK,SAAL;AAAgB,aAAO,SAAP;;;AAGhB,SAAK,SAAL;AAAgB,aAAO,SAAP;;AAChB,SAAK,SAAL;AAAgB,aAAO,SAAP;;AAChB,SAAK,KAAL;AAAY,aAAO,KAAP;;AACZ,SAAK,KAAL;AAAY,aAAO,KAAP;;;AAGZ,SAAK,WAAL;AAAkB,aAAO,WAAP;;AAClB,SAAK,YAAL;AAAmB,aAAO,YAAP;;AACnB,SAAK,mBAAL;AAA0B,aAAO,mBAAP;;;AAG1B,SAAK,YAAL;AAAmB,aAAO,YAAP;;AACnB,SAAK,aAAL;AAAoB,aAAO,aAAP;;;AAGpB,SAAK,YAAL;AAAmB,aAAO,YAAP;;AACnB,SAAK,aAAL;AAAoB,aAAO,aAAP;;AACpB,SAAK,cAAL;AAAqB,aAAO,cAAP;;AACrB,SAAK,cAAL;AAAqB,aAAO,cAAP;AAvBvB;;AA0BA,MAAI,cAAc,CAAC,GAAD,CAAlB,EAAyB;AACvB,WAAO,WAAP;AACD,GAhDmC,C;;;AAmDpC,EAAA,IAAI,GAAG,QAAQ,CAAC,IAAT,CAAc,GAAd,CAAP;;AACA,UAAQ,IAAR;AACE,SAAK,iBAAL;AAAwB,aAAO,QAAP;;;AAExB,SAAK,uBAAL;AAA8B,aAAO,aAAP;;AAC9B,SAAK,uBAAL;AAA8B,aAAO,aAAP;;AAC9B,SAAK,0BAAL;AAAiC,aAAO,gBAAP;;AACjC,SAAK,yBAAL;AAAgC,aAAO,eAAP;AANlC,GApDoC,C;;;AA8DpC,SAAO,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,EAAkB,WAAlB,GAAgC,OAAhC,CAAwC,KAAxC,EAA+C,EAA/C,CAAP;AACD,CA/DD;;AAiEA,SAAS,QAAT,CAAkB,GAAlB,EAAuB;AACrB,SAAO,OAAO,GAAG,CAAC,WAAX,KAA2B,UAA3B,GAAwC,GAAG,CAAC,WAAJ,CAAgB,IAAxD,GAA+D,IAAtE;AACD;;AAED,SAAS,OAAT,CAAiB,GAAjB,EAAsB;AACpB,MAAI,KAAK,CAAC,OAAV,EAAmB,OAAO,KAAK,CAAC,OAAN,CAAc,GAAd,CAAP;AACnB,SAAO,GAAG,YAAY,KAAtB;AACD;;AAED,SAAS,OAAT,CAAiB,GAAjB,EAAsB;AACpB,SAAO,GAAG,YAAY,KAAf,IAAyB,OAAO,GAAG,CAAC,OAAX,KAAuB,QAAvB,IAAmC,GAAG,CAAC,WAAvC,IAAsD,OAAO,GAAG,CAAC,WAAJ,CAAgB,eAAvB,KAA2C,QAAjI;AACD;;AAED,SAAS,MAAT,CAAgB,GAAhB,EAAqB;AACnB,MAAI,GAAG,YAAY,IAAnB,EAAyB,OAAO,IAAP;AACzB,SAAO,OAAO,GAAG,CAAC,YAAX,KAA4B,UAA5B,IACF,OAAO,GAAG,CAAC,OAAX,KAAuB,UADrB,IAEF,OAAO,GAAG,CAAC,OAAX,KAAuB,UAF5B;AAGD;;AAED,SAAS,QAAT,CAAkB,GAAlB,EAAuB;AACrB,MAAI,GAAG,YAAY,MAAnB,EAA2B,OAAO,IAAP;AAC3B,SAAO,OAAO,GAAG,CAAC,KAAX,KAAqB,QAArB,IACF,OAAO,GAAG,CAAC,UAAX,KAA0B,SADxB,IAEF,OAAO,GAAG,CAAC,SAAX,KAAyB,SAFvB,IAGF,OAAO,GAAG,CAAC,MAAX,KAAsB,SAH3B;AAID;;AAED,SAAS,aAAT,CAAuB,IAAvB,EAA6B,GAA7B,EAAkC;AAChC,SAAO,QAAQ,CAAC,IAAD,CAAR,KAAmB,mBAA1B;AACD;;AAED,SAAS,cAAT,CAAwB,GAAxB,EAA6B;AAC3B,SAAO,OAAO,GAAG,CAAC,KAAX,KAAqB,UAArB,IACF,OAAO,GAAG,CAAC,MAAX,KAAsB,UADpB,IAEF,OAAO,GAAG,CAAC,IAAX,KAAoB,UAFzB;AAGD;;AAED,SAAS,WAAT,CAAqB,GAArB,EAA0B;AACxB,MAAI;AACF,QAAI,OAAO,GAAG,CAAC,MAAX,KAAsB,QAAtB,IAAkC,OAAO,GAAG,CAAC,MAAX,KAAsB,UAA5D,EAAwE;AACtE,aAAO,IAAP;AACD;AACF,GAJD,CAIE,OAAO,GAAP,EAAY;AACZ,QAAI,GAAG,CAAC,OAAJ,CAAY,OAAZ,CAAoB,QAApB,MAAkC,CAAC,CAAvC,EAA0C;AACxC,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD;;;;;;;AAOD,SAAS,QAAT,CAAkB,GAAlB,EAAuB;AACrB,MAAI,GAAG,CAAC,WAAJ,IAAmB,OAAO,GAAG,CAAC,WAAJ,CAAgB,QAAvB,KAAoC,UAA3D,EAAuE;AACrE,WAAO,GAAG,CAAC,WAAJ,CAAgB,QAAhB,CAAyB,GAAzB,CAAP;AACD;;AACD,SAAO,KAAP;;AC5HF;;;;;;AAKA,IAAaA,KAAK,GAAG;AACnB;;;;;;;;AASAC,EAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,KAAA,EAAA;AAAA,WAAgBC,KAAK,KAArB,SAAA;AAVc,GAAA;;AAYnB;;;;;;;AAQAC,EAAAA,SAAS,EAAE,SAAA,UAAA,CAAA,KAAA,EAAA;AAAA,WAAgBC,MAAM,CAANA,KAAM,CAANA,KAAhB,WAAA;AApBQ,GAAA;;AAsBnB;;;;;;;AAQAC,EAAAA,KAAK,EAAE,SAAA,KAAA,CAAA,KAAA,EAAA;AAAA,WAAgBD,MAAM,CAANA,KAAM,CAANA,KAAhB,OAAA;AA9BY,GAAA;;AAgCnB;;;;;;;;AASAE,EAAAA,OAAO,EAAE,SAAA,OAAA,CAAA,KAAA,EAAA;AAAA,WAAgBF,MAAM,CAANA,KAAM,CAANA,KAAhB,SAAA;AAzCU,GAAA;;AA2CnB;;;;;;;AAQAG,EAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,KAAA,EAAA;AAAA,WAAgBH,MAAM,CAANA,KAAM,CAANA,KAAhB,QAAA;AAnDW,GAAA;;AAqDnB;;;;;;;;;AAUAI,EAAAA,IAAI,EAAE,SAAA,IAAA,CAAA,KAAA,EAAA;AAAA,WAAgBJ,MAAM,CAANA,KAAM,CAANA,KAAAA,MAAAA,IAA4B,CAACK,KAAK,CAAlD,KAAkD,CAAlD;AA/Da,GAAA;;AAiEnB;;;;;;;AAQAC,EAAAA,KAAK,EAAE,SAAA,KAAA,CAAA,KAAA,EAAA;AAAA,WAAgBN,MAAM,CAANA,KAAM,CAANA,KAAhB,OAAA;AAzEY,GAAA;;AA2EnB;;;AAIAO,EAAAA,YAAY,EAAE,SAAA,YAAA,CAAA,KAAA,EAAA;AAAA,WAAgBP,MAAM,CAANA,KAAM,CAANA,KAAhB,cAAA;AA/EK,GAAA;;AAiFnB;;;AAIAQ,EAAAA,YAAY,EAAE,SAAA,YAAA,CAAA,KAAA,EAAA;AAAA,WAAgBR,MAAM,CAANA,KAAM,CAANA,KAAhB,cAAA;AArFK,GAAA;;AAuFnB;;;;;;;;AASAS,EAAAA,QAAQ,EAAE,SAAA,SAAA,CAAA,KAAA,EAAA;AAAA,WAAgBT,MAAM,CAANA,KAAM,CAANA,KAAhB,UAAA;AAhGS,GAAA;;AAkGnB;;;;;;;AAQAU,EAAAA,iBAAiB,EAAE,SAAA,iBAAA,CAAA,KAAA,EAAA;AAAA,WAAgBV,MAAM,CAANA,KAAM,CAANA,KAAhB,mBAAA;AA1GA,GAAA;;AA4GnB;;;AAIAW,EAAAA,UAAU,EAAE,SAAA,UAAA,CAAA,KAAA,EAAA;AAAA,WAAgBX,MAAM,CAANA,KAAM,CAANA,KAAhB,YAAA;AAhHO,GAAA;;AAkHnB;;;AAIAY,EAAAA,UAAU,EAAE,SAAA,UAAA,CAAA,KAAA,EAAA;AAAA,WAAgBZ,MAAM,CAANA,KAAM,CAANA,KAAhB,YAAA;AAtHO,GAAA;;AAwHnB;;;AAIAa,EAAAA,SAAS,EAAE,SAAA,SAAA,CAAA,KAAA,EAAA;AAAA,WAAgBb,MAAM,CAANA,KAAM,CAANA,KAAhB,WAAA;AA5HQ,GAAA;;AA8HnB;;;;;;;AAQAc,EAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,KAAA,EAAA;AAAA,WAAgBd,MAAM,CAANA,KAAM,CAANA,KAAhB,KAAA;AAtIc,GAAA;;AAwInB;;;;;;;AAQAe,EAAAA,IAAI,EAAE,SAAA,KAAA,CAAA,KAAA,EAAA;AAAA,WAAgBf,MAAM,CAANA,KAAM,CAANA,KAAhB,MAAA;AAhJa,GAAA;;AAkJnB;;;;;;;AAQAgB,EAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,KAAA,EAAA;AAAA,WAAgBhB,MAAM,CAANA,KAAM,CAANA,KAAhB,QAAA;AA1JW,GAAA;;AA4JnB;;;;;;;;AASAiB,EAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,KAAA,EAAA;AAAA,WAAgBjB,MAAM,CAANA,KAAM,CAANA,KAAhB,QAAA;AArKW,GAAA;;AAuKnB;;;;;;;AAQAkB,EAAAA,OAAO,EAAE,SAAA,OAAA,CAAA,KAAA,EAAA;AAAA,WAAgBlB,MAAM,CAANA,KAAM,CAANA,KAAhB,SAAA;AA/KU,GAAA;;AAiLnB;;;;;;;AAQAmB,EAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,KAAA,EAAA;AAAA,WAAgBnB,MAAM,CAANA,KAAM,CAANA,KAAhB,QAAA;AAzLW,GAAA;;AA2LnB;;;;;;;AAQAoB,EAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,KAAA,EAAA;AAAA,WAAgBpB,MAAM,CAANA,KAAM,CAANA,KAAhB,KAAA;AAnMc,GAAA;;AAqMnB;;;;;;;AAQAqB,EAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,KAAA,EAAA;AAAA,WAAgBrB,MAAM,CAANA,KAAM,CAANA,KAAhB,QAAA;AA7MW,GAAA;;AA+MnB;;;;;;;AAQAsB,EAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,KAAA,EAAA;AAAA,WAAgBtB,MAAM,CAANA,KAAM,CAANA,KAAhB,QAAA;AAvNW,GAAA;;AAyNnB;;;AAIAuB,EAAAA,WAAW,EAAE,SAAA,WAAA,CAAA,KAAA,EAAA;AAAA,WAAgBvB,MAAM,CAANA,KAAM,CAANA,KAAhB,aAAA;AA7NM,GAAA;;AA+NnB;;;AAIAwB,EAAAA,WAAW,EAAE,SAAA,WAAA,CAAA,KAAA,EAAA;AAAA,WAAgBxB,MAAM,CAANA,KAAM,CAANA,KAAhB,aAAA;AAnOM,GAAA;;AAqOnB;;;AAIAyB,EAAAA,UAAU,EAAE,SAAA,UAAA,CAAA,KAAA,EAAA;AAAA,WAAgBzB,MAAM,CAANA,KAAM,CAANA,KAAhB,YAAA;AAzOO,GAAA;;AA2OnB;;;AAIA0B,EAAAA,iBAAiB,EAAE,SAAA,iBAAA,CAAA,KAAA,EAAA;AAAA,WAAgB1B,MAAM,CAANA,KAAM,CAANA,KAAhB,mBAAA;AA/OA,GAAA;;AAiPnB;;;;;;;AAQA2B,EAAAA,SAAS,EAAE,SAAA,WAAA,CAAA,KAAA,EAAA;AAAA,WAAgB3B,MAAM,CAANA,KAAM,CAANA,KAAhB,WAAA;AAzPQ,GAAA;;AA2PnB;;;;;;;AAQA4B,EAAAA,OAAO,EAAE,SAAA,OAAA,CAAA,KAAA,EAAA;AAAA,WAAgB5B,MAAM,CAANA,KAAM,CAANA,KAAhB,SAAA;AAnQU,GAAA;;AAqQnB;;;;;;;AAQA6B,EAAAA,OAAO,EAAE,SAAA,OAAA,CAAA,KAAA,EAAA;AAAA,WAAgB7B,MAAM,CAANA,KAAM,CAANA,KAAhB,SAAA;AAAA;AA7QU,CAArB;ACRA,IAAI,YAAY,GAAG,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA5C;AACA,IAAI,MAAM,GAAG,kBAAb;;AACA,SAAS,SAAT,CAAmB,SAAnB,EAA8B,OAA9B,EAAuC;AACrC,MAAI,SAAJ,EAAe;AACb;AACD;;AAED,MAAI,YAAJ,EAAkB;AAChB,UAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACD,GAFD,MAEO;AACL,UAAM,IAAI,KAAJ,CAAU,MAAM,GAAG,IAAT,IAAiB,OAAO,IAAI,EAA5B,CAAV,CAAN;AACD;AACF;ACVD;;;;;;;;AAOA,IAAa8B,WAAb,GAAA,aAAA,UAAA,UAAA,EAAA;AAAA,EAAA,cAAA,CAAA,WAAA,EAAA,UAAA,CAAA;;AAQE,WAAA,WAAA,CAAA,QAAA,EAAA;;;AACEC,IAAAA,SAAS,CACPC,QAAQ,CAARA,MAAAA,GADO,CAAA,EAAA,gEAATD,QAAS,CAATA;QAKOE,KAAAA,GAASD,QAAAA,CAAAA,CAAAA,C;;QACRE,IAAAA,GAAuCD,KAAAA,CAAvCC,I;QAAMpC,KAAAA,GAAiCmC,KAAAA,CAAjCnC,K;QAAOqC,IAAAA,GAA0BF,KAAAA,CAA1BE,I;QAAMC,MAAAA,GAAoBH,KAAAA,CAApBG,M;QAAWC,IAAAA,GAAAA,6BAAAA,CAASJ,KAATI,EAASJ,CAAAA,MAAAA,EAAAA,OAAAA,EAAAA,MAAAA,EAAAA,QAAAA,CAATI,C;;AACtC,QAAMC,OAAO,GAAA,+BAAA,IAAA,GAAA,GAAA,IACXJ,IAAI,CAAJA,MAAAA,GAAAA,WAAwBA,IAAI,CAAJA,IAAAA,CAAxBA,GAAwBA,CAAxBA,GAAAA,GAAAA,GADW,EAAA,IAAA,iBAAA,GAEMK,IAAI,CAAJA,SAAAA,CAFN,KAEMA,CAFN,GAAb,IAAA;AAIA,IAAA,KAAA,GAAA,UAAA,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,KAAA,IAAA;AACA,IAAA,KAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,KAAA,CAAA,KAAA,GAAA,KAAA;AACAC,IAAAA,MAAM,CAANA,MAAAA,CAAAA,sBAAAA,CAAAA,KAAAA,CAAAA,EAAAA,IAAAA;AACA,IAAA,KAAA,CAAA,IAAA,GAAA,IAAA;AACA,IAAA,KAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,KAAA,CAAA,QAAA,GAAA,QAAA;AACA,IAAA,KAAA,CAAA,KAAA,GAAa,IAAA,KAAA,GAAb,KAAA;AACE,IAAA,KAAA,CAAA,SAAA,GAAyBV,WAAW,CAApC,SAAA;;AACH;;AA7BH,SAAA,WAAA;AAAA,CAAA,EAAA,aAAA,gBAAA,CAAA,SAAA,CAAA,CAAA;ACNA;;;;;AAIO,IAAMW,MAAM,GAAGC,MAAM,CAArB,QAAqB,CAArB;AAEP;;;;AAIA,IAAaC,QAAQ,GAAG,SAAXA,QAAW,CAAA,KAAA,EAAA;AACtB,SAAO,OAAA,KAAA,KAAA,UAAA,IAA+B7C,KAAK,CAA3C,MAA2C,CAA3C;AADK,CAAP;AAIA;;;;;;AAKO,IAAM8C,YAAY,GAAG,SAAfA,YAAe,CAAA,KAAA,EAAA;MAMlBC,MAAAA,GAAWC,KAAAA,CAAXD,M;MACAE,KAAAA,GAAUF,MAAAA,CAAVE,K;;AACR,MAAMC,MAAM,GAAG,SAATA,MAAS,CAAA,KAAA,EAAA;AAAA,WAAqBA,MAAM,CAANA,MAAAA,CAArB,KAAqBA,CAArB;AAAf,GAAA,CAR0B,CAQ1B;AAGA;;;AACAR,EAAAA,MAAM,CAANA,cAAAA,CAAAA,MAAAA,EAAAA,MAAAA,EAAsC;AAAE1C,IAAAA,KAAK,EAAE;AAAT,GAAtC0C;AAEAQ,EAAAA,MAAM,CAANA,IAAAA,GAAcF,KAAK,CAAnBE,IAAAA;AACAA,EAAAA,MAAM,CAANA,IAAAA,GAAcF,KAAK,CAAnBE,IAAAA;;AAEAA,EAAAA,MAAM,CAANA,OAAAA,GAAiB,YAAA;AACf,WAAO,OAAOF,KAAK,CAAZ,QAAA,KAAA,UAAA,GACHA,KAAK,CADF,QACHA,EADG,GAEHA,KAAK,CAFT,QAAA;AADFE,GAAAA;;AAMAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,UAAA,KAAA,EAAA;wBACOA,MAAM,CAANA,KAAAA,CAAAA,KAAAA,EAAoB,CAApBA,KAAoB,CAApBA,EAAAA,EAAAA,C;QAAZhB,QAAAA,GAAAA,aAAAA,CAAAA,CAAAA,C;;AACP,WAAO,CAAP,QAAA;AAFFgB,GAAAA;;AAKAA,EAAAA,MAAM,CAANA,MAAAA,GAAgB,UAAA,KAAA,EAAA;yBACaA,MAAM,CAANA,KAAAA,CAAAA,KAAAA,EAAoB,CAApBA,KAAoB,CAApBA,EAAAA,EAAAA,C;QAApBhB,QAAAA,GAAAA,cAAAA,CAAAA,CAAAA,C;QAAUiB,MAAAA,GAAAA,cAAAA,CAAAA,CAAAA,C;;AAEjB,QAAA,QAAA,EAAc;AACZ,YAAM,IAAA,KAAA,CAAN,QAAM,CAAN;AADF,KAAA,MAEO;AACL,aAAA,MAAA;AACD;AAPHD,GAAAA;;AAUAA,EAAAA,MAAM,CAANA,QAAAA,GAAkB,UAAA,KAAA,EAAA;yBACWA,MAAM,CAANA,KAAAA,CAAAA,KAAAA,EAAoB,CAApBA,KAAoB,CAApBA,EAAAA,EAAAA,C;QAApBhB,QAAAA,GAAAA,cAAAA,CAAAA,CAAAA,C;QAAUiB,MAAAA,GAAAA,cAAAA,CAAAA,CAAAA,C;;AAEjB,QAAA,QAAA,EAAc;AACZ,aAAO,CAAC,IAAA,KAAA,CAAR,QAAQ,CAAD,CAAP;AADF,KAAA,MAEO;AACL,aAAO,CAAA,SAAA,EAAP,MAAO,CAAP;AACD;AAPHD,GAAAA;;AAUAA,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAMkC,QAAQ,GAAG,CAAC,MAAM,CAAN,IAAA,CAAY;AAAElC,MAAAA,KAAK,EAAP,KAAA;AAASsC,MAAAA,MAAM,EAAf,MAAA;AAAiBF,MAAAA,IAAI,EAAJA;AAAjB,KAAZ,CAAD,CAAjB;AACA,WAAO,CAAP,QAAO,CAAP;AANFc,GAAAA;;AASAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,UAAA,GAAA,EAAA;AAMZ,WAAA,cAAA,CAAA,cAAA,CAAA,EAAA,EAAA,GAAA,CAAA,EAAA,EAAA,EAAA;AAAiBb,MAAAA,IAAI,EAAE,UAAA,GAAA,GAAgBe,GAAG,CAAnB,IAAA,GAA2BF,MAAM,CAACb;AAAzD,KAAA,CAAA;AANFa,GAAAA;;AASA,SAAA,MAAA;AAlEK,CAAA;;AClBA,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKzBpB,EAAAA,SAAS,CACPqB,KAAK,CAALA,OAAAA,CAAAA,MAAAA,KAAyBC,MAAM,CAANA,MAAAA,KADlB,CAAA,EAAA,iFAATtB,MAAS,CAATA;AAKA,MAAMuB,OAAO,GAAGT,MAAM,CAACQ,MAAM,CAAP,CAAO,CAAP,EAAtB,SAAsB,CAAtB;AACA,MAAML,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,OAAA;AAE1BpB,IAAAA,IAAI,EAAKmB,OAAO,CAAZ,IAAKA,GAFiB,IAAA;AAG1BE,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAI,CAACsD,KAAK,CAALA,OAAAA,CAAL,KAAKA,CAAL,EAA2B;AACzB,aAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAEtD,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAD,CAAD,CAAP;AACD;;AAED,QAAMe,MAAM,GAAZ,EAAA;AACA,QAAMjB,QAAQ,GAAd,EAAA;;AAEA,SAAK,IAAIyB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAG3D,KAAK,CAAzB,MAAA,EAAkC2D,CAAlC,EAAA,EAAuC;AACrC,UAAMC,CAAC,GAAG5D,KAAK,CAAf,CAAe,CAAf;;AADqC,UAAA,cAAA,GAEnBwD,OAAO,CAAPA,KAAAA,CAAAA,CAAAA,EAAiBlB,MAAM,CAANA,MAAAA,CAAjBkB,CAAiBlB,CAAjBkB,EAAmCpB,IAAI,CAAJA,MAAAA,CAFhB,CAEgBA,CAAnCoB,CAFmB;AAAA,UAE9BK,GAF8B,GAAA,cAAA,CAAA,CAAA,CAAA;AAAA,UAEzBC,EAFyB,GAAA,cAAA,CAAA,CAAA,CAAA;;AAIrC,UAAA,GAAA,EAAS;AACP5B,QAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AACA;AACD;;AAEDiB,MAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,EAAAA;AACD;;AAED,WAAOjB,QAAQ,CAARA,MAAAA,GAAkB,CAAlBA,QAAkB,CAAlBA,GAA+B,CAAA,SAAA,EAAtC,MAAsC,CAAtC;AAxBFgB,GAAAA;;AA2BA,SAAA,MAAA;AA7CK,CAAA;;ACAA,IAAMa,aAAa,GAAG,SAAhBA,aAAgB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK3B9B,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,UAAA,EAAA,oEAATA,MAAS,CAATA;AAKA,MAAM+B,OAAO,GAAGlB,YAAY,CAAC;AAC3BW,IAAAA,IAAI,EADuB,SAAA;AAE3BpB,IAAAA,IAAI,EAFuB,iBAAA;AAG3BqB,IAAAA,QAAQ,EAHmB,QAAA;AAI3BX,IAAAA,MAAM,EAANA;AAJ2B,GAAD,CAA5B;;AAOAiB,EAAAA,OAAO,CAAPA,KAAAA,GAAgB,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACdhE,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAagE,OAAO,CAAPA,OAAAA,EAAbhE;;;AAIA,QAAMkD,MAAM,GAAGK,MAAM,CAAA,KAAA,EAAA,MAAA,EAArB,IAAqB,CAArB;AACA,WAAOL,MAAM,CAANA,KAAAA,CAAAA,KAAAA,EAAAA,MAAAA,EAAP,IAAOA,CAAP;AANFc,GAAAA;;AASA,SAAA,OAAA;AA1BK,CAAA;;ACDA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKxBhC,EAAAA,SAAS,CACPqB,KAAK,CAALA,OAAAA,CADO,MACPA,CADO,EAAA,+DAATrB,MAAS,CAATA;;AAKA,MAAMiC,SAAS,GAAG,SAAZA,SAAY,CAAA,KAAA,EAAA;AAAA,WAAgBX,MAAM,CAANA,QAAAA,CAAhB,KAAgBA,CAAhB;AAAlB,GAAA;;AACA,MAAML,MAAM,GAAGH,MAAM,CAAA,SAAA,EAArB,QAAqB,CAArB;AACAG,EAAAA,MAAM,CAANA,IAAAA,GAAAA,MAAAA;AACAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,MAAM,CAAN,GAAA,CACP,UAAA,CAAA,EAAC;AAAA,WAAK,OAAA,CAAA,KAAA,QAAA,GAAA,OAAA,CAAA,GAAA,IAAA,GAAA,KAAL,CAAA;AADM,GAAA,EAAA,IAAA,CAAdA,KAAc,CAAdA;AAGA,SAAA,MAAA;AAhBK,CAAA;;ACCA,IAAMiB,cAAc,GAAG,SAAjBA,cAAiB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK5B,MAAMjB,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,UAAA;AAE1BpB,IAAAA,IAAI,EAFsB,kBAAA;AAG1BqB,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAMmD,MAAM,GAAGI,MAAM,CAAA,KAAA,EAAA,MAAA,EAArB,IAAqB,CAArB;;AAEA,QAAIJ,MAAM,KAAV,IAAA,EAAqB;AACnB,aAAO,CAAA,SAAA,EAAP,KAAO,CAAP;AACD;;AAED,QAAMjB,QAAQ,GAAd,EAAA;;AAEA,QAAIiB,MAAM,KAAV,KAAA,EAAsB;AACpBjB,MAAAA,QAAQ,CAARA,IAAAA,CAAc,MAAM,CAAN,IAAA,CAAY;AAAElC,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAdF;AADF,KAAA,MAEO,IAAIoB,KAAK,CAALA,OAAAA,CAAAA,MAAAA,KAAyBH,MAAM,CAANA,MAAAA,GAA7B,CAAA,EAAgD;AACrD,WAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,MAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAwB;AAAA,YAAbiB,CAAa,GAAA,KAAA,CAAA,KAAA;AACtBlC,QAAAA,QAAQ,CAARA,IAAAA,CAAc,MAAM,CAAN,IAAA,CAAA,cAAA,CAAA;AAAclC,UAAAA,KAAK,EAAnB,KAAA;AAAqBsC,UAAAA,MAAM,EAA3B,MAAA;AAA6BF,UAAAA,IAAI,EAAJA;AAA7B,SAAA,EAAdF,CAAc,CAAA,CAAdA;AACD;AAHI,KAAA,MAIA,IAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AACrCA,MAAAA,QAAQ,CAARA,IAAAA,CAAc,MAAM,CAAN,IAAA,CAAA,cAAA,CAAA;AAAclC,QAAAA,KAAK,EAAnB,KAAA;AAAqBsC,QAAAA,MAAM,EAA3B,MAAA;AAA6BF,QAAAA,IAAI,EAAJA;AAA7B,OAAA,EAAdF,MAAc,CAAA,CAAdA;AADK,KAAA,MAEA;AACLD,MAAAA,SAAS,CAAA,KAAA,EAAA,kHAATA,MAAS,CAATA;AAID;;AAED,WAAO,CAAP,QAAO,CAAP;AA5BFiB,GAAAA;;AA+BA,SAAA,MAAA;AA3CK,CAAA;;ACDA,IAAMmB,cAAc,GAAG,SAAjBA,cAAiB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK5BpC,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,UAAA,EAAA,qEAATA,MAAS,CAATA;;AAKA,MAAMiC,SAAS,GAAG,SAAZA,SAAY,CAAA,KAAA,EAAA;AAAA,WAAgBlE,KAAK,YAArB,MAAA;AAAlB,GAAA;;AACA,MAAMkD,MAAM,GAAGH,MAAM,CAAA,SAAA,EAArB,QAAqB,CAArB;AACAG,EAAAA,MAAM,CAANA,IAAAA,GAAAA,UAAAA;AACAA,EAAAA,MAAM,CAANA,IAAAA,GAAAA,cAA0BK,MAAM,CAAhCL,IAAAA,GAAAA,GAAAA;AACA,SAAA,MAAA;AAdK,CAAA;;ACCA,IAAMoB,eAAe,GAAG,SAAlBA,eAAkB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK7BrC,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,QAAA,EAAA,qEAATA,MAAS,CAATA;AAKA,MAAMsC,KAAK,GAAX,EAAA;;AAEA,OAAK,IAAL,GAAA,IAAA,MAAA,EAA0B;AACxBA,IAAAA,KAAK,CAALA,GAAK,CAALA,GAAaxB,MAAM,CAACQ,MAAM,CAA1BgB,GAA0B,CAAP,CAAnBA;AACD;;AAED,MAAMrB,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,WAAA;AAE1BpB,IAAAA,IAAI,EAAA,gBAAgBK,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAhB,IAAgBA,EAAhB,GAFsB,IAAA;AAG1BgB,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAI,OAAA,KAAA,KAAA,QAAA,IAA6B,OAAA,KAAA,KAAjC,UAAA,EAA8D;AAC5D,aAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAEA,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAD,CAAD,CAAP;AACD;;AAED,QAAMF,QAAQ,GAAd,EAAA;;AAEA,SAAK,IAAL,CAAA,IAAA,KAAA,EAAuB;AACrB,UAAMsC,IAAI,GAAGD,KAAK,CAAlB,CAAkB,CAAlB;AACA,UAAMX,CAAC,GAAG5D,KAAK,CAAf,CAAe,CAAf;;AAFqB,UAAA,WAAA,GAGPwE,IAAI,CAAJA,KAAAA,CAAAA,CAAAA,EAAclC,MAAM,CAANA,MAAAA,CAAdkC,CAAclC,CAAdkC,EAAgCpC,IAAI,CAAJA,MAAAA,CAHzB,CAGyBA,CAAhCoC,CAHO;AAAA,UAGdC,GAHc,GAAA,WAAA,CAAA,CAAA,CAAA;;AAKrB,UAAA,GAAA,EAAS;AACPvC,QAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AACD;AACF;;AAED,WAAOA,QAAQ,CAARA,MAAAA,GAAkB,CAAlBA,QAAkB,CAAlBA,GAA+B,CAAA,SAAA,EAAtC,KAAsC,CAAtC;AArBFgB,GAAAA;;AAwBA,SAAA,MAAA;AA/CK,CAAA;;ACAA,IAAMwB,kBAAkB,GAAG,SAArBA,kBAAqB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKhCzC,EAAAA,SAAS,CACPqB,KAAK,CAALA,OAAAA,CAAAA,MAAAA,KAAyBC,MAAM,CAANA,MAAAA,KADlB,CAAA,EAAA,gFAATtB,MAAS,CAATA;AAKA,MAAM0C,OAAO,GAAG,MAAM,CAAN,GAAA,CAAW,UAAA,GAAA,EAAG;AAAA,WAAI5B,MAAM,CAAV,GAAU,CAAV;AAA9B,GAAgB,CAAhB;AACA,MAAMV,IAAI,GAAG,OAAO,CAAP,GAAA,CAAY,UAAA,CAAA,EAAC;AAAA,WAAIuC,CAAC,CAAL,IAAA;AAAb,GAAA,EAAA,IAAA,CAAb,KAAa,CAAb;AACA,MAAM1B,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,cAAA;AAE1BpB,IAAAA,IAAI,EAFsB,IAAA;AAG1BqB,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAImD,MAAM,GAAV,KAAA;;AAEA,SAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,OAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAA8B;AAAA,UAAnBJ,OAAmB,GAAA,KAAA,CAAA,KAAA;;AAAA,UAAA,aAAA,GACZA,OAAM,CAANA,KAAAA,CAAAA,KAAAA,EAAAA,MAAAA,EADY,IACZA,CADY;AAAA,UACrB8B,EADqB,GAAA,aAAA,CAAA,CAAA,CAAA;AAAA,UACjBjB,CADiB,GAAA,aAAA,CAAA,CAAA,CAAA;;AAG5B,UAAA,EAAA,EAAQ;AACN,eAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAE5D,UAAAA,KAAK,EAAP,KAAA;AAASsC,UAAAA,MAAM,EAAf,MAAA;AAAiBF,UAAAA,IAAI,EAAJA;AAAjB,SAAZ,CAAD,CAAD,CAAP;AADF,OAAA,MAEO;AACLe,QAAAA,MAAM,GAANA,CAAAA;AACD;AACF;;AAED,WAAO,CAAA,SAAA,EAAP,MAAO,CAAP;AAjBFD,GAAAA;;AAoBA,SAAA,MAAA;AAvCK,CAAA;;ACAA,IAAM4B,UAAU,GAAG,SAAbA,UAAa,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKxB7C,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,UAAA,EAAA,iEAATA,MAAS,CAATA;AAKA,MAAM8C,IAAI,GAAGjC,YAAY,CAAC;AACxBW,IAAAA,IAAI,EADoB,MAAA;AAExBpB,IAAAA,IAAI,EAFoB,cAAA;AAGxBqB,IAAAA,QAAQ,EAHgB,QAAA;AAIxBX,IAAAA,MAAM,EAANA;AAJwB,GAAD,CAAzB;;AAOAgC,EAAAA,IAAI,CAAJA,KAAAA,GAAa,YAAA;AACXrC,IAAAA,MAAM,CAANA,MAAAA,CAAAA,IAAAA,EAAoBa,MAApBb,EAAAA;AACA,WAAOqC,IAAI,CAAJA,KAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAP,SAAOA,CAAP;AAFFA,GAAAA;;AAKA,SAAA,IAAA;AAtBK,CAAA;;ACDA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKxB/C,EAAAA,SAAS,CACPqB,KAAK,CAALA,OAAAA,CAAAA,MAAAA,KACEC,MAAM,CAANA,MAAAA,KADFD,CAAAA,IAEE,MAAM,CAAN,KAAA,CAAa,UAAA,CAAA,EAAC;AAAA,WAAI,OAAA,CAAA,KAAJ,QAAA;AAHT,GAGL,CAHK,EAAA,wFAATrB,MAAS,CAATA;MAOOgD,GAAAA,GAAY1B,MAAAA,CAAAA,CAAAA,C;MAAP2B,GAAAA,GAAO3B,MAAAA,CAAAA,CAAAA,C;;AACnB,MAAMW,SAAS,GAAG,SAAZA,SAAY,CAAA,KAAA,EAAA;AAAA,WAChBlE,KAAK,IAALA,IAAAA,IACA,OAAOA,KAAK,CAAZ,MAAA,KADAA,QAAAA,IAEAA,KAAK,CAALA,MAAAA,IAFAA,GAAAA,IAGAA,KAAK,CAALA,MAAAA,IAJgB,GAAA;AAAlB,GAAA;;AAMA,MAAMkD,MAAM,GAAGH,MAAM,CAAA,SAAA,EAArB,QAAqB,CAArB;AACAG,EAAAA,MAAM,CAANA,IAAAA,GAAAA,MAAAA;AACAA,EAAAA,MAAM,CAANA,IAAAA,GAAAA,UAAAA,GAAAA,GAAAA,GAAAA,GAAAA,GAAAA,GAAAA,GAAAA;AACA,SAAA,MAAA;AAtBK,CAAA;;ACDA,IAAMiC,aAAa,GAAG,SAAhBA,aAAgB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK3B,MAAMjB,SAAS,GAAG,SAAZA,SAAY,CAAA,KAAA,EAAA;AAAA,WAAgBlE,KAAK,KAArB,MAAA;AAAlB,GAAA;;AACA,MAAMkD,MAAM,GAAGH,MAAM,CAAA,SAAA,EAArB,QAAqB,CAArB;AACAG,EAAAA,MAAM,CAANA,IAAAA,GAAAA,SAAAA;AACAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,OAAA,MAAA,KAAA,QAAA,GAAA,OAAA,MAAA,GAAA,IAAA,GAAA,KAAdA,MAAAA;AACA,SAAA,MAAA;AATK,CAAA;;ACGA,IAAMkC,YAAY,GAAG,SAAfA,YAAe,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK1BnD,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,QAAA,EAAA,kEAATA,MAAS,CAATA;AAKA,MAAMsC,KAAK,GAAX,EAAA;;AAEA,OAAK,IAAL,GAAA,IAAA,MAAA,EAA0B;AACxBA,IAAAA,KAAK,CAALA,GAAK,CAALA,GAAaxB,MAAM,CAACQ,MAAM,CAA1BgB,GAA0B,CAAP,CAAnBA;AACD;;AAED,MAAMrB,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,QAAA;AAE1BpB,IAAAA,IAAI,EAAA,MAAMK,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAN,IAAMA,EAAN,GAFsB,GAAA;AAG1BgB,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAMqF,CAAC,GAAGnC,MAAM,CAAhB,OAAUA,EAAV;;AAEA,QAAIlD,KAAK,KAAT,SAAA,EAAyB;AACvBA,MAAAA,KAAK,GAALA,CAAAA;AACD;;AAED,QAAIE,MAAM,CAANA,KAAM,CAANA,KAAJ,QAAA,EAAgC;AAC9B,aAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAEF,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAD,CAAD,CAAP;AACD;;AAED,QAAMe,MAAM,GAAZ,EAAA;AACA,QAAMjB,QAAQ,GAAd,EAAA;AACA,QAAMoD,IAAI,GAAG,IAAA,GAAA,CAAQ5C,MAAM,CAANA,IAAAA,CAAAA,KAAAA,EAAAA,MAAAA,CAA0BA,MAAM,CAANA,IAAAA,CAA/C,KAA+CA,CAA1BA,CAAR,CAAb;;AAEA,SAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,IAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAsB;AAAA,UAAX6C,CAAW,GAAA,KAAA,CAAA,KAAA;AACpB,UAAI3B,CAAC,GAAG5D,KAAK,CAAb,CAAa,CAAb;AACA,UAAMwF,CAAC,GAAGpD,IAAI,CAAJA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMqD,CAAC,GAAGnD,MAAM,CAANA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMkC,IAAI,GAAGD,KAAK,CAAlB,CAAkB,CAAlB;;AAEA,UAAIX,CAAC,KAADA,SAAAA,IAAmByB,CAAC,IAApBzB,IAAAA,IAAgC2B,CAAC,IAArC,CAAA,EAA4C;AAC1C3B,QAAAA,CAAC,GAAG,OAAOyB,CAAC,CAAR,CAAQ,CAAR,KAAA,UAAA,GAA6BA,CAAC,CAADA,CAAC,CAADA,CAAAA,KAAAA,EAAAA,MAAAA,EAA7B,IAA6BA,CAA7B,GAAyDA,CAAC,CAA9DzB,CAA8D,CAA9DA;AACD;;AAED,UAAI,EAAE2B,CAAC,IAAP,KAAI,CAAJ,EAAmB;AACjBrD,QAAAA,QAAQ,CAARA,IAAAA,CACE,MAAM,CAAN,IAAA,CAAY;AACVG,UAAAA,IAAI,EADM,SAAA;AAEVrC,UAAAA,KAAK,EAFK,CAAA;AAGVoC,UAAAA,IAAI,EAHM,CAAA;AAIVE,UAAAA,MAAM,EAAEtC;AAJE,SAAZ,CADFkC;AASA;AACD;;AArBmB,UAAA,WAAA,GAuBFsC,IAAI,CAAJA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAvBE,CAuBFA,CAvBE;AAAA,UAuBbC,GAvBa,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,UAuBRiB,EAvBQ,GAAA,WAAA,CAAA,CAAA,CAAA;;AAyBpB,UAAA,GAAA,EAAS;AACPxD,QAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AADF,OAAA,MAEO,IAAIwD,EAAE,KAAFA,SAAAA,IAAoBH,CAAC,IAAzB,KAAA,EAAoC;AACzCpC,QAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,EAAAA;AACD;AACF;;AAED,WAAOjB,QAAQ,CAARA,MAAAA,GAAkB,CAAlBA,QAAkB,CAAlBA,GAA+B,CAAA,SAAA,EAAtC,MAAsC,CAAtC;AAnDFgB,GAAAA;;AAsDA,SAAA,MAAA;AA7EK,CAAA;;ACAA,IAAMyC,aAAa,GAAG,SAAhBA,aAAgB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK3B1D,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,QAAA,EAAA,mEAATA,MAAS,CAATA;AAKA,MAAMsC,KAAK,GAAX,EAAA;;AAEA,OAAK,IAAL,GAAA,IAAA,MAAA,EAA0B;AACxBA,IAAAA,KAAK,CAALA,GAAK,CAALA,GAAaxB,MAAM,CAANA,KAAAA,CAAa,CAACQ,MAAM,CAAP,GAAO,CAAP,EAA1BgB,WAA0B,CAAbxB,CAAbwB;AACD;;AAED,MAAMrB,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,QAAA;AAE1BpB,IAAAA,IAAI,EAAA,MAAMK,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAN,IAAMA,EAAN,GAFsB,GAAA;AAG1BgB,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAMqF,CAAC,GAAGnC,MAAM,CAAhB,OAAUA,EAAV;;AAEA,QAAIlD,KAAK,KAAT,SAAA,EAAyB;AACvBA,MAAAA,KAAK,GAALA,CAAAA;AACD;;AAED,QAAIE,MAAM,CAANA,KAAM,CAANA,KAAJ,QAAA,EAAgC;AAC9B,aAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAEF,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAD,CAAD,CAAP;AACD;;AAED,QAAMe,MAAM,GAAZ,EAAA;AACA,QAAMjB,QAAQ,GAAd,EAAA;;AAEA,SAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,KAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAuB;AAAA,UAAZqD,CAAY,GAAA,KAAA,CAAA,KAAA;AACrB,UAAI3B,CAAC,GAAG5D,KAAK,CAAb,CAAa,CAAb;AACA,UAAMwF,CAAC,GAAGpD,IAAI,CAAJA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMqD,CAAC,GAAGnD,MAAM,CAANA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMkC,IAAI,GAAGD,KAAK,CAAlB,CAAkB,CAAlB;;AAEA,UAAIX,CAAC,KAADA,SAAAA,IAAmByB,CAAC,IAApBzB,IAAAA,IAAgC2B,CAAC,IAArC,CAAA,EAA4C;AAC1C3B,QAAAA,CAAC,GAAG,OAAOyB,CAAC,CAAR,CAAQ,CAAR,KAAA,UAAA,GAA6BA,CAAC,CAADA,CAAC,CAADA,CAAAA,KAAAA,EAAAA,MAAAA,EAA7B,IAA6BA,CAA7B,GAAyDA,CAAC,CAA9DzB,CAA8D,CAA9DA;AACD;;AAED,UAAI,EAAE2B,CAAC,IAAP,KAAI,CAAJ,EAAmB;AACjBrD,QAAAA,QAAQ,CAARA,IAAAA,CACE,MAAM,CAAN,IAAA,CAAY;AACVG,UAAAA,IAAI,EADM,SAAA;AAEVrC,UAAAA,KAAK,EAFK,CAAA;AAGVoC,UAAAA,IAAI,EAHM,CAAA;AAIVE,UAAAA,MAAM,EAAEtC;AAJE,SAAZ,CADFkC;AASA;AACD;;AArBoB,UAAA,WAAA,GAuBHsC,IAAI,CAAJA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAvBG,CAuBHA,CAvBG;AAAA,UAuBdC,GAvBc,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,UAuBTiB,EAvBS,GAAA,WAAA,CAAA,CAAA,CAAA;;AAyBrB,UAAA,GAAA,EAAS;AACPxD,QAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AADF,OAAA,MAEO,IAAIwD,EAAE,KAAFA,SAAAA,IAAoBH,CAAC,IAAzB,KAAA,EAAoC;AACzCpC,QAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,EAAAA;AACD;AACF;;AAED,WAAOjB,QAAQ,CAARA,MAAAA,GAAkB,CAAlBA,QAAkB,CAAlBA,GAA+B,CAAA,SAAA,EAAtC,MAAsC,CAAtC;AAlDFgB,GAAAA;;AAqDA,SAAA,MAAA;AA5EK,CAAA;;ACAA,IAAM0C,UAAU,GAAG,SAAbA,UAAa,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKxB3D,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,QAAA,EAAA,gEAATA,MAAS,CAATA;AAKA,MAAMsC,KAAK,GAAX,EAAA;;AAEA,OAAK,IAAL,GAAA,IAAA,MAAA,EAA0B;AACxBA,IAAAA,KAAK,CAALA,GAAK,CAALA,GAAaxB,MAAM,CAACQ,MAAM,CAA1BgB,GAA0B,CAAP,CAAnBA;AACD;;AAED,MAAMrB,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,MAAA;AAE1BpB,IAAAA,IAAI,EAAA,WAAWK,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAX,IAAWA,EAAX,GAFsB,IAAA;AAG1BgB,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAMqF,CAAC,GAAGnC,MAAM,CAAhB,OAAUA,EAAV;;AAEA,QAAIlD,KAAK,KAAT,SAAA,EAAyB;AACvBA,MAAAA,KAAK,GAALA,CAAAA;AACD;;AAED,QAAIE,MAAM,CAANA,KAAM,CAANA,KAAJ,QAAA,EAAgC;AAC9B,aAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAEF,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAD,CAAD,CAAP;AACD;;AAED,QAAMe,MAAM,GAAZ,EAAA;AACA,QAAMjB,QAAQ,GAAd,EAAA;;AAEA,SAAK,IAAL,CAAA,IAAA,KAAA,EAAuB;AACrB,UAAI0B,CAAC,GAAG5D,KAAK,CAAb,CAAa,CAAb;AACA,UAAMwF,CAAC,GAAGpD,IAAI,CAAJA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMqD,CAAC,GAAGnD,MAAM,CAANA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMkC,IAAI,GAAGD,KAAK,CAAlB,CAAkB,CAAlB;;AAEA,UAAIX,CAAC,KAADA,SAAAA,IAAmByB,CAAC,IAApBzB,IAAAA,IAAgC2B,CAAC,IAArC,CAAA,EAA4C;AAC1C3B,QAAAA,CAAC,GAAG,OAAOyB,CAAC,CAAR,CAAQ,CAAR,KAAA,UAAA,GAA6BA,CAAC,CAADA,CAAC,CAADA,CAAAA,KAAAA,EAAAA,MAAAA,EAA7B,IAA6BA,CAA7B,GAAyDA,CAAC,CAA9DzB,CAA8D,CAA9DA;AACD;;AARoB,UAAA,WAAA,GAUHY,IAAI,CAAJA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAVG,CAUHA,CAVG;AAAA,UAUdC,GAVc,GAAA,WAAA,CAAA,CAAA,CAAA;AAAA,UAUTiB,EAVS,GAAA,WAAA,CAAA,CAAA,CAAA;;AAYrB,UAAA,GAAA,EAAS;AACPxD,QAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AADF,OAAA,MAEO,IAAIwD,EAAE,KAAFA,SAAAA,IAAoBH,CAAC,IAAzB,KAAA,EAAoC;AACzCpC,QAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,EAAAA;AACD;AACF;;AAED,WAAOjB,QAAQ,CAARA,MAAAA,GAAkB,CAAlBA,QAAkB,CAAlBA,GAA+B,CAAA,SAAA,EAAtC,MAAsC,CAAtC;AArCFgB,GAAAA;;AAwCA,SAAA,MAAA;AA/DK,CAAA;;ACAA,IAAM2C,YAAY,GAAG,SAAfA,YAAe,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK1B5D,EAAAA,SAAS,CACPqB,KAAK,CAALA,OAAAA,CAAAA,MAAAA,KAAyBC,MAAM,CAANA,MAAAA,KADlB,CAAA,EAAA,mFAATtB,MAAS,CAATA;AAKA,MAAM6D,GAAG,GAAG/C,MAAM,CAACQ,MAAM,CAAzB,CAAyB,CAAP,CAAlB;AACA,MAAMwC,KAAK,GAAGhD,MAAM,CAACQ,MAAM,CAA3B,CAA2B,CAAP,CAApB;AACA,MAAML,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,QAAA;AAE1BpB,IAAAA,IAAI,EAAA,YAAYyD,GAAG,CAAf,IAAA,GAAA,GAAA,GAAwBC,KAAK,CAA7B,IAAA,GAFsB,GAAA;AAG1BrC,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;AAKb;AACA;AACA;AACA,QAAM8C,IAAI,GAAG9C,MAAM,CAAnB,OAAaA,EAAb;AACAlD,IAAAA,KAAK,GAAGgG,IAAI,GAAA,cAAA,CAAA,cAAA,CAAA,EAAA,EAAA,IAAA,CAAA,EAAA,KAAA,CAAA,GAAZhG,KAAAA;;AAEA,QAAIE,MAAM,CAANA,KAAM,CAANA,KAAJ,QAAA,EAAgC;AAC9B,aAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAEF,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAD,CAAD,CAAP;AACD;;AAED,QAAMe,MAAM,GAAZ,EAAA;AACA,QAAMjB,QAAQ,GAAd,EAAA;;AAEA,SAAK,IAAL,CAAA,IAAA,KAAA,EAAqB;AACnB,UAAM0B,CAAC,GAAG5D,KAAK,CAAf,CAAe,CAAf;AACA,UAAMwF,CAAC,GAAGpD,IAAI,CAAJA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMqD,CAAC,GAAGnD,MAAM,CAANA,MAAAA,CAAV,CAAUA,CAAV;;AAHmB,UAAA,UAAA,GAIDwD,GAAG,CAAHA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAJC,CAIDA,CAJC;AAAA,UAIZG,GAJY,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,UAIPC,EAJO,GAAA,UAAA,CAAA,CAAA,CAAA;;AAMnB,UAAA,GAAA,EAAS;AACPhE,QAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AADF,OAAA,MAEO;AAAA,YAAA,YAAA,GACa6D,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EADb,CACaA,CADb;AAAA,YACEI,GADF,GAAA,YAAA,CAAA,CAAA,CAAA;AAAA,YACOC,EADP,GAAA,YAAA,CAAA,CAAA,CAAA;;AAGL,YAAA,GAAA,EAAS;AACPlE,UAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AADF,SAAA,MAEO;AACLiB,UAAAA,MAAM,CAANA,EAAM,CAANA,GAAAA,EAAAA;AACD;AACF;AACF;;AAED,WAAOjB,QAAQ,CAARA,MAAAA,GAAkB,CAAlBA,QAAkB,CAAlBA,GAA+B,CAAA,SAAA,EAAtC,MAAsC,CAAtC;AArCFgB,GAAAA;;AAwCA,SAAA,MAAA;AA3DK,CAAA;;ACFA,IAAMmD,YAAY,GAAG,SAAfA,YAAe,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK1BpE,EAAAA,SAAS,CACP,OAAA,MAAA,KADO,QAAA,EAAA,iEAATA,MAAS,CAATA;MAKQnC,KAAAA,GAAUiD,MAAAA,CAAVjD,K;AAERmC,EAAAA,SAAS,CACPsB,MAAM,IADC,KAAA,EAAA,mDAAA,MAAA,GAATtB,KAAS,CAATA;AAKA,MAAMiB,MAAM,GAAGH,MAAM,CAACjD,KAAK,CAAN,MAAM,CAAN,EAArB,QAAqB,CAArB;AACAoD,EAAAA,MAAM,CAANA,IAAAA,GAAAA,QAAAA;AACAA,EAAAA,MAAM,CAANA,IAAAA,GAAAA,MAAAA;AACA,SAAA,MAAA;AApBK,CAAA;;ACDA,IAAMoD,eAAe,GAAG,SAAlBA,eAAkB,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAK7B,MAAIzD,QAAQ,CAAZ,MAAY,CAAZ,EAAsB;AACpB,WAAA,MAAA;AACD;;AAED,MAAIS,KAAK,CAALA,OAAAA,CAAJ,MAAIA,CAAJ,EAA2B;AACzB,QAAIC,MAAM,CAANA,MAAAA,KAAJ,CAAA,EAAyB;AAAA,UAAA,OAAA,GAAA,MAAA;AAAA,UAChBpB,KADgB,GAAA,OAAA,CAAA,CAAA,CAAA;AAEvB,aAAOY,MAAM,CAANA,KAAAA,CAAa,CAAbA,KAAa,CAAbA,EAAP,QAAOA,CAAP;AAFF,KAAA,MAGO,IAAIQ,MAAM,CAANA,MAAAA,GAAJ,CAAA,EAAuB;AAC5B,aAAOR,MAAM,CAANA,KAAAA,CAAAA,MAAAA,EAAP,QAAOA,CAAP;AACD;AACF;;AAED,MAAI,OAAA,MAAA,KAAJ,UAAA,EAAkC;AAChC,WAAOA,MAAM,CAANA,QAAAA,CAAAA,MAAAA,EAAP,QAAOA,CAAP;AACD;;AAED,MAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AAC9B,WAAOA,MAAM,CAANA,MAAAA,CAAAA,MAAAA,EAAP,QAAOA,CAAP;AACD;;AAED,MAAI,OAAA,MAAA,KAAJ,QAAA,EAAgC;AAC9B,QAAIwD,QAAQ,GAAZ,KAAA;AACA,QAAA,MAAA;;AAEA,QAAIhD,MAAM,CAANA,QAAAA,CAAJ,GAAIA,CAAJ,EAA0B;AACxBgD,MAAAA,QAAQ,GAARA,IAAAA;AACAhD,MAAAA,MAAM,GAAGA,MAAM,CAANA,KAAAA,CAAAA,CAAAA,EAAgB,CAAzBA,CAASA,CAATA;AACD;;AAED,QAAIA,MAAM,CAANA,QAAAA,CAAJ,GAAIA,CAAJ,EAA0B;AACxB,UAAMiD,OAAO,GAAGjD,MAAM,CAANA,KAAAA,CAAhB,WAAgBA,CAAhB;AACAL,MAAAA,MAAM,GAAGH,MAAM,CAANA,KAAAA,CAAAA,OAAAA,EAATG,QAASH,CAATG;AAFF,KAAA,MAGO,IAAIK,MAAM,CAANA,QAAAA,CAAJ,GAAIA,CAAJ,EAA0B;AAC/B,UAAMiD,QAAO,GAAGjD,MAAM,CAANA,KAAAA,CAAhB,UAAgBA,CAAhB;;AACAL,MAAAA,MAAM,GAAGH,MAAM,CAANA,YAAAA,CAAAA,QAAAA,EAATG,QAASH,CAATG;AAFK,KAAA,MAGA;AACLA,MAAAA,MAAM,GAAGH,MAAM,CAANA,MAAAA,CAAAA,MAAAA,EAATG,QAASH,CAATG;AACD;;AAED,QAAA,QAAA,EAAc;AACZA,MAAAA,MAAM,GAAGH,MAAM,CAANA,KAAAA,CAAa,CAAA,MAAA,EAAbA,WAAa,CAAbA,EAATG,SAASH,CAATG;AACD;;AAED,WAAA,MAAA;AACD;;AAED,QAAM,IAAA,KAAA,CAAA,uFAAN,MAAM,CAAN;AApDK,CAAA;;ACEA,IAAMuD,WAAW,GAAG,SAAdA,WAAc,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKzBxE,EAAAA,SAAS,CACPqB,KAAK,CAALA,OAAAA,CADO,MACPA,CADO,EAAA,gEAATrB,MAAS,CAATA;AAKA,MAAMyE,QAAQ,GAAG,MAAM,CAAN,GAAA,CAAW,UAAA,CAAA,EAAC;AAAA,WAAI3D,MAAM,CAAV,CAAU,CAAV;AAA7B,GAAiB,CAAjB;AACA,MAAMG,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,OAAA;AAE1BpB,IAAAA,IAAI,EAAA,MAAM,QAAQ,CAAR,GAAA,CAAa,UAAA,CAAA,EAAC;AAAA,aAAIsE,CAAC,CAAL,IAAA;AAAd,KAAA,EAAN,IAAM,EAAN,GAFsB,GAAA;AAG1BjD,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,QAAI,CAACsD,KAAK,CAALA,OAAAA,CAAL,KAAKA,CAAL,EAA2B;AACzB,aAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAEtD,QAAAA,KAAK,EAAP,KAAA;AAASsC,QAAAA,MAAM,EAAf,MAAA;AAAiBF,QAAAA,IAAI,EAAJA;AAAjB,OAAZ,CAAD,CAAD,CAAP;AACD;;AAED,QAAMe,MAAM,GAAZ,EAAA;AACA,QAAMjB,QAAQ,GAAd,EAAA;AACA,QAAM0E,MAAM,GAAGC,IAAI,CAAJA,GAAAA,CAAS7G,KAAK,CAAd6G,MAAAA,EAAuBH,QAAQ,CAA9C,MAAeG,CAAf;;AAEA,SAAK,IAAIlD,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,MAAA,EAA4BA,CAA5B,EAAA,EAAiC;AAC/B,UAAMH,OAAO,GAAGkD,QAAQ,CAAxB,CAAwB,CAAxB;AACA,UAAM9C,CAAC,GAAG5D,KAAK,CAAf,CAAe,CAAf;AACA,UAAMwF,CAAC,GAAGpD,IAAI,CAAJA,MAAAA,CAAV,CAAUA,CAAV;AACA,UAAMqD,CAAC,GAAGnD,MAAM,CAANA,MAAAA,CAAV,CAAUA,CAAV;;AAEA,UAAI,CAAJ,OAAA,EAAc;AACZJ,QAAAA,QAAQ,CAARA,IAAAA,CACE,MAAM,CAAN,IAAA,CAAY;AAAEG,UAAAA,IAAI,EAAN,SAAA;AAAmBrC,UAAAA,KAAK,EAAxB,CAAA;AAA6BoC,UAAAA,IAAI,EAAjC,CAAA;AAAsCE,UAAAA,MAAM,EAAEmD;AAA9C,SAAZ,CADFvD;AADF,OAAA,MAIO;AAAA,YAAA,cAAA,GACasB,OAAO,CAAPA,KAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EADb,CACaA,CADb;AAAA,YACEK,GADF,GAAA,cAAA,CAAA,CAAA,CAAA;AAAA,YACOC,EADP,GAAA,cAAA,CAAA,CAAA,CAAA;;AAGL,YAAA,GAAA,EAAS;AACP5B,UAAAA,QAAQ,CAARA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,GAAAA;AADF,SAAA,MAEO;AACLiB,UAAAA,MAAM,CAANA,CAAM,CAANA,GAAAA,EAAAA;AACD;AACF;AACF;;AAED,WAAOjB,QAAQ,CAARA,MAAAA,GAAkB,CAAlBA,QAAkB,CAAlBA,GAA+B,CAAA,SAAA,EAAtC,MAAsC,CAAtC;AAlCFgB,GAAAA;;AAqCA,SAAA,MAAA;AAvDK,CAAA;;ACAA,IAAM4D,WAAW,GAAG,SAAdA,WAAc,CAAA,MAAA,EAAA,QAAA,EAAA,MAAA,EAAA;AAKzB7E,EAAAA,SAAS,CACPqB,KAAK,CAALA,OAAAA,CAAAA,MAAAA,KAAyBC,MAAM,CAANA,MAAAA,KADlB,CAAA,EAAA,yEAATtB,MAAS,CAATA;AAKA,MAAM0C,OAAO,GAAG,MAAM,CAAN,GAAA,CAAW,UAAA,GAAA,EAAG;AAAA,WAAI5B,MAAM,CAAV,GAAU,CAAV;AAA9B,GAAgB,CAAhB;AACA,MAAMV,IAAI,GAAG,OAAO,CAAP,GAAA,CAAY,UAAA,CAAA,EAAC;AAAA,WAAIuC,CAAC,CAAL,IAAA;AAAb,GAAA,EAAA,IAAA,CAAb,KAAa,CAAb;AACA,MAAM1B,MAAM,GAAGJ,YAAY,CAAC;AAC1BW,IAAAA,IAAI,EADsB,OAAA;AAE1BpB,IAAAA,IAAI,EAFsB,IAAA;AAG1BqB,IAAAA,QAAQ,EAHkB,QAAA;AAI1BX,IAAAA,MAAM,EAANA;AAJ0B,GAAD,CAA3B;;AAOAG,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,KAAA,EAAA,MAAA,EAAA,IAAA,EAAA;QACblD,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAakD,MAAM,CAANA,OAAAA,EAAblD;;;AAIA,SAAA,IAAA,SAAA,GAAA,+BAAA,CAAA,OAAA,CAAA,EAAA,KAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAA8B;AAAA,UAAnB+C,OAAmB,GAAA,KAAA,CAAA,KAAA;;AAAA,UAAA,aAAA,GACZA,OAAM,CAANA,KAAAA,CAAAA,KAAAA,EAAAA,MAAAA,EADY,IACZA,CADY;AAAA,UACrB8B,EADqB,GAAA,aAAA,CAAA,CAAA,CAAA;AAAA,UACjBjB,CADiB,GAAA,aAAA,CAAA,CAAA,CAAA;;AAG5B,UAAI,CAAJ,EAAA,EAAS;AACP,eAAO,CAAA,SAAA,EAAP,CAAO,CAAP;AACD;AACF;;AAED,WAAO,CAAC,CAAC,MAAM,CAAN,IAAA,CAAY;AAAE5D,MAAAA,KAAK,EAAP,KAAA;AAASsC,MAAAA,MAAM,EAAf,MAAA;AAAiBF,MAAAA,IAAI,EAAJA;AAAjB,KAAZ,CAAD,CAAD,CAAP;AAbFc,GAAAA;;AAgBA,SAAA,MAAA;AAnCK,CAAA;AC6BP;;;;;;AAKA,IAAa6D,WAAW,GAAG,SAAdA,WAAc,CAAA,QAAA,EAAA;MACzBC,QAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,IAAAA,QAAAA,GAAyC,EAAzCA;;;AAEA,MAAMjE,MAAM,GAAG,SAATA,MAAS,CAAA,MAAA,EAAA,QAAA,EAAA;AACb,WAAOuD,eAAe,CAAA,MAAA,EAAA,QAAA,EAAtB,MAAsB,CAAtB;AADF,GAAA;;AAIAvD,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,MAAA,EAAA,QAAA,EAAA;AACb,WAAOM,WAAW,CAAA,MAAA,EAAA,QAAA,EAAlB,MAAkB,CAAlB;AADFN,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,OAAAA,GAAiB,UAAA,MAAA,EAAA,QAAA,EAAA;AAIf,WAAOgB,aAAa,CAAA,MAAA,EAAA,QAAA,EAApB,MAAoB,CAApB;AAJFhB,GAAAA;;AAOAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,UAAA,MAAA,EAAA,QAAA,EAAA;AACZ,WAAOkB,UAAU,CAAA,MAAA,EAAA,QAAA,EAAjB,MAAiB,CAAjB;AADFlB,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,QAAAA,GAAkB,UAAA,MAAA,EAAA,QAAA,EAAA;AAChB,WAAOoB,cAAc,CAAA,MAAA,EAAA,QAAA,EAArB,MAAqB,CAArB;AADFpB,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,QAAAA,GAAkB,UAAA,MAAA,EAAA,QAAA,EAAA;AAChB,WAAOsB,cAAc,CAAA,MAAA,EAAA,QAAA,EAArB,MAAqB,CAArB;AADFtB,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,SAAAA,GAAmB,UAAA,MAAA,EAAA,QAAA,EAAA;AACjB,WAAOuB,eAAe,CAAA,MAAA,EAAA,QAAA,EAAtB,MAAsB,CAAtB;AADFvB,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,YAAAA,GAAsB,UAAA,MAAA,EAAA,QAAA,EAAA;AACpB,WAAO2B,kBAAkB,CAAA,MAAA,EAAA,QAAA,EAAzB,MAAyB,CAAzB;AADF3B,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,UAAA,MAAA,EAAA,QAAA,EAAA;AACZ,WAAO+B,UAAU,CAAA,MAAA,EAAA,QAAA,EAAjB,MAAiB,CAAjB;AADF/B,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,OAAAA,GAAiB,UAAA,MAAA,EAAA,QAAA,EAAA;AACf,WAAOoC,aAAa,CAAA,MAAA,EAAA,QAAA,EAApB,MAAoB,CAApB;AADFpC,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,MAAAA,GAAgB,UAAA,MAAA,EAAA,QAAA,EAAA;AACd,WAAOqC,YAAY,CAAA,MAAA,EAAA,QAAA,EAAnB,MAAmB,CAAnB;AADFrC,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,QAAAA,GAAkB,UAAA,MAAA,EAAA,QAAA,EAAA;AAChB,WAAO+D,WAAW,CAAC,CAAA,MAAA,EAAD,WAAC,CAAD,EAAA,QAAA,EAAlB,MAAkB,CAAlB;AADF/D,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,OAAAA,GAAiB,UAAA,MAAA,EAAA,QAAA,EAAA;AACf,WAAO4C,aAAa,CAAA,MAAA,EAAA,QAAA,EAApB,MAAoB,CAApB;AADF5C,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,UAAA,MAAA,EAAA,QAAA,EAAA;AACZ,WAAO6C,UAAU,CAAA,MAAA,EAAA,QAAA,EAAjB,MAAiB,CAAjB;AADF7C,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,MAAAA,GAAgB,UAAA,MAAA,EAAA,QAAA,EAAA;AACd,WAAO8C,YAAY,CAAA,MAAA,EAAA,QAAA,EAAnB,MAAmB,CAAnB;AADF9C,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,MAAAA,GAAgB,UAAA,MAAA,EAAA,QAAA,EAAA;AACd,WAAOsD,YAAY,CAAA,MAAA,EAAA,QAAA,EAAnB,MAAmB,CAAnB;AADFtD,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,IAAAA,GAAc,UAAA,MAAA,EAAA,QAAA,EAAA;AACZ,WAAOiC,UAAU,CAAA,MAAA,EAAA,QAAA,EAAjB,MAAiB,CAAjB;AADFjC,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,MAAA,EAAA,QAAA,EAAA;AACb,WAAO0D,WAAW,CAAA,MAAA,EAAA,QAAA,EAAlB,MAAkB,CAAlB;AADF1D,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,KAAAA,GAAe,UAAA,MAAA,EAAA,QAAA,EAAA;AACb,WAAO+D,WAAW,CAAA,MAAA,EAAA,QAAA,EAAlB,MAAkB,CAAlB;AADF/D,GAAAA;;AAIAA,EAAAA,MAAM,CAANA,KAAAA,GAAeiE,QAAQ,CAARA,KAAAA,IAAfjE,WAAAA;AACAA,EAAAA,MAAM,CAANA,KAAAA,GAAAA,cAAAA,CAAAA,cAAAA,CAAAA,EAAAA,EAAAA,KAAAA,CAAAA,EAAqCiE,QAAQ,CAA7CjE,KAAAA,CAAAA;AACA,SAAA,MAAA;AApFK,CAAP;ACpCA;;;;;;;;;;AASA,IAAMA,MAAM,GAAGgE,WAAf,EAAA","sourcesContent":["var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","import kindOf from 'kind-of'\nimport { Branch, Path, Failure } from './struct-error'\n\n/**\n * Superstruct ships by default with an unopinionated set of scalar types that\n * express all of the data types that are built-in to JavaScript.\n */\n\nexport const Types = {\n  /**\n   * Matches any value other than `undefined`.\n   *\n   * ```js\n   * 'anything'\n   * true\n   * ```\n   */\n\n  any: (value: any) => value !== undefined,\n\n  /**\n   * Matches an `arguments` object.\n   *\n   * ```js\n   * arguments\n   * ```\n   */\n\n  arguments: (value: any) => kindOf(value) === 'arguments',\n\n  /**\n   * Matches an `Array`.\n   *\n   * ```js\n   * [1, 2, 3]\n   * ```\n   */\n\n  array: (value: any) => kindOf(value) === 'array',\n\n  /**\n   * Matches a boolean.\n   *\n   * ```js\n   * true\n   * false\n   * ```\n   */\n\n  boolean: (value: any) => kindOf(value) === 'boolean',\n\n  /**\n   * Matches a Node.js `Buffer`.\n   *\n   * ```js\n   * Buffer.from('string')\n   * ```\n   */\n\n  buffer: (value: any) => kindOf(value) === 'buffer',\n\n  /**\n   * Matches a **valid** `Date` object.\n   *\n   * ```js\n   * new Date()\n   * ```\n   *\n   * Note: Invalid `Date` objects that equal `NaN` are not matched.\n   */\n\n  date: (value: any) => kindOf(value) === 'date' && !isNaN(value),\n\n  /**\n   * Matches an error object.\n   *\n   * ```js\n   * new Error()\n   * ```\n   */\n\n  error: (value: any) => kindOf(value) === 'error',\n\n  /**\n   * Matches a `Float32Array` object.\n   */\n\n  float32array: (value: any) => kindOf(value) === 'float32array',\n\n  /**\n   * Matches a `Float64Array` object.\n   */\n\n  float64array: (value: any) => kindOf(value) === 'float64array',\n\n  /**\n   * Matches a function.\n   *\n   * ```js\n   * () => {}\n   * function () {}\n   * ```\n   */\n\n  function: (value: any) => kindOf(value) === 'function',\n\n  /**\n   * Matches a generator function.\n   *\n   * ```js\n   * function* () {}\n   * ```\n   */\n\n  generatorfunction: (value: any) => kindOf(value) === 'generatorfunction',\n\n  /**\n   * Matches a `Int16Array` object.\n   */\n\n  int16array: (value: any) => kindOf(value) === 'int16array',\n\n  /**\n   * Matches a `Int32Array` object.\n   */\n\n  int32array: (value: any) => kindOf(value) === 'int32array',\n\n  /**\n   * Matches a `Int8Array` object.\n   */\n\n  int8array: (value: any) => kindOf(value) === 'int8array',\n\n  /**\n   * Matches a `Map` object.\n   *\n   * ```js\n   * new Map()\n   * ```\n   */\n\n  map: (value: any) => kindOf(value) === 'map',\n\n  /**\n   * Matches the `null` literal value.\n   *\n   * ```js\n   * null\n   * ```\n   */\n\n  null: (value: any) => kindOf(value) === 'null',\n\n  /**\n   * Matches a number.\n   *\n   * ```js\n   * 42\n   * ```\n   */\n\n  number: (value: any) => kindOf(value) === 'number',\n\n  /**\n   * Matches a plain object.\n   *\n   * ```js\n   * { key: 'value' }\n   * { something: true }\n   * ```\n   */\n\n  object: (value: any) => kindOf(value) === 'object',\n\n  /**\n   * Matches a `Promise` object.\n   *\n   * ```js\n   * Promise.resolve()\n   * ```\n   */\n\n  promise: (value: any) => kindOf(value) === 'promise',\n\n  /**\n   * Matches a regular expression object.\n   *\n   * ```js\n   * /a-z/g\n   * ```\n   */\n\n  regexp: (value: any) => kindOf(value) === 'regexp',\n\n  /**\n   * Matches a `Set` object.\n   *\n   * ```js\n   * new Set()\n   * ```\n   */\n\n  set: (value: any) => kindOf(value) === 'set',\n\n  /**\n   * Matches a string.\n   *\n   * ```js\n   * 'text'\n   * ```\n   */\n\n  string: (value: any) => kindOf(value) === 'string',\n\n  /**\n   * Matches a `Symbol`.\n   *\n   * ```js\n   * Symbol()\n   * ```\n   */\n\n  symbol: (value: any) => kindOf(value) === 'symbol',\n\n  /**\n   * Matches a `Uint16Array` object.\n   */\n\n  uint16array: (value: any) => kindOf(value) === 'uint16array',\n\n  /**\n   * Matches a `Uint32Array` object.\n   */\n\n  uint32array: (value: any) => kindOf(value) === 'uint32array',\n\n  /**\n   * Matches a `Uint8Array` object.\n   */\n\n  uint8array: (value: any) => kindOf(value) === 'uint8array',\n\n  /**\n   * Matches a `Uint8ClampedArray` object.\n   */\n\n  uint8clampedarray: (value: any) => kindOf(value) === 'uint8clampedarray',\n\n  /**\n   * Matches the `undefined` literal value.\n   *\n   * ```js\n   * undefined\n   * ```\n   */\n\n  undefined: (value: any) => kindOf(value) === 'undefined',\n\n  /**\n   * Matches a `WeakMap` object.\n   *\n   * ```js\n   * new WeakMap()\n   * ```\n   */\n\n  weakmap: (value: any) => kindOf(value) === 'weakmap',\n\n  /**\n   * Matches a `WeakSet` object.\n   *\n   * ```js\n   * new WeakSet()\n   * ```\n   */\n\n  weakset: (value: any) => kindOf(value) === 'weakset',\n}\n\n/**\n * `Validator` functions allow developers to define their own scalar types for\n * Superstruct to validate against, and return an indication of what is invalid.\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *   }\n * })\n * ```\n */\n\nexport type Validator = (\n  value: any,\n  branch: Branch,\n  path: Path\n) => Partial<Failure>[] | Partial<Failure> | boolean\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nexport default invariant;\n","import invariant from 'tiny-invariant'\n\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nexport class StructError extends TypeError {\n  branch: Branch\n  failures: Failure[]\n  path: Path\n  type: string | undefined\n  value: any\n  [key: string]: any\n\n  constructor(failures: Failure[]) {\n    invariant(\n      failures.length > 0,\n      `StructError requires being passed a failure, but received: ${failures}`\n    )\n\n    const [first] = failures\n    const { path, value, type, branch, ...rest } = first\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n\n    super(message)\n    this.type = type\n    this.value = value\n    Object.assign(this, rest)\n    this.path = path\n    this.branch = branch\n    this.failures = failures\n    this.stack = new Error().stack\n    ;(this as any).__proto__ = StructError.prototype\n  }\n}\n\n/**\n * `Path` arrays specify a nested value's location in a root object or array.\n *\n * ```js\n * ['user', 'address', 'city']\n * ['nodes', 1, 'nodes', 0, 'text']\n * ```\n */\n\nexport type Path = Array<number | string>\n\n/**\n * `Branch` arrays contain each value following a path down from the root.\n *\n * ```js\n * [root, ..., parent, value]\n * ```\n */\n\nexport type Branch = Array<any>\n\n/**\n * `Failure` objects represent a specific failure in validation. They are plain\n * objects that can be turned into real `StructError` when needed.\n *\n * ```js\n * {\n *   type: 'number',\n *   value: 'invalid',\n *   path: [1],\n *   branch: [\n *     [1, 'invalid', 2],\n *     'invalid',\n *   ]\n * }\n */\n\nexport type Failure = {\n  /**\n   * The branch of values following a path down from the root.\n   */\n\n  branch: Branch\n\n  /**\n   * The path of indices to retrieve the failing value from the root.\n   */\n\n  path: Path\n\n  /**\n   * The failing value.\n   */\n\n  value: any\n\n  /**\n   * The expected type description of the failing value, or `undefined` if it\n   * didn't have an expected type.\n   */\n\n  type: string | undefined\n\n  /**\n   * Failures can also be augmented with any of your on custom properties.\n   */\n\n  [key: string]: any\n}\n","import { Failure, Branch, Path } from './struct-error'\nimport { Superstruct } from './superstruct'\n\n/**\n * A symbol to set on `Struct` objects to test them against later.\n */\n\nexport const STRUCT = Symbol('STRUCT')\n\n/**\n * Check if a value is a `Struct` object.\n */\n\nexport const isStruct = (value: any): value is Struct => {\n  return typeof value === 'function' && value[STRUCT]\n}\n\n/**\n * This abstract `Struct` factory creates a generic struct that validates values\n * against a `Validator` function.\n */\n\nexport const createStruct = (props: {\n  kind: string\n  type: string\n  defaults: () => any\n  struct: Superstruct\n}): Struct => {\n  const { struct } = props\n  const { Error } = struct\n  const Struct = (value: any): any => Struct.assert(value)\n\n  // Set a hidden symbol property so that we can check it later to see if an\n  // object is a struct object.\n  Object.defineProperty(Struct, STRUCT, { value: true })\n\n  Struct.kind = props.kind\n  Struct.type = props.type\n\n  Struct.default = () => {\n    return typeof props.defaults === 'function'\n      ? props.defaults()\n      : props.defaults\n  }\n\n  Struct.test = (value: any): boolean => {\n    const [failures] = Struct.check(value, [value], [])\n    return !failures\n  }\n\n  Struct.assert = (value: any): any => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      throw new Error(failures)\n    } else {\n      return result\n    }\n  }\n\n  Struct.validate = (value: any): [Error?, any?] => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      return [new Error(failures)]\n    } else {\n      return [undefined, result]\n    }\n  }\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const failures = [Struct.fail({ value, branch, path })]\n    return [failures]\n  }\n\n  Struct.fail = (obj: {\n    value: any\n    branch: Branch\n    path: Path\n    type?: string\n  }): Failure => {\n    return { ...obj, type: 'type' in obj ? obj.type : Struct.type }\n  }\n\n  return Struct\n}\n\n/**\n * `Struct` validators encapsulate the validation logic for a specific type of\n * data (either custom or built-in). They have a set of methods that allow you\n * to validate input in various ways, while producing detailed errors.\n *\n * They are created by the [[Superstruct]] factory functions. You can call them\n * directly for the simple case, or use one of their validation methods.\n *\n * ```js\n * const Struct = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n *\n * const result = Struct(data) // Throws if invalid!\n *\n * const [error, result] = Struct.validate(data)\n *\n * if (Struct.test(data)) {\n *    // ...\n * }\n * ```\n */\n\nexport interface Struct {\n  /**\n   * All structs are functions that are shorthand for calling [[Struct.assert]].\n   */\n\n  (value: any): any\n\n  /**\n   * The struct's name.\n   *\n   * ```js\n   * 'object'\n   * 'union'\n   * 'email'\n   * ```\n   */\n\n  kind: string\n\n  /**\n   * A string representing the type of the struct. These strings are purely for\n   * user-facing error messages, and aren't canonical. They are similar to the\n   * syntax that TypeScript uses.\n   *\n   * ```js\n   * '{id,name,email}'\n   * 'string | number'\n   * 'email'\n   * ```\n   */\n\n  type: string\n\n  /**\n   * Get the default value for a struct.\n   *\n   * ```js\n   * const defaults = Struct.default()\n   * ```\n   */\n\n  default(): any\n\n  /**\n   * Run the low-level validation function a struct, returning a tuple that\n   * contains either a list of [[Failure]] objects, or a resulting value.\n   *\n   * This method is fairly low-level and not for normal use.\n   *\n   * ```js\n   * const [failures, result] = Struct.check(value, branch, path)\n   * ```\n   */\n\n  check(value: any, branch: Branch, path: Path): [Failure[]?, any?]\n\n  /**\n   * Validate a `value`, returning the resulting value, and throwing an error if\n   * validation fails.\n   *\n   * ```js\n   * try {\n   *   const result = Struct.assert(value)\n   *   // ...\n   * } catch (e) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  assert(value: any): any\n\n  /**\n   * Validate a `value`, returning a boolean indicating whether it's valid.\n   *\n   * Note: Using this method does not give you access to the defaults that may\n   * be associated with a struct, so it doesn't guarantee that the value you\n   * have passes, just that the value with defaults passes.\n   *\n   * ```js\n   * if (Struct.test(value)) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  test(value: any): boolean\n\n  /**\n   * Validate a `value` returning a tuple containing an error if the validation\n   * fails, or the resulting value if it succeeds.\n   *\n   * ```js\n   * const [error, result] = Struct.validate(value)\n   * ```\n   */\n\n  validate(value: any): [Error?, any?]\n\n  /**\n   * Create a low-level [[Failure]] object for the struct.\n   *\n   * ```js\n   * const failure = Struct.fail({ value, branch, path })\n   * ```\n   */\n\n  fail(obj: { value: any; branch: Branch; path: Path; type?: string }): Failure\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createArray = (\n  schema: [any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 1,\n    `Array structs must be defined as an array with one element, but you passed: ${schema}`\n  )\n\n  const Element = struct(schema[0], undefined)\n  const Struct = createStruct({\n    kind: 'array',\n    type: `${Element.type}[]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [efs, er] = Element.check(v, branch.concat(v), path.concat(i))\n\n      if (efs) {\n        failures.push(...efs)\n        continue\n      }\n\n      result[i] = er\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createDynamic = (\n  schema: (value: any, branch: Branch, path: Path) => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Dynamic structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Dynamic = createStruct({\n    kind: 'dynamic',\n    type: `dynamic<>`,\n    defaults,\n    struct,\n  })\n\n  Dynamic.check = (\n    value: any = Dynamic.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const Struct = schema(value, branch, path)\n    return Struct.check(value, branch, path)\n  }\n\n  return Dynamic\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createEnum = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Enum structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => schema.includes(value)\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'enum'\n  Struct.type = schema\n    .map(s => (typeof s === 'string' ? `\"${s}\"` : `${s}`))\n    .join(' | ')\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct, Validator } from '..'\nimport { createStruct } from '../struct'\n\nexport const createFunction = (\n  schema: Validator,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const Struct = createStruct({\n    kind: 'function',\n    type: `function<>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const result = schema(value, branch, path)\n\n    if (result === true) {\n      return [undefined, value]\n    }\n\n    const failures: Failure[] = []\n\n    if (result === false) {\n      failures.push(Struct.fail({ value, branch, path }))\n    } else if (Array.isArray(result) && result.length > 0) {\n      for (const r of result) {\n        failures.push(Struct.fail({ value, branch, path, ...r }))\n      }\n    } else if (typeof result === 'object') {\n      failures.push(Struct.fail({ value, branch, path, ...result }))\n    } else {\n      invariant(\n        false,\n        `Validator functions must return a boolean, a failure object, or an array of failure objects, but you passed: ${result}`\n      )\n    }\n\n    return [failures]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createInstance = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Instance structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => value instanceof schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'instance'\n  Struct.type = `instance<${schema.name}>`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createInterface = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Interface structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'interface',\n    type: `interface<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      const Prop = Props[k]\n      const v = value[k]\n      const [pfs] = Prop.check(v, branch.concat(v), path.concat(k))\n\n      if (pfs) {\n        failures.push(...pfs)\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, value]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createIntersection = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Intersection structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' & ')\n  const Struct = createStruct({\n    kind: 'intersection',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    let result: any = value\n\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (fs) {\n        return [[Struct.fail({ value, branch, path })]]\n      } else {\n        result = v\n      }\n    }\n\n    return [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Failure, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createLazy = (\n  schema: () => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Lazy structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Lazy = createStruct({\n    kind: 'lazy',\n    type: `lazy<>`,\n    defaults,\n    struct,\n  })\n\n  Lazy.check = (...args): [Failure[]?, any?] => {\n    Object.assign(Lazy, schema())\n    return Lazy.check(...args)\n  }\n\n  return Lazy\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createSize = (\n  schema: [number, number],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) &&\n      schema.length === 2 &&\n      schema.every(n => typeof n === 'number'),\n    `Size structs must be defined as an array with two number elements, but you passed: ${schema}`\n  )\n\n  const [min, max] = schema\n  const validator = (value: any) =>\n    value != null &&\n    typeof value.length === 'number' &&\n    value.length >= min &&\n    value.length <= max\n\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'size'\n  Struct.type = `size<${min},${max}>`\n  return Struct\n}\n","import { Struct, Superstruct } from '..'\n\nexport const createLiteral = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const validator = (value: any) => value === schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'literal'\n  Struct.type = typeof schema === 'string' ? `\"${schema}\"` : `${schema}`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createObject = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Object structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n    const keys = new Set(Object.keys(Props).concat(Object.keys(value)))\n\n    for (const k of keys) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPartial = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Partial structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct.union([schema[key], 'undefined'])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k of value) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPick = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Pick structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'pick',\n    type: `pick<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createRecord = (\n  schema: [any, any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 2,\n    `Record structs must be defined as an array with two elements, but you passed: ${schema}`\n  )\n\n  const Key = struct(schema[0])\n  const Value = struct(schema[1])\n  const Struct = createStruct({\n    kind: 'record',\n    type: `record<${Key.type},${Value.type}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any,\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    // Record structs have a special default handling behavior, where the defaults\n    // are for the entries themselves, not for the entire value. So we can't use\n    // JavaScript's built-in default handling here.\n    const defs = Struct.default()\n    value = defs ? { ...defs, ...value } : value\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (let k in value) {\n      const v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const [kfs, kr] = Key.check(k, b, p)\n\n      if (kfs) {\n        failures.push(...kfs)\n      } else {\n        const [vfs, vr] = Value.check(v, b, p)\n\n        if (vfs) {\n          failures.push(...vfs)\n        } else {\n          result[kr] = vr\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createScalar = (\n  schema: string,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'string',\n    `Scalar structs must be defined as a string, but you passed: ${schema}`\n  )\n\n  const { Types } = struct\n\n  invariant(\n    schema in Types,\n    `No struct validator function found for type \"${schema}\".`\n  )\n\n  const Struct = struct(Types[schema], defaults)\n  Struct.kind = 'scalar'\n  Struct.type = schema\n  return Struct\n}\n","import { isStruct, Struct, Superstruct } from '..'\n\nexport const createShorthand = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  if (isStruct(schema)) {\n    return schema\n  }\n\n  if (Array.isArray(schema)) {\n    if (schema.length === 1) {\n      const [first] = schema\n      return struct.array([first], defaults)\n    } else if (schema.length > 1) {\n      return struct.tuple(schema, defaults)\n    }\n  }\n\n  if (typeof schema === 'function') {\n    return struct.function(schema, defaults)\n  }\n\n  if (typeof schema === 'object') {\n    return struct.object(schema, defaults)\n  }\n\n  if (typeof schema === 'string') {\n    let optional = false\n    let Struct\n\n    if (schema.endsWith('?')) {\n      optional = true\n      schema = schema.slice(0, -1)\n    }\n\n    if (schema.includes('|')) {\n      const scalars = schema.split(/\\s*\\|\\s*/g)\n      Struct = struct.union(scalars, defaults)\n    } else if (schema.includes('&')) {\n      const scalars = schema.split(/\\s*&\\s*/g)\n      Struct = struct.intersection(scalars, defaults)\n    } else {\n      Struct = struct.scalar(schema, defaults)\n    }\n\n    if (optional) {\n      Struct = struct.union([Struct, 'undefined'], undefined)\n    }\n\n    return Struct\n  }\n\n  throw new Error(\n    `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n  )\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createTuple = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Tuple structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const Elements = schema.map(s => struct(s))\n  const Struct = createStruct({\n    kind: 'tuple',\n    type: `[${Elements.map(S => S.type).join()}]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n    const length = Math.max(value.length, Elements.length)\n\n    for (let i = 0; i < length; i++) {\n      const Element = Elements[i]\n      const v = value[i]\n      const p = path.concat(i)\n      const b = branch.concat(v)\n\n      if (!Element) {\n        failures.push(\n          Struct.fail({ type: undefined, value: v, path: p, branch: b })\n        )\n      } else {\n        const [efs, er] = Element.check(v, b, p)\n\n        if (efs) {\n          failures.push(...efs)\n        } else {\n          result[i] = er\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { createStruct } from '../struct'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\n\nexport const createUnion = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Union structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' | ')\n  const Struct = createStruct({\n    kind: 'union',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (!fs) {\n        return [undefined, v]\n      }\n    }\n\n    return [[Struct.fail({ value, branch, path })]]\n  }\n\n  return Struct\n}\n","import { Validator, Types as BuiltinTypes } from './types'\nimport { Branch, Failure, Path, StructError } from './struct-error'\nimport { Struct } from './struct'\nimport {\n  createArray,\n  createDynamic,\n  createEnum,\n  createFunction,\n  createInstance,\n  createInterface,\n  createIntersection,\n  createLazy,\n  createLiteral,\n  createObject,\n  createPartial,\n  createPick,\n  createRecord,\n  createScalar,\n  createShorthand,\n  createSize,\n  createTuple,\n  createUnion,\n} from './structs'\n\n/**\n * `SuperstructSettings` are passed in when creating a `Superstruct` factory.\n */\n\nexport type SuperstructSettings = {\n  types: Record<string, Validator>\n  error: { new (failures: Failure[]): Error }\n}\n\n/**\n * Create a struct singleton with settings that include your own domain-specific\n * data `types`, and an optional custom `Error` class.\n */\n\nexport const superstruct = (\n  settings: Partial<SuperstructSettings> = {}\n): Superstruct => {\n  const struct = (schema: any, defaults?: any): Struct => {\n    return createShorthand(schema, defaults, struct)\n  }\n\n  struct.array = (schema: [any], defaults?: any): Struct => {\n    return createArray(schema, defaults, struct)\n  }\n\n  struct.dynamic = (\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct => {\n    return createDynamic(schema, defaults, struct)\n  }\n\n  struct.enum = (schema: any[], defaults?: any): Struct => {\n    return createEnum(schema, defaults, struct)\n  }\n\n  struct.function = (schema: Validator, defaults?: any): Struct => {\n    return createFunction(schema, defaults, struct)\n  }\n\n  struct.instance = (schema: any, defaults?: any): Struct => {\n    return createInstance(schema, defaults, struct)\n  }\n\n  struct.interface = (schema: any, defaults?: any): Struct => {\n    return createInterface(schema, defaults, struct)\n  }\n\n  struct.intersection = (schema: any[], defaults?: any): Struct => {\n    return createIntersection(schema, defaults, struct)\n  }\n\n  struct.lazy = (schema: () => Struct, defaults?: any): Struct => {\n    return createLazy(schema, defaults, struct)\n  }\n\n  struct.literal = (schema: any, defaults?: any): Struct => {\n    return createLiteral(schema, defaults, struct)\n  }\n\n  struct.object = (schema: {}, defaults?: any): Struct => {\n    return createObject(schema, defaults, struct)\n  }\n\n  struct.optional = (schema: any, defaults?: any): Struct => {\n    return createUnion([schema, 'undefined'], defaults, struct)\n  }\n\n  struct.partial = (schema: {}, defaults?: any): Struct => {\n    return createPartial(schema, defaults, struct)\n  }\n\n  struct.pick = (schema: {}, defaults?: any): Struct => {\n    return createPick(schema, defaults, struct)\n  }\n\n  struct.record = (schema: [any, any], defaults?: any): Struct => {\n    return createRecord(schema, defaults, struct)\n  }\n\n  struct.scalar = (schema: string, defaults?: any): Struct => {\n    return createScalar(schema, defaults, struct)\n  }\n\n  struct.size = (schema: [number, number], defaults?: any): Struct => {\n    return createSize(schema, defaults, struct)\n  }\n\n  struct.tuple = (schema: any[], defaults?: any): Struct => {\n    return createTuple(schema, defaults, struct)\n  }\n\n  struct.union = (schema: any[], defaults?: any): Struct => {\n    return createUnion(schema, defaults, struct)\n  }\n\n  struct.Error = settings.error || StructError\n  struct.Types = { ...BuiltinTypes, ...settings.types }\n  return struct\n}\n\n/**\n * `Superstruct` factories create different kinds of [[Struct]] validators, and\n * encapsulate the user-defined data types.\n *\n * The [[struct]] export is a factory that ships with Superstruct by default,\n * pre-configured with all of the built-in JavaScript data types. It's the\n * easiest way to quickly define structs:\n *\n * ```js\n * import { struct } from 'superstruct'\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n * ```\n *\n * If you need to define custom data types, you can define your own by using\n * the [[superstruct]] export:\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n * import isUrl from 'is-url'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *     url: value => isUrl(value) && value.length < 2048,\n *   }\n * })\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n *   email: 'email',\n *   website: 'url?',\n * })\n * ```\n *\n * This way you can easily define structs that contain types like `'email'`,\n * `'url'`, or whatever else your application may need.\n */\n\nexport interface Superstruct {\n  /**\n   * Structs are defined by passing a schema definition to the struct factory.\n   * The schema definition can be a string, array, object or function. They can\n   * also be composed by nesting structs inside each other.\n   *\n   * The default struct factory allows you to write structs using a shorthand\n   * syntax for the most common casesarrays, objects, scalars, tuples, etc.\n   *\n   * ```js\n   * struct('string') // Scalars\n   * struct(['number']) // Arrays\n   * struct({ name: 'string' }) // Objects\n   * struct(['error', 'string']) // Tuples\n   * struct('number?') // Optional\n   * struct('string & email') // Intersection\n   * struct('number | string') // Union\n   * struct(value => true || false) // Function\n   * struct(Struct) // Pass-through\n   * ```\n   *\n   * Each shorthand is equivalent to a method on the [[Superstruct]] factory:\n   *\n   * ```js\n   * // These are equivalent...\n   * struct(['number'])\n   * struct.array(['number'])\n   *\n   * struct('string & email')\n   * struct.union(['string', 'email'])\n   * ```\n   *\n   * And each one can use your custom types, or even other structs:\n   *\n   * ```js\n   * struct('email')\n   * struct(User)\n   * ```\n   *\n   * The second argument to struct factories is always a `defaults` value. It\n   * can either be the default itself or a function that returns the default.\n   *\n   * ```js\n   * struct('id', uuid.v4)\n   *\n   * struct({\n   *   id: 'number',\n   *   name: 'string',\n   *   is_admin: 'boolean?',\n   * }, {\n   *   is_admin: false,\n   * })\n   * ```\n   */\n\n  (schema: any, defaults?: any): Struct\n\n  /**\n   * Array structs validate that their input is an array with elements that\n   * match a specific struct. You can also pass the `max` or `min` options to\n   * validate the length of the array.\n   *\n   * ```js\n   * const Struct = struct.array(['number'])\n   *\n   * Struct([1, 2, 3])\n   * ```\n   *\n   * They are similar to the `Array` type in TypeScript.\n   */\n\n  array(schema: [any], defaults?: any): Struct\n\n  /**\n   * Dynamic structs are defined by a function that is passed the value being\n   * validated, and they determine which struct to use at runtime.\n   *\n   * ```js\n   * const Struct = struct.dynamic(value => StructA || StructB)\n   * ```\n   *\n   * They are inhernetly less performant that compile-time structs, but they\n   * unlock a set of possibilities that aren't possible at compile time alone.\n   */\n\n  dynamic(\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct\n\n  /**\n   * Enum structs validate that their input is one of a set of values.\n   *\n   * ```js\n   * const Struct = struct.enum(['fruit', 'vegetable', 'meat'])\n   *\n   * Struct('fruit')\n   * ```\n   *\n   * They are similar to the `enum` type in TypeScript.\n   */\n\n  enum(schema: any[], defaults?: any): Struct\n\n  /**\n   * Function structs validate their input against a one-off validator function.\n   *\n   * ```js\n   * const Struct = struct.function(value => typeof value === 'string')\n   *\n   * Struct('a simple string')\n   * ```\n   *\n   * They can't provide as detailed of errors as other struct types, but they do\n   * allow for customization for easy one-off cases.\n   */\n\n  function(schema: Validator, defaults?: any): Struct\n\n  /**\n   * Instance structs validate that their input is an instance of a class.\n   *\n   * ```js\n   * const Struct = struct.instance(MyClass)\n   *\n   * Struct(new MyClass())\n   * ```\n   */\n\n  instance(schema: any, defaults?: any): Struct\n\n  /**\n   * Interface structs validate that their input matches an interface defined as\n   * a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.interface({\n   *   length: 'number',\n   *   indexOf: 'function',\n   * })\n   *\n   * Struct([1, 2, 3])\n   * Struct('abc')\n   * ```\n   *\n   * They are similar to the structural-typing granted by TypeScript.\n   */\n\n  interface(schema: any, defaults?: any): Struct\n\n  /**\n   * Intersection structs validate that their input matches **all** of a set of\n   * different structs.\n   *\n   * ```js\n   * const Struct = struct.intersection('string & email')\n   *\n   * Struct('jane@example.com')\n   * ```\n   *\n   * Note: The structs will be validated in order, so validators on the right\n   * can rely on the validators before them having passed.\n   *\n   * They are similar to the `&` operator in TypeScript.\n   */\n\n  intersection(schema: any[], defaults?: any): Struct\n\n  /**\n   * Lazy structs allow you to initialize a struct lazily, only initializing it\n   * once on the first time it attempts to be validated.\n   *\n   * ```js\n   * const Struct = struct({\n   *   nodes: struct.lazy(() => Struct)\n   * })\n   *\n   * Struct({\n   *   nodes: {\n   *     nodes: { ... }\n   *   }\n   * })\n   * ```\n   *\n   * They are helpful for defining recursive structs.\n   */\n\n  lazy(schema: () => Struct, defaults?: any): Struct\n\n  /**\n   * Literal structs validate their input against a literal value.\n   *\n   * ```js\n   * const Struct = struct.literal(42)\n   *\n   * Struct(42)\n   * ```\n   */\n\n  literal(schema: any, defaults?: any): Struct\n\n  /**\n   * Object structs validate that their input exactly matches an object defined\n   * as a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.object({\n   *   id: 'number',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `?` qualifier in TypeScript.\n   */\n\n  object(schema: {}, defaults?: any): Struct\n\n  /**\n   * Optional structs validate that their input passes a specific struct, or\n   * `undefined`.\n   *\n   * ```js\n   * const Struct = struct.optional('string?')\n   *\n   * Struct('a string of text')\n   * Struct(undefined)\n   * ```\n   *\n   * This is a shorthand for using `struct.union` with `undefined`.\n   */\n\n  optional(schema: any, defaults?: any): Struct\n\n  /**\n   * Partial structs validate that their input partially matches an object\n   * defined as a set of properties with associated types. All of the properties\n   * of the object are optional.\n   *\n   * ```js\n   * const Struct = struct.partial({\n   *   id: 'number'\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `Partial` utility in TypeScript.\n   */\n\n  partial(schema: {}, defaults?: any): Struct\n\n  /**\n   * Pick structs validate that their input exactly matches a subset of an\n   * object defined as a set of properties with associated types. All of the\n   * properties of its schema are required, but the object can have more that it\n   * does not concern itself with.\n   *\n   * ```js\n   * const Struct = struct.pick({\n   *   id: 'string',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'James Smith',\n   *   email: 'james@example.com',\n   * })\n   * ```\n   *\n   * They are similar to the `Pick` utility in TypeScript.\n   */\n\n  pick(schema: {}, defaults?: any): Struct\n\n  /**\n   * Record structs validate that their input is an object with keys that match\n   * one struct and values that match another. The object can have zero or many\n   * properties set on it.\n   *\n   * ```js\n   * const Struct = struct.record('string', 'number')\n   *\n   * Struct({\n   *   a: 1,\n   *   b: 2,\n   * })\n   * ```\n   *\n   * They are similar to the `Record` utility in TypeScript.\n   */\n\n  record(schema: [any, any], defaults?: any): Struct\n\n  /**\n   * Scalar structs validate that their input passes the `Validator` function\n   * defined for a specific type by name. By default Superstruct ships with a\n   * set of built-in scalars. But you can configure it with custom scalars that\n   * match your domain.\n   *\n   * ```js\n   * const Struct = struct.scalar('string')\n   *\n   * Struct('a string of text')\n   * ```\n   */\n\n  scalar(schema: string, defaults?: any): Struct\n\n  /**\n   * Size structs validate their input has a certain length, by checking its\n   * `length` property. This works strings or arrays.\n   *\n   * ```js\n   * const Struct = struct.size([0, 7])\n   *\n   * Struct([1, 2, 3])\n   * Struct('abcdefg')\n   * ```\n   *\n   * They are helpful for defining unions with array structs.\n   */\n\n  size(schema: [number, number], defaults?: any): Struct\n\n  /**\n   * Tuple structs validate that their input exactly matches a tuple of values,\n   * in length and in type.\n   *\n   * ```js\n   * const Struct = struct.tuple(['string', 'boolean'])\n   *\n   * Struct(['one', true])\n   * ```\n   */\n\n  tuple(schema: any[], defaults?: any): Struct\n\n  /**\n   * Union structs validate that their input matches **at least one** of a set\n   * of different structs.\n   *\n   * ```js\n   * const Struct = struct.union(['string', 'number'])\n   *\n   * Struct('a string')\n   * Struct(42)\n   * ```\n   *\n   * They are similar to the `|` operator in TypeScript.\n   */\n\n  union(schema: any[], defaults?: any): Struct\n\n  /**\n   * The class for errors thrown by `Structs`, defaults to [[StructError]].\n   */\n\n  Error: { new (failures: Failure[]): Error }\n\n  /**\n   * The set of data types that the factory knows.\n   */\n\n  Types: Record<string, Validator>\n}\n","import { superstruct } from './superstruct'\n\n/**\n * The singleton instance of Superstruct that is exported by default, configured\n * with types for all of the JavaScript built-in data types.\n *\n * You can use it if you don't need any custom types. However, if you do want to\n * define custom types, use the [[superstruct]] factory to configure your own\n * [[Superstruct]] instance.\n */\n\nconst struct = superstruct()\n\nexport { struct, superstruct }\nexport { Superstruct } from './superstruct'\nexport { StructError, Failure, Path, Branch } from './struct-error'\nexport { Types, Validator } from './types'\nexport { isStruct, Struct } from './struct'\n"]},"metadata":{},"sourceType":"module"}