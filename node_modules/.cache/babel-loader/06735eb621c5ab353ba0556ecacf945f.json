{"ast":null,"code":"// Although `Symbol` is widely supported these days, we can safely fall\n// back to using a non-enumerable string property without violating any\n// assumptions elsewhere in the implementation.\nvar useSymbol = typeof Symbol === \"function\" && typeof Symbol.for === \"function\"; // Used to mark `tuple.prototype` so that all objects that inherit from\n// any `tuple.prototype` object (there could be more than one) will test\n// positive according to `tuple.isTuple`.\n\nvar brand = useSymbol ? Symbol.for(\"immutable-tuple\") : \"@@__IMMUTABLE_TUPLE__@@\"; // Used to save a reference to the globally shared `UniversalWeakMap` that\n// stores all known `tuple` objects.\n\nvar globalKey = useSymbol ? Symbol.for(\"immutable-tuple-root\") : \"@@__IMMUTABLE_TUPLE_ROOT__@@\"; // Convenient helper for defining hidden immutable properties.\n\nfunction def(obj, name, value, enumerable) {\n  Object.defineProperty(obj, name, {\n    value: value,\n    enumerable: !!enumerable,\n    writable: false,\n    configurable: false\n  });\n  return value;\n}\n\nvar freeze = Object.freeze || function (obj) {\n  return obj;\n};\n\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) {\n        return false;\n      }\n\n    case \"function\":\n      return true;\n\n    default:\n      return false;\n  }\n} // The `mustConvertThisToArray` value is true when the corresponding\n// `Array` method does not attempt to modify `this`, which means we can\n// pass a `tuple` object as `this` without first converting it to an\n// `Array`.\n\n\nfunction forEachArrayMethod(fn) {\n  function call(name, mustConvertThisToArray) {\n    var desc = Object.getOwnPropertyDescriptor(Array.prototype, name);\n    fn(name, desc, !!mustConvertThisToArray);\n  }\n\n  call(\"every\");\n  call(\"filter\");\n  call(\"find\");\n  call(\"findIndex\");\n  call(\"forEach\");\n  call(\"includes\");\n  call(\"indexOf\");\n  call(\"join\");\n  call(\"lastIndexOf\");\n  call(\"map\");\n  call(\"reduce\");\n  call(\"reduceRight\");\n  call(\"slice\");\n  call(\"some\");\n  call(\"toLocaleString\");\n  call(\"toString\"); // The `reverse` and `sort` methods are usually destructive, but for\n  // `tuple` objects they return a new `tuple` object that has been\n  // appropriately reversed/sorted.\n\n  call(\"reverse\", true);\n  call(\"sort\", true); // Make `[...someTuple]` work.\n\n  call(useSymbol && Symbol.iterator || \"@@iterator\");\n} // A map data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\n\n\nvar UniversalWeakMap = function UniversalWeakMap() {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  this._weakMap = null;\n  this._strongMap = null;\n  this.data = null;\n}; // Since `get` and `set` are the only methods used, that's all I've\n// implemented here.\n\n\nUniversalWeakMap.prototype.get = function get(key) {\n  var map = this._getMap(key, false);\n\n  if (map) {\n    return map.get(key);\n  }\n};\n\nUniversalWeakMap.prototype.set = function set(key, value) {\n  this._getMap(key, true).set(key, value); // An actual `Map` or `WeakMap` would return `this` here, but\n  // returning the `value` is more convenient for the `tuple`\n  // implementation.\n\n\n  return value;\n};\n\nUniversalWeakMap.prototype._getMap = function _getMap(key, canCreate) {\n  if (!canCreate) {\n    return isObjRef(key) ? this._weakMap : this._strongMap;\n  }\n\n  if (isObjRef(key)) {\n    return this._weakMap || (this._weakMap = new WeakMap());\n  }\n\n  return this._strongMap || (this._strongMap = new Map());\n}; // See [`universal-weak-map.js`](universal-weak-map.html).\n// See [`util.js`](util.html).\n// If this package is installed multiple times, there could be mutiple\n// implementations of the `tuple` function with distinct `tuple.prototype`\n// objects, but the shared pool of `tuple` objects must be the same across\n// all implementations. While it would be ideal to use the `global`\n// object, there's no reliable way to get the global object across all JS\n// environments without using the `Function` constructor, so instead we\n// use the global `Array` constructor as a shared namespace.\n\n\nvar root = Array[globalKey] || def(Array, globalKey, new UniversalWeakMap(), false);\n\nfunction lookup() {\n  return lookupArray(arguments);\n}\n\nfunction lookupArray(array) {\n  var node = root; // Because we are building a tree of *weak* maps, the tree will not\n  // prevent objects in tuples from being garbage collected, since the\n  // tree itself will be pruned over time when the corresponding `tuple`\n  // objects become unreachable. In addition to internalization, this\n  // property is a key advantage of the `immutable-tuple` package.\n\n  var len = array.length;\n\n  for (var i = 0; i < len; ++i) {\n    var item = array[i];\n    node = node.get(item) || node.set(item, new UniversalWeakMap());\n  } // Return node.data rather than node itself to prevent tampering with\n  // the UniversalWeakMap tree.\n\n\n  return node.data || (node.data = Object.create(null));\n} // See [`lookup.js`](lookup.html).\n// See [`util.js`](util.html).\n// When called with any number of arguments, this function returns an\n// object that inherits from `tuple.prototype` and is guaranteed to be\n// `===` any other `tuple` object that has exactly the same items. In\n// computer science jargon, `tuple` instances are \"internalized\" or just\n// \"interned,\" which allows for constant-time equality checking, and makes\n// it possible for tuple objects to be used as `Map` or `WeakMap` keys, or\n// stored in a `Set`.\n\n\nfunction tuple() {\n  var arguments$1 = arguments;\n  var node = lookup.apply(null, arguments);\n\n  if (node.tuple) {\n    return node.tuple;\n  }\n\n  var t = Object.create(tuple.prototype); // Define immutable items with numeric indexes, and permanently fix the\n  // `.length` property.\n\n  var argc = arguments.length;\n\n  for (var i = 0; i < argc; ++i) {\n    t[i] = arguments$1[i];\n  }\n\n  def(t, \"length\", argc, false); // Remember this new `tuple` object so that we can return the same object\n  // earlier next time.\n\n  return freeze(node.tuple = t);\n} // Since the `immutable-tuple` package could be installed multiple times\n// in an application, there is no guarantee that the `tuple` constructor\n// or `tuple.prototype` will be unique, so `value instanceof tuple` is\n// unreliable. Instead, to test if a value is a tuple, you should use\n// `tuple.isTuple(value)`.\n\n\ndef(tuple.prototype, brand, true, false);\n\nfunction isTuple(that) {\n  return !!(that && that[brand] === true);\n}\n\ntuple.isTuple = isTuple;\n\nfunction toArray(tuple) {\n  var array = [];\n  var i = tuple.length;\n\n  while (i--) {\n    array[i] = tuple[i];\n  }\n\n  return array;\n} // Copy all generic non-destructive Array methods to `tuple.prototype`.\n// This works because (for example) `Array.prototype.slice` can be invoked\n// against any `Array`-like object.\n\n\nforEachArrayMethod(function (name, desc, mustConvertThisToArray) {\n  var method = desc && desc.value;\n\n  if (typeof method === \"function\") {\n    desc.value = function () {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      var result = method.apply(mustConvertThisToArray ? toArray(this) : this, args); // Of course, `tuple.prototype.slice` should return a `tuple` object,\n      // not a new `Array`.\n\n      return Array.isArray(result) ? tuple.apply(void 0, result) : result;\n    };\n\n    Object.defineProperty(tuple.prototype, name, desc);\n  }\n}); // Like `Array.prototype.concat`, except for the extra effort required to\n// convert any tuple arguments to arrays, so that\n// ```\n// tuple(1).concat(tuple(2), 3) === tuple(1, 2, 3)\n// ```\n\nvar ref = Array.prototype;\nvar concat = ref.concat;\n\ntuple.prototype.concat = function () {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) args[len] = arguments[len];\n\n  return tuple.apply(void 0, concat.apply(toArray(this), args.map(function (item) {\n    return isTuple(item) ? toArray(item) : item;\n  })));\n};\n\nexport default tuple;\nexport { tuple, lookup, lookupArray };","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/node_modules/immutable-tuple/dist/tuple.mjs"],"names":["useSymbol","Symbol","for","brand","globalKey","def","obj","name","value","enumerable","Object","defineProperty","writable","configurable","freeze","isObjRef","forEachArrayMethod","fn","call","mustConvertThisToArray","desc","getOwnPropertyDescriptor","Array","prototype","iterator","UniversalWeakMap","_weakMap","_strongMap","data","get","key","map","_getMap","set","canCreate","WeakMap","Map","root","lookup","lookupArray","arguments","array","node","len","length","i","item","create","tuple","arguments$1","apply","t","argc","isTuple","that","toArray","method","args","result","isArray","ref","concat"],"mappings":"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","sourcesContent":["// Although `Symbol` is widely supported these days, we can safely fall\n// back to using a non-enumerable string property without violating any\n// assumptions elsewhere in the implementation.\nvar useSymbol =\n  typeof Symbol === \"function\" &&\n  typeof Symbol.for === \"function\";\n\n// Used to mark `tuple.prototype` so that all objects that inherit from\n// any `tuple.prototype` object (there could be more than one) will test\n// positive according to `tuple.isTuple`.\nvar brand = useSymbol\n  ? Symbol.for(\"immutable-tuple\")\n  : \"@@__IMMUTABLE_TUPLE__@@\";\n\n// Used to save a reference to the globally shared `UniversalWeakMap` that\n// stores all known `tuple` objects.\nvar globalKey = useSymbol\n  ? Symbol.for(\"immutable-tuple-root\")\n  : \"@@__IMMUTABLE_TUPLE_ROOT__@@\";\n\n// Convenient helper for defining hidden immutable properties.\nfunction def(obj, name, value, enumerable) {\n  Object.defineProperty(obj, name, {\n    value: value,\n    enumerable: !! enumerable,\n    writable: false,\n    configurable: false\n  });\n  return value;\n}\n\nvar freeze = Object.freeze || function (obj) {\n  return obj;\n};\n\nfunction isObjRef(value) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) {\n      return false;\n    }\n  case \"function\":\n    return true;\n  default:\n    return false;\n  }\n}\n\n// The `mustConvertThisToArray` value is true when the corresponding\n// `Array` method does not attempt to modify `this`, which means we can\n// pass a `tuple` object as `this` without first converting it to an\n// `Array`.\nfunction forEachArrayMethod(fn) {\n  function call(name, mustConvertThisToArray) {\n    var desc = Object.getOwnPropertyDescriptor(Array.prototype, name);\n    fn(name, desc, !! mustConvertThisToArray);\n  }\n\n  call(\"every\");\n  call(\"filter\");\n  call(\"find\");\n  call(\"findIndex\");\n  call(\"forEach\");\n  call(\"includes\");\n  call(\"indexOf\");\n  call(\"join\");\n  call(\"lastIndexOf\");\n  call(\"map\");\n  call(\"reduce\");\n  call(\"reduceRight\");\n  call(\"slice\");\n  call(\"some\");\n  call(\"toLocaleString\");\n  call(\"toString\");\n\n  // The `reverse` and `sort` methods are usually destructive, but for\n  // `tuple` objects they return a new `tuple` object that has been\n  // appropriately reversed/sorted.\n  call(\"reverse\", true);\n  call(\"sort\", true);\n\n  // Make `[...someTuple]` work.\n  call(useSymbol && Symbol.iterator || \"@@iterator\");\n}\n\n// A map data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\nvar UniversalWeakMap = function UniversalWeakMap() {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  this._weakMap = null;\n  this._strongMap = null;\n  this.data = null;\n};\n\n// Since `get` and `set` are the only methods used, that's all I've\n// implemented here.\n\nUniversalWeakMap.prototype.get = function get (key) {\n  var map = this._getMap(key, false);\n  if (map) {\n    return map.get(key);\n  }\n};\n\nUniversalWeakMap.prototype.set = function set (key, value) {\n  this._getMap(key, true).set(key, value);\n  // An actual `Map` or `WeakMap` would return `this` here, but\n  // returning the `value` is more convenient for the `tuple`\n  // implementation.\n  return value;\n};\n\nUniversalWeakMap.prototype._getMap = function _getMap (key, canCreate) {\n  if (! canCreate) {\n    return isObjRef(key) ? this._weakMap : this._strongMap;\n  }\n  if (isObjRef(key)) {\n    return this._weakMap || (this._weakMap = new WeakMap);\n  }\n  return this._strongMap || (this._strongMap = new Map);\n};\n\n// See [`universal-weak-map.js`](universal-weak-map.html).\n// See [`util.js`](util.html).\n// If this package is installed multiple times, there could be mutiple\n// implementations of the `tuple` function with distinct `tuple.prototype`\n// objects, but the shared pool of `tuple` objects must be the same across\n// all implementations. While it would be ideal to use the `global`\n// object, there's no reliable way to get the global object across all JS\n// environments without using the `Function` constructor, so instead we\n// use the global `Array` constructor as a shared namespace.\nvar root = Array[globalKey] || def(Array, globalKey, new UniversalWeakMap, false);\n\nfunction lookup() {\n  return lookupArray(arguments);\n}\n\nfunction lookupArray(array) {\n  var node = root;\n\n  // Because we are building a tree of *weak* maps, the tree will not\n  // prevent objects in tuples from being garbage collected, since the\n  // tree itself will be pruned over time when the corresponding `tuple`\n  // objects become unreachable. In addition to internalization, this\n  // property is a key advantage of the `immutable-tuple` package.\n  var len = array.length;\n  for (var i = 0; i < len; ++i) {\n    var item = array[i];\n    node = node.get(item) || node.set(item, new UniversalWeakMap);\n  }\n\n  // Return node.data rather than node itself to prevent tampering with\n  // the UniversalWeakMap tree.\n  return node.data || (node.data = Object.create(null));\n}\n\n// See [`lookup.js`](lookup.html).\n// See [`util.js`](util.html).\n// When called with any number of arguments, this function returns an\n// object that inherits from `tuple.prototype` and is guaranteed to be\n// `===` any other `tuple` object that has exactly the same items. In\n// computer science jargon, `tuple` instances are \"internalized\" or just\n// \"interned,\" which allows for constant-time equality checking, and makes\n// it possible for tuple objects to be used as `Map` or `WeakMap` keys, or\n// stored in a `Set`.\nfunction tuple() {\n  var arguments$1 = arguments;\n\n  var node = lookup.apply(null, arguments);\n\n  if (node.tuple) {\n    return node.tuple;\n  }\n\n  var t = Object.create(tuple.prototype);\n\n  // Define immutable items with numeric indexes, and permanently fix the\n  // `.length` property.\n  var argc = arguments.length;\n  for (var i = 0; i < argc; ++i) {\n    t[i] = arguments$1[i];\n  }\n\n  def(t, \"length\", argc, false);\n\n  // Remember this new `tuple` object so that we can return the same object\n  // earlier next time.\n  return freeze(node.tuple = t);\n}\n\n// Since the `immutable-tuple` package could be installed multiple times\n// in an application, there is no guarantee that the `tuple` constructor\n// or `tuple.prototype` will be unique, so `value instanceof tuple` is\n// unreliable. Instead, to test if a value is a tuple, you should use\n// `tuple.isTuple(value)`.\ndef(tuple.prototype, brand, true, false);\nfunction isTuple(that) {\n  return !! (that && that[brand] === true);\n}\n\ntuple.isTuple = isTuple;\n\nfunction toArray(tuple) {\n  var array = [];\n  var i = tuple.length;\n  while (i--) { array[i] = tuple[i]; }\n  return array;\n}\n\n// Copy all generic non-destructive Array methods to `tuple.prototype`.\n// This works because (for example) `Array.prototype.slice` can be invoked\n// against any `Array`-like object.\nforEachArrayMethod(function (name, desc, mustConvertThisToArray) {\n  var method = desc && desc.value;\n  if (typeof method === \"function\") {\n    desc.value = function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = method.apply(\n        mustConvertThisToArray ? toArray(this) : this,\n        args\n      );\n      // Of course, `tuple.prototype.slice` should return a `tuple` object,\n      // not a new `Array`.\n      return Array.isArray(result) ? tuple.apply(void 0, result) : result;\n    };\n    Object.defineProperty(tuple.prototype, name, desc);\n  }\n});\n\n// Like `Array.prototype.concat`, except for the extra effort required to\n// convert any tuple arguments to arrays, so that\n// ```\n// tuple(1).concat(tuple(2), 3) === tuple(1, 2, 3)\n// ```\nvar ref = Array.prototype;\nvar concat = ref.concat;\ntuple.prototype.concat = function () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return tuple.apply(void 0, concat.apply(toArray(this), args.map(\n    function (item) { return isTuple(item) ? toArray(item) : item; }\n  )));\n};\n\nexport default tuple;\nexport { tuple, lookup, lookupArray };\n"]},"metadata":{},"sourceType":"module"}