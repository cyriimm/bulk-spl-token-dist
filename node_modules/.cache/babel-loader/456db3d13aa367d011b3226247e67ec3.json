{"ast":null,"code":"var ERRORS = require('./errors');\n\nvar NATIVE = require('./native'); // short-hand\n\n\nvar tfJSON = ERRORS.tfJSON;\nvar TfTypeError = ERRORS.TfTypeError;\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError;\nvar tfSubError = ERRORS.tfSubError;\nvar getValueTypeName = ERRORS.getValueTypeName;\nvar TYPES = {\n  arrayOf: function arrayOf(type, options) {\n    type = compile(type);\n    options = options || {};\n\n    function _arrayOf(array, strict) {\n      if (!NATIVE.Array(array)) return false;\n      if (NATIVE.Nil(array)) return false;\n      if (options.minLength !== undefined && array.length < options.minLength) return false;\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false;\n      if (options.length !== undefined && array.length !== options.length) return false;\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          throw tfSubError(e, i);\n        }\n      });\n    }\n\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']';\n\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}';\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' + (options.minLength === undefined ? 0 : options.minLength) + ',' + (options.maxLength === undefined ? Infinity : options.maxLength) + '}';\n      }\n\n      return str;\n    };\n\n    return _arrayOf;\n  },\n  maybe: function maybe(type) {\n    type = compile(type);\n\n    function _maybe(value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe);\n    }\n\n    _maybe.toJSON = function () {\n      return '?' + tfJSON(type);\n    };\n\n    return _maybe;\n  },\n  map: function map(propertyType, propertyKeyType) {\n    propertyType = compile(propertyType);\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType);\n\n    function _map(value, strict) {\n      if (!NATIVE.Object(value)) return false;\n      if (NATIVE.Nil(value)) return false;\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict);\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key');\n        }\n\n        try {\n          var propertyValue = value[propertyName];\n          typeforce(propertyType, propertyValue, strict);\n        } catch (e) {\n          throw tfSubError(e, propertyName);\n        }\n      }\n\n      return true;\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}';\n      };\n    } else {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyType) + '}';\n      };\n    }\n\n    return _map;\n  },\n  object: function object(uncompiled) {\n    var type = {};\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName]);\n    }\n\n    function _object(value, strict) {\n      if (!NATIVE.Object(value)) return false;\n      if (NATIVE.Nil(value)) return false;\n      var propertyName;\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName];\n          var propertyValue = value[propertyName];\n          typeforce(propertyType, propertyValue, strict);\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName);\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue;\n          throw new TfPropertyTypeError(undefined, propertyName);\n        }\n      }\n\n      return true;\n    }\n\n    _object.toJSON = function () {\n      return tfJSON(type);\n    };\n\n    return _object;\n  },\n  anyOf: function anyOf() {\n    var types = [].slice.call(arguments).map(compile);\n\n    function _anyOf(value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          return false;\n        }\n      });\n    }\n\n    _anyOf.toJSON = function () {\n      return types.map(tfJSON).join('|');\n    };\n\n    return _anyOf;\n  },\n  allOf: function allOf() {\n    var types = [].slice.call(arguments).map(compile);\n\n    function _allOf(value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          return false;\n        }\n      });\n    }\n\n    _allOf.toJSON = function () {\n      return types.map(tfJSON).join(' & ');\n    };\n\n    return _allOf;\n  },\n  quacksLike: function quacksLike(type) {\n    function _quacksLike(value) {\n      return type === getValueTypeName(value);\n    }\n\n    _quacksLike.toJSON = function () {\n      return type;\n    };\n\n    return _quacksLike;\n  },\n  tuple: function tuple() {\n    var types = [].slice.call(arguments).map(compile);\n\n    function _tuple(values, strict) {\n      if (NATIVE.Nil(values)) return false;\n      if (NATIVE.Nil(values.length)) return false;\n      if (strict && values.length !== types.length) return false;\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict);\n        } catch (e) {\n          throw tfSubError(e, i);\n        }\n      });\n    }\n\n    _tuple.toJSON = function () {\n      return '(' + types.map(tfJSON).join(', ') + ')';\n    };\n\n    return _tuple;\n  },\n  value: function value(expected) {\n    function _value(actual) {\n      return actual === expected;\n    }\n\n    _value.toJSON = function () {\n      return expected;\n    };\n\n    return _value;\n  }\n}; // TODO: deprecate\n\nTYPES.oneOf = TYPES.anyOf;\n\nfunction compile(type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1));\n    return NATIVE[type] || TYPES.quacksLike(type);\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1');\n      return TYPES.arrayOf(type[0]);\n    }\n\n    return TYPES.object(type);\n  } else if (NATIVE.Function(type)) {\n    return type;\n  }\n\n  return TYPES.value(type);\n}\n\nfunction typeforce(type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true;\n    throw new TfTypeError(surrogate || type, value);\n  } // JIT\n\n\n  return typeforce(compile(type), value, strict);\n} // assign types to typeforce function\n\n\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName];\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName];\n}\n\nvar EXTRA = require('./extra');\n\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName];\n}\n\ntypeforce.compile = compile;\ntypeforce.TfTypeError = TfTypeError;\ntypeforce.TfPropertyTypeError = TfPropertyTypeError;\nmodule.exports = typeforce;","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/node_modules/typeforce/index.js"],"names":["ERRORS","require","NATIVE","tfJSON","TfTypeError","TfPropertyTypeError","tfSubError","getValueTypeName","TYPES","arrayOf","type","options","compile","_arrayOf","array","strict","Array","Nil","minLength","undefined","length","maxLength","every","value","i","typeforce","e","toJSON","str","Infinity","maybe","_maybe","map","propertyType","propertyKeyType","_map","Object","propertyName","propertyValue","object","uncompiled","typePropertyName","_object","anyOf","types","slice","call","arguments","_anyOf","some","join","allOf","_allOf","quacksLike","_quacksLike","tuple","_tuple","values","expected","_value","actual","oneOf","String","TypeError","Function","surrogate","typeName","EXTRA","module","exports"],"mappings":"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","sourcesContent":["var ERRORS = require('./errors')\nvar NATIVE = require('./native')\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON\nvar TfTypeError = ERRORS.TfTypeError\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError\nvar tfSubError = ERRORS.tfSubError\nvar getValueTypeName = ERRORS.getValueTypeName\n\nvar TYPES = {\n  arrayOf: function arrayOf (type, options) {\n    type = compile(type)\n    options = options || {}\n\n    function _arrayOf (array, strict) {\n      if (!NATIVE.Array(array)) return false\n      if (NATIVE.Nil(array)) return false\n      if (options.minLength !== undefined && array.length < options.minLength) return false\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false\n      if (options.length !== undefined && array.length !== options.length) return false\n\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']'\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}'\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' +\n          (options.minLength === undefined ? 0 : options.minLength) + ',' +\n          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'\n      }\n      return str\n    }\n\n    return _arrayOf\n  },\n\n  maybe: function maybe (type) {\n    type = compile(type)\n\n    function _maybe (value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe)\n    }\n    _maybe.toJSON = function () { return '?' + tfJSON(type) }\n\n    return _maybe\n  },\n\n  map: function map (propertyType, propertyKeyType) {\n    propertyType = compile(propertyType)\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)\n\n    function _map (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict)\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key')\n        }\n\n        try {\n          var propertyValue = value[propertyName]\n          typeforce(propertyType, propertyValue, strict)\n        } catch (e) {\n          throw tfSubError(e, propertyName)\n        }\n      }\n\n      return true\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'\n      }\n    } else {\n      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }\n    }\n\n    return _map\n  },\n\n  object: function object (uncompiled) {\n    var type = {}\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName])\n    }\n\n    function _object (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      var propertyName\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName]\n          var propertyValue = value[propertyName]\n\n          typeforce(propertyType, propertyValue, strict)\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName)\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue\n\n          throw new TfPropertyTypeError(undefined, propertyName)\n        }\n      }\n\n      return true\n    }\n    _object.toJSON = function () { return tfJSON(type) }\n\n    return _object\n  },\n\n  anyOf: function anyOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _anyOf (value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }\n\n    return _anyOf\n  },\n\n  allOf: function allOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _allOf (value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }\n\n    return _allOf\n  },\n\n  quacksLike: function quacksLike (type) {\n    function _quacksLike (value) {\n      return type === getValueTypeName(value)\n    }\n    _quacksLike.toJSON = function () { return type }\n\n    return _quacksLike\n  },\n\n  tuple: function tuple () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _tuple (values, strict) {\n      if (NATIVE.Nil(values)) return false\n      if (NATIVE.Nil(values.length)) return false\n      if (strict && (values.length !== types.length)) return false\n\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }\n\n    return _tuple\n  },\n\n  value: function value (expected) {\n    function _value (actual) {\n      return actual === expected\n    }\n    _value.toJSON = function () { return expected }\n\n    return _value\n  }\n}\n\n// TODO: deprecate\nTYPES.oneOf = TYPES.anyOf\n\nfunction compile (type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1))\n\n    return NATIVE[type] || TYPES.quacksLike(type)\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')\n      return TYPES.arrayOf(type[0])\n    }\n\n    return TYPES.object(type)\n  } else if (NATIVE.Function(type)) {\n    return type\n  }\n\n  return TYPES.value(type)\n}\n\nfunction typeforce (type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true\n\n    throw new TfTypeError(surrogate || type, value)\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict)\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName]\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName]\n}\n\nvar EXTRA = require('./extra')\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName]\n}\n\ntypeforce.compile = compile\ntypeforce.TfTypeError = TfTypeError\ntypeforce.TfPropertyTypeError = TfPropertyTypeError\n\nmodule.exports = typeforce\n"]},"metadata":{},"sourceType":"script"}