{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _errors = require(\"@ledgerhq/errors\");\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n *\n */\n\nconst createHIDframing = (channel, packetSize) => {\n  return {\n    makeBlocks(apdu) {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([data, // fill data with padding\n      Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      const blocks = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    reduceResponse(acc, chunk) {\n      let {\n        data,\n        dataLength,\n        sequence\n      } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new _errors.TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new _errors.TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new _errors.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence\n      };\n    },\n\n    getReducedResult(acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n\n  };\n};\n\nvar _default = createHIDframing;\nexports.default = _default;","map":{"version":3,"sources":["../src/hid-framing.js"],"names":["Tag","b","Buffer","initialAcc","data","dataLength","sequence","createHIDframing","makeBlocks","asUInt16BE","apdu","blockSize","packetSize","nbBlocks","Math","blocks","i","head","chunk","reduceResponse","acc","TransportError","chunkData","getReducedResult"],"mappings":"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","sourcesContent":["// @flow\n\nimport { TransportError } from \"@ledgerhq/errors\";\n\nexport type ResponseAcc = ?{\n  data: Buffer,\n  dataLength: number,\n  sequence: number,\n};\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): ?Buffer {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n"]},"metadata":{},"sourceType":"script"}