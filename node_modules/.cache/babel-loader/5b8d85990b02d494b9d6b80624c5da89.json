{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\n\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\n\nvar secp256k1v3 = require('./secp256k1v3-lib/index');\n\nvar der = require('./secp256k1v3-lib/der');\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\n\n\nexports.privateKeyVerify = function (privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\n\n\nexports.privateKeyExport = function (privateKey, compressed) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.privateKeyImport = function (privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n\n  if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n\n  throw new Error(\"couldn't import from DER format\");\n};\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.privateKeyNegate = function (privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.privateKeyModInverse = function (privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\n\n\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\n\n\nexports.privateKeyTweakMul = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyCreate = function (privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyConvert = function (publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\n\n\nexports.publicKeyVerify = function (publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyCombine = function (publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureNormalize = function (signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureExport = function (signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureImport = function (signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureImportLax = function (signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n\n  var sigObj = der.signatureImportLax(signature);\n\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n\n  return secp256k1v3.signatureImport(sigObj);\n};\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\n\n\nexports.sign = function (message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n\n  var signOptions = undefined;\n\n  if (options) {\n    signOptions = {};\n\n    if (options.data === null) {\n      // validate option.data length\n      throw new TypeError('options.data should be a Buffer');\n    }\n\n    if (options.data) {\n      if (options.data.length != 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n\n      signOptions.data = new Uint8Array(options.data);\n    }\n\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n\n    if (options.noncefn) {\n      // convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n        var buffer = Buffer.from('');\n\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n\n        return new Uint8Array(buffer);\n      };\n    }\n  }\n\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\n\n\nexports.verify = function (message, signature, publicKey) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.recover = function (message, signature, recid, compressed) {\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.ecdh = function (publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\n\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  } // ensure valid privateKey length\n\n\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};","map":{"version":3,"sources":["../src/secp256k1v3-adapter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\nvar secp256k1v3 = require('./secp256k1v3-lib/index');\nvar der = require('./secp256k1v3-lib/der');\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\nexports.privateKeyVerify = function (privateKey) {\n    // secp256k1 v4 version throws when privateKey length is not 32\n    if (privateKey.length !== 32) {\n        return false;\n    }\n    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\nexports.privateKeyExport = function (privateKey, compressed) {\n    // secp256k1 v4 version throws when privateKey length is not 32\n    if (privateKey.length !== 32) {\n        throw new RangeError('private key length is invalid');\n    }\n    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n    return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyImport = function (privateKey) {\n    // privateKeyImport method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    privateKey = der.privateKeyImport(privateKey);\n    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\n        return privateKey;\n    }\n    throw new Error(\"couldn't import from DER format\");\n};\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyNegate = function (privateKey) {\n    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyModInverse = function (privateKey) {\n    if (privateKey.length !== 32) {\n        throw new Error('private key length is invalid');\n    }\n    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\n    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nexports.privateKeyTweakMul = function (privateKey, tweak) {\n    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyCreate = function (privateKey, compressed) {\n    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyConvert = function (publicKey, compressed) {\n    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nexports.publicKeyVerify = function (publicKey) {\n    // secp256k1 v4 version throws when publicKey length is not 33 or 65\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\n    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\n    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyCombine = function (publicKeys, compressed) {\n    var keys = [];\n    publicKeys.forEach(function (publicKey) {\n        keys.push(Uint8Array.from(publicKey));\n    });\n    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureNormalize = function (signature) {\n    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureExport = function (signature) {\n    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureImport = function (signature) {\n    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureImportLax = function (signature) {\n    // signatureImportLax method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    // ensure that signature is greater than 0\n    if (signature.length === 0) {\n        throw new RangeError('signature length is invalid');\n    }\n    var sigObj = der.signatureImportLax(signature);\n    if (sigObj === null) {\n        throw new Error(\"couldn't parse DER signature\");\n    }\n    return secp256k1v3.signatureImport(sigObj);\n};\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\nexports.sign = function (message, privateKey, options) {\n    if (options === null) {\n        throw new TypeError('options should be an Object');\n    }\n    var signOptions = undefined;\n    if (options) {\n        signOptions = {};\n        if (options.data === null) {\n            // validate option.data length\n            throw new TypeError('options.data should be a Buffer');\n        }\n        if (options.data) {\n            if (options.data.length != 32) {\n                throw new RangeError('options.data length is invalid');\n            }\n            signOptions.data = new Uint8Array(options.data);\n        }\n        if (options.noncefn === null) {\n            throw new TypeError('options.noncefn should be a Function');\n        }\n        if (options.noncefn) {\n            // convert option.noncefn function signature\n            signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n                var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n                var bufferData = data != null ? Buffer.from(data) : null;\n                var buffer = Buffer.from('');\n                if (options.noncefn) {\n                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n                }\n                return new Uint8Array(buffer);\n            };\n        }\n    }\n    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n    return {\n        signature: Buffer.from(sig.signature),\n        recovery: sig.recid,\n    };\n};\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nexports.verify = function (message, signature, publicKey) {\n    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.recover = function (message, signature, recid, compressed) {\n    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.ecdh = function (publicKey, privateKey) {\n    // note: secp256k1 v3 doesn't allow optional parameter\n    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n    // ecdhUnsafe method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    // ensure valid publicKey length\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\n        throw new RangeError('public key length is invalid');\n    }\n    // ensure valid privateKey length\n    if (privateKey.length !== 32) {\n        throw new RangeError('private key length is invalid');\n    }\n    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};\n//# sourceMappingURL=secp256k1v3-adapter.js.map"]},"metadata":{},"sourceType":"script"}