{"ast":null,"code":"const BN = require('bn.js');\n\nconst EC = require('elliptic').ec;\n\nconst secp256k1 = new EC('secp256k1');\n\nconst deterministicGenerateK = require('./rfc6979');\n\nconst ZERO32 = Buffer.alloc(32, 0);\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex');\nconst n = secp256k1.curve.n;\nconst nDiv2 = n.shrn(1);\nconst G = secp256k1.curve.g;\nconst THROW_BAD_PRIVATE = 'Expected Private';\nconst THROW_BAD_POINT = 'Expected Point';\nconst THROW_BAD_TWEAK = 'Expected Tweak';\nconst THROW_BAD_HASH = 'Expected Hash';\nconst THROW_BAD_SIGNATURE = 'Expected Signature';\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)';\n\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isOrderScalar(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isPoint(p) {\n  if (!Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try {\n      decodeFrom(p);\n    } catch (e) {\n      return false;\n    } // TODO: temporary\n\n\n    return true;\n  }\n\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\n\nfunction __isPointCompressed(p) {\n  return p[0] !== 0x04;\n}\n\nfunction isPointCompressed(p) {\n  if (!isPoint(p)) return false;\n  return __isPointCompressed(p);\n}\n\nfunction isPrivate(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(ZERO32) > 0 && // > 0\n  x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isSignature(value) {\n  const r = value.slice(0, 32);\n  const s = value.slice(32, 64);\n  return Buffer.isBuffer(value) && value.length === 64 && r.compare(EC_GROUP_ORDER) < 0 && s.compare(EC_GROUP_ORDER) < 0;\n}\n\nfunction assumeCompression(value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey);\n  if (value === undefined) return true;\n  return value;\n}\n\nfunction fromBuffer(d) {\n  return new BN(d);\n}\n\nfunction toBuffer(d) {\n  return d.toArrayLike(Buffer, 'be', 32);\n}\n\nfunction decodeFrom(P) {\n  return secp256k1.curve.decodePoint(P);\n}\n\nfunction getEncoded(P, compressed) {\n  return Buffer.from(P._encode(compressed));\n}\n\nfunction pointAdd(pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);\n  const a = decodeFrom(pA);\n  const b = decodeFrom(pB);\n  const pp = a.add(b);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed, pA);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointAddScalar(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed);\n  const tt = fromBuffer(tweak);\n  const qq = G.mul(tt);\n  const uu = pp.add(qq);\n  if (uu.isInfinity()) return null;\n  return getEncoded(uu, compressed);\n}\n\nfunction pointCompress(p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  const pp = decodeFrom(p);\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);\n  const compressed = assumeCompression(__compressed, p);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointFromScalar(d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  const dd = fromBuffer(d);\n  const pp = G.mul(dd);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointMultiply(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  const tt = fromBuffer(tweak);\n  const qq = pp.mul(tt);\n  if (qq.isInfinity()) return null;\n  return getEncoded(qq, compressed);\n}\n\nfunction privateAdd(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.add(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\n\nfunction privateSub(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.sub(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\n\nfunction sign(hash, x) {\n  return __sign(hash, x);\n}\n\nfunction signWithEntropy(hash, x, addData) {\n  return __sign(hash, x, addData);\n}\n\nfunction __sign(hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);\n  const d = fromBuffer(x);\n  const e = fromBuffer(hash);\n  let r, s;\n\n  const checkSig = function (k) {\n    const kI = fromBuffer(k);\n    const Q = G.mul(kI);\n    if (Q.isInfinity()) return false;\n    r = Q.x.umod(n);\n    if (r.isZero() === 0) return false;\n    s = kI.invm(n).mul(e.add(d.mul(r))).umod(n);\n    if (s.isZero() === 0) return false;\n    return true;\n  };\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s);\n  }\n\n  const buffer = Buffer.allocUnsafe(64);\n  toBuffer(r).copy(buffer, 0);\n  toBuffer(s).copy(buffer, 32);\n  return buffer;\n}\n\nfunction verify(hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT); // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);\n  const Q = decodeFrom(q);\n  const r = fromBuffer(signature.slice(0, 32));\n  const s = fromBuffer(signature.slice(32, 64));\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false;\n  } // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n\n\n  if (r.gtn(0) <= 0\n  /* || r.compareTo(n) >= 0 */\n  ) return false;\n  if (s.gtn(0) <= 0\n  /* || s.compareTo(n) >= 0 */\n  ) return false; // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n\n  const e = fromBuffer(hash); // Compute s^-1\n\n  const sInv = s.invm(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  const u1 = e.mul(sInv).umod(n);\n  const u2 = r.mul(sInv).umod(n); // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n\n  const R = G.mulAdd(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (R.isInfinity()) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  const xR = R.x; // 1.4.7 Set v = xR mod n\n\n  const v = xR.umod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.eq(r);\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n};","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/node_modules/tiny-secp256k1/js.js"],"names":["BN","require","EC","ec","secp256k1","deterministicGenerateK","ZERO32","Buffer","alloc","EC_GROUP_ORDER","from","EC_P","n","curve","nDiv2","shrn","G","g","THROW_BAD_PRIVATE","THROW_BAD_POINT","THROW_BAD_TWEAK","THROW_BAD_HASH","THROW_BAD_SIGNATURE","THROW_BAD_EXTRA_DATA","isScalar","x","isBuffer","length","isOrderScalar","compare","isPoint","p","t","slice","decodeFrom","e","y","__isPointCompressed","isPointCompressed","isPrivate","isSignature","value","r","s","assumeCompression","pubkey","undefined","fromBuffer","d","toBuffer","toArrayLike","P","decodePoint","getEncoded","compressed","_encode","pointAdd","pA","pB","__compressed","TypeError","a","b","pp","add","isInfinity","pointAddScalar","tweak","tt","qq","mul","uu","pointCompress","pointFromScalar","dd","pointMultiply","privateAdd","dt","umod","privateSub","sub","sign","hash","__sign","signWithEntropy","addData","checkSig","k","kI","Q","isZero","invm","cmp","buffer","allocUnsafe","copy","verify","q","signature","strict","gtn","sInv","u1","u2","R","mulAdd","xR","v","eq","module","exports"],"mappings":"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","sourcesContent":["const BN = require('bn.js')\nconst EC = require('elliptic').ec\nconst secp256k1 = new EC('secp256k1')\nconst deterministicGenerateK = require('./rfc6979')\n\nconst ZERO32 = Buffer.alloc(32, 0)\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')\n\nconst n = secp256k1.curve.n\nconst nDiv2 = n.shrn(1)\nconst G = secp256k1.curve.g\n\nconst THROW_BAD_PRIVATE = 'Expected Private'\nconst THROW_BAD_POINT = 'Expected Point'\nconst THROW_BAD_TWEAK = 'Expected Tweak'\nconst THROW_BAD_HASH = 'Expected Hash'\nconst THROW_BAD_SIGNATURE = 'Expected Signature'\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32\n}\n\nfunction isOrderScalar (x) {\n  if (!isScalar(x)) return false\n  return x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isPoint (p) {\n  if (!Buffer.isBuffer(p)) return false\n  if (p.length < 33) return false\n\n  const t = p[0]\n  const x = p.slice(1, 33)\n  if (x.compare(ZERO32) === 0) return false\n  if (x.compare(EC_P) >= 0) return false\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary\n    return true\n  }\n\n  const y = p.slice(33)\n  if (y.compare(ZERO32) === 0) return false\n  if (y.compare(EC_P) >= 0) return false\n  if (t === 0x04 && p.length === 65) return true\n  return false\n}\n\nfunction __isPointCompressed (p) {\n  return p[0] !== 0x04\n}\n\nfunction isPointCompressed (p) {\n  if (!isPoint(p)) return false\n  return __isPointCompressed(p)\n}\n\nfunction isPrivate (x) {\n  if (!isScalar(x)) return false\n  return x.compare(ZERO32) > 0 && // > 0\n    x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isSignature (value) {\n  const r = value.slice(0, 32)\n  const s = value.slice(32, 64)\n  return Buffer.isBuffer(value) && value.length === 64 &&\n    r.compare(EC_GROUP_ORDER) < 0 &&\n    s.compare(EC_GROUP_ORDER) < 0\n}\n\nfunction assumeCompression (value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)\n  if (value === undefined) return true\n  return value\n}\n\nfunction fromBuffer (d) { return new BN(d) }\nfunction toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }\nfunction decodeFrom (P) { return secp256k1.curve.decodePoint(P) }\nfunction getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }\n\nfunction pointAdd (pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)\n\n  const a = decodeFrom(pA)\n  const b = decodeFrom(pB)\n  const pp = a.add(b)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed, pA)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointAddScalar (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)\n\n  const tt = fromBuffer(tweak)\n  const qq = G.mul(tt)\n  const uu = pp.add(qq)\n  if (uu.isInfinity()) return null\n\n  return getEncoded(uu, compressed)\n}\n\nfunction pointCompress (p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n\n  const pp = decodeFrom(p)\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)\n\n  const compressed = assumeCompression(__compressed, p)\n\n  return getEncoded(pp, compressed)\n}\n\nfunction pointFromScalar (d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n\n  const dd = fromBuffer(d)\n  const pp = G.mul(dd)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointMultiply (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  const tt = fromBuffer(tweak)\n  const qq = pp.mul(tt)\n  if (qq.isInfinity()) return null\n\n  return getEncoded(qq, compressed)\n}\n\nfunction privateAdd (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.add(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction privateSub (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.sub(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction sign (hash, x) {\n  return __sign(hash, x)\n}\n\nfunction signWithEntropy (hash, x, addData) {\n  return __sign(hash, x, addData)\n}\n\nfunction __sign (hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)\n\n  const d = fromBuffer(x)\n  const e = fromBuffer(hash)\n\n  let r, s\n  const checkSig = function (k) {\n    const kI = fromBuffer(k)\n    const Q = G.mul(kI)\n\n    if (Q.isInfinity()) return false\n\n    r = Q.x.umod(n)\n    if (r.isZero() === 0) return false\n\n    s = kI\n      .invm(n)\n      .mul(e.add(d.mul(r)))\n      .umod(n)\n    if (s.isZero() === 0) return false\n\n    return true\n  }\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s)\n  }\n\n  const buffer = Buffer.allocUnsafe(64)\n  toBuffer(r).copy(buffer, 0)\n  toBuffer(s).copy(buffer, 32)\n  return buffer\n}\n\nfunction verify (hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)\n\n  const Q = decodeFrom(q)\n  const r = fromBuffer(signature.slice(0, 32))\n  const s = fromBuffer(signature.slice(32, 64))\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false\n  }\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false\n  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  const e = fromBuffer(hash)\n\n  // Compute s^-1\n  const sInv = s.invm(n)\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  const u1 = e.mul(sInv).umod(n)\n  const u2 = r.mul(sInv).umod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  const R = G.mulAdd(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (R.isInfinity()) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  const xR = R.x\n\n  // 1.4.7 Set v = xR mod n\n  const v = xR.umod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.eq(r)\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n}\n"]},"metadata":{},"sourceType":"script"}