{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport assert from 'assert';\nimport { useEffect, useReducer } from 'react';\nimport tuple from 'immutable-tuple';\nconst pageLoadTime = new Date();\nconst globalCache = new Map();\nconst errorCache = new Map();\n\nclass FetchLoops {\n  constructor() {\n    this.loops = new Map();\n  }\n\n  addListener(listener) {\n    if (!this.loops.has(listener.cacheKey)) {\n      this.loops.set(listener.cacheKey, new FetchLoopInternal(listener.cacheKey, listener.fn));\n    }\n\n    this.loops.get(listener.cacheKey).addListener(listener);\n  }\n\n  removeListener(listener) {\n    let loop = this.loops.get(listener.cacheKey);\n    loop.removeListener(listener);\n\n    if (loop.stopped) {\n      this.loops.delete(listener.cacheKey);\n    }\n  }\n\n  refresh(cacheKey) {\n    if (this.loops.has(cacheKey)) {\n      this.loops.get(cacheKey).refresh();\n    }\n  }\n\n  refreshAll() {\n    return Promise.all([...this.loops.values()].map(loop => loop.refresh()));\n  }\n\n}\n\nconst globalLoops = new FetchLoops();\n\nclass FetchLoopListener {\n  constructor(cacheKey, fn, refreshInterval, callback) {\n    this.cacheKey = void 0;\n    this.fn = void 0;\n    this.refreshInterval = void 0;\n    this.callback = void 0;\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.refreshInterval = refreshInterval;\n    this.callback = callback;\n  }\n\n}\n\nclass FetchLoopInternal {\n  constructor(cacheKey, fn) {\n    this.cacheKey = void 0;\n    this.fn = void 0;\n    this.timeoutId = void 0;\n    this.listeners = void 0;\n    this.errors = void 0;\n\n    this.refresh = async () => {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n\n      if (this.stopped) {\n        return;\n      }\n\n      try {\n        const data = await this.fn();\n        globalCache.set(this.cacheKey, data);\n        errorCache.delete(this.cacheKey);\n        this.errors = 0;\n        return data;\n      } catch (error) {\n        ++this.errors;\n        globalCache.delete(this.cacheKey);\n        errorCache.set(this.cacheKey, error);\n        console.warn(error);\n      } finally {\n        this.notifyListeners();\n\n        if (!this.timeoutId && !this.stopped) {\n          let waitTime = this.refreshInterval; // Back off on errors.\n\n          if (this.errors > 0) {\n            waitTime = Math.min(1000 * 2 ** (this.errors - 1), 60000);\n          } // Don't do any refreshing for the first five seconds, to make way for other things to load.\n\n\n          const timeSincePageLoad = +new Date() - +pageLoadTime;\n\n          if (timeSincePageLoad < 5000) {\n            waitTime += 5000 - timeSincePageLoad / 2;\n          } // Refresh background pages slowly.\n\n\n          if (document.visibilityState === 'hidden') {\n            waitTime = 60000;\n          } else if (!document.hasFocus()) {\n            waitTime *= 1.5;\n          } // Add jitter so we don't send all requests at the same time.\n\n\n          waitTime *= 0.8 + 0.4 * Math.random();\n          this.timeoutId = setTimeout(this.refresh, waitTime);\n        }\n      }\n    };\n\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.timeoutId = null;\n    this.listeners = new Set();\n    this.errors = 0;\n  }\n\n  get refreshInterval() {\n    return Math.min(...[...this.listeners].map(listener => listener.refreshInterval));\n  }\n\n  get stopped() {\n    return this.listeners.size === 0;\n  }\n\n  addListener(listener) {\n    const previousRefreshInterval = this.refreshInterval;\n    this.listeners.add(listener);\n\n    if (this.refreshInterval < previousRefreshInterval) {\n      this.refresh();\n    }\n  }\n\n  removeListener(listener) {\n    assert(this.listeners.delete(listener));\n\n    if (this.stopped) {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n    }\n  }\n\n  notifyListeners() {\n    this.listeners.forEach(listener => listener.callback());\n  }\n\n} // returns [data, loaded, error]\n// loaded is false when error is present for backwards compatibility\n\n\nexport function useAsyncData(asyncFn, cacheKey, {\n  refreshInterval = 60000\n} = {}) {\n  _s();\n\n  const [, rerender] = useReducer(i => i + 1, 0);\n  cacheKey = formatCacheKey(cacheKey);\n  useEffect(() => {\n    if (!cacheKey) {\n      return;\n    }\n\n    const listener = new FetchLoopListener(cacheKey, asyncFn, refreshInterval, rerender);\n    globalLoops.addListener(listener);\n    return () => globalLoops.removeListener(listener); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheKey, refreshInterval]);\n\n  if (!cacheKey) {\n    return [null, false, undefined];\n  }\n\n  const loaded = globalCache.has(cacheKey);\n  const error = errorCache.has(cacheKey) ? errorCache.get(cacheKey) : undefined;\n  const data = loaded ? globalCache.get(cacheKey) : undefined;\n  return [data, loaded, error];\n}\n\n_s(useAsyncData, \"pNgBuGje6hRqQQNB5UlZxEfXmhw=\");\n\nexport function refreshCache(cacheKey, clearCache = false) {\n  cacheKey = formatCacheKey(cacheKey);\n\n  if (clearCache) {\n    globalCache.delete(cacheKey);\n  }\n\n  const loop = globalLoops.loops.get(cacheKey);\n\n  if (loop) {\n    loop.refresh();\n\n    if (clearCache) {\n      loop.notifyListeners();\n    }\n  }\n}\nexport function setCache(cacheKey, value, {\n  initializeOnly = false\n} = {}) {\n  cacheKey = formatCacheKey(cacheKey);\n\n  if (initializeOnly && globalCache.has(cacheKey)) {\n    return;\n  }\n\n  globalCache.set(cacheKey, value);\n  const loop = globalLoops.loops.get(cacheKey);\n\n  if (loop) {\n    loop.notifyListeners();\n  }\n}\n\nfunction formatCacheKey(cacheKey) {\n  if (Array.isArray(cacheKey)) {\n    return tuple(...cacheKey);\n  }\n\n  return cacheKey;\n}","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/fetch-loop.ts"],"names":["assert","useEffect","useReducer","tuple","pageLoadTime","Date","globalCache","Map","errorCache","FetchLoops","loops","addListener","listener","has","cacheKey","set","FetchLoopInternal","fn","get","removeListener","loop","stopped","delete","refresh","refreshAll","Promise","all","values","map","globalLoops","FetchLoopListener","constructor","refreshInterval","callback","timeoutId","listeners","errors","clearTimeout","data","error","console","warn","notifyListeners","waitTime","Math","min","timeSincePageLoad","document","visibilityState","hasFocus","random","setTimeout","Set","size","previousRefreshInterval","add","forEach","useAsyncData","asyncFn","rerender","i","formatCacheKey","undefined","loaded","refreshCache","clearCache","setCache","value","initializeOnly","Array","isArray"],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport { useEffect, useReducer } from 'react';\nimport tuple from 'immutable-tuple';\n\nconst pageLoadTime = new Date();\n\nconst globalCache: Map<any, any> = new Map();\nconst errorCache: Map<any, any> = new Map();\n\nclass FetchLoops {\n  loops = new Map();\n\n  addListener(listener) {\n    if (!this.loops.has(listener.cacheKey)) {\n      this.loops.set(\n        listener.cacheKey,\n        new FetchLoopInternal(listener.cacheKey, listener.fn),\n      );\n    }\n    this.loops.get(listener.cacheKey).addListener(listener);\n  }\n\n  removeListener(listener) {\n    let loop = this.loops.get(listener.cacheKey);\n    loop.removeListener(listener);\n    if (loop.stopped) {\n      this.loops.delete(listener.cacheKey);\n    }\n  }\n\n  refresh(cacheKey) {\n    if (this.loops.has(cacheKey)) {\n      this.loops.get(cacheKey).refresh();\n    }\n  }\n\n  refreshAll() {\n    return Promise.all([...this.loops.values()].map((loop) => loop.refresh()));\n  }\n}\nconst globalLoops = new FetchLoops();\n\nclass FetchLoopListener<T = any> {\n  cacheKey: any;\n  fn: () => Promise<T>;\n  refreshInterval: number;\n  callback: () => void;\n\n  constructor(\n    cacheKey: any,\n    fn: () => Promise<T>,\n    refreshInterval: number,\n    callback: () => void,\n  ) {\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.refreshInterval = refreshInterval;\n    this.callback = callback;\n  }\n}\n\nclass FetchLoopInternal<T = any> {\n  cacheKey: any;\n  fn: () => Promise<T>;\n  timeoutId: null | any;\n  listeners: Set<FetchLoopListener<T>>;\n  errors: number;\n\n  constructor(cacheKey: any, fn: () => Promise<T>) {\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.timeoutId = null;\n    this.listeners = new Set();\n    this.errors = 0;\n  }\n\n  get refreshInterval(): number {\n    return Math.min(\n      ...[...this.listeners].map((listener) => listener.refreshInterval),\n    );\n  }\n\n  get stopped(): boolean {\n    return this.listeners.size === 0;\n  }\n\n  addListener(listener: FetchLoopListener<T>): void {\n    const previousRefreshInterval = this.refreshInterval;\n    this.listeners.add(listener);\n    if (this.refreshInterval < previousRefreshInterval) {\n      this.refresh();\n    }\n  }\n\n  removeListener(listener: FetchLoopListener<T>): void {\n    assert(this.listeners.delete(listener));\n    if (this.stopped) {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n    }\n  }\n\n  notifyListeners(): void {\n    this.listeners.forEach((listener) => listener.callback());\n  }\n\n  refresh = async () => {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n    if (this.stopped) {\n      return;\n    }\n\n    try {\n      const data = await this.fn();\n      globalCache.set(this.cacheKey, data);\n      errorCache.delete(this.cacheKey);\n      this.errors = 0;\n      return data;\n    } catch (error) {\n      ++this.errors;\n      globalCache.delete(this.cacheKey);\n      errorCache.set(this.cacheKey, error);\n      console.warn(error);\n    } finally {\n      this.notifyListeners();\n      if (!this.timeoutId && !this.stopped) {\n        let waitTime = this.refreshInterval;\n\n        // Back off on errors.\n        if (this.errors > 0) {\n          waitTime = Math.min(1000 * 2 ** (this.errors - 1), 60000);\n        }\n\n        // Don't do any refreshing for the first five seconds, to make way for other things to load.\n        const timeSincePageLoad = +new Date() - +pageLoadTime;\n        if (timeSincePageLoad < 5000) {\n          waitTime += 5000 - timeSincePageLoad / 2;\n        }\n\n        // Refresh background pages slowly.\n        if (document.visibilityState === 'hidden') {\n          waitTime = 60000;\n        } else if (!document.hasFocus()) {\n          waitTime *= 1.5;\n        }\n\n        // Add jitter so we don't send all requests at the same time.\n        waitTime *= 0.8 + 0.4 * Math.random();\n\n        this.timeoutId = setTimeout(this.refresh, waitTime);\n      }\n    }\n  };\n}\n\n// returns [data, loaded, error]\n// loaded is false when error is present for backwards compatibility\nexport function useAsyncData<T = any>(\n  asyncFn: () => Promise<T>,\n  cacheKey: any,\n  { refreshInterval = 60000 } = {},\n): [null | undefined | T, boolean, any] {\n  const [, rerender] = useReducer((i) => i + 1, 0);\n  cacheKey = formatCacheKey(cacheKey);\n\n  useEffect(() => {\n    if (!cacheKey) {\n      return;\n    }\n    const listener = new FetchLoopListener<T>(\n      cacheKey,\n      asyncFn,\n      refreshInterval,\n      rerender,\n    );\n    globalLoops.addListener(listener);\n    return () => globalLoops.removeListener(listener);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheKey, refreshInterval]);\n\n  if (!cacheKey) {\n    return [null, false, undefined];\n  }\n\n  const loaded = globalCache.has(cacheKey);\n  const error = errorCache.has(cacheKey) ? errorCache.get(cacheKey) : undefined;\n  const data = loaded ? globalCache.get(cacheKey) : undefined;\n  return [data, loaded, error];\n}\n\nexport function refreshCache(cacheKey, clearCache = false) {\n  cacheKey = formatCacheKey(cacheKey);\n  if (clearCache) {\n    globalCache.delete(cacheKey);\n  }\n  const loop = globalLoops.loops.get(cacheKey);\n  if (loop) {\n    loop.refresh();\n    if (clearCache) {\n      loop.notifyListeners();\n    }\n  }\n}\n\nexport function setCache(cacheKey, value, { initializeOnly = false } = {}) {\n  cacheKey = formatCacheKey(cacheKey);\n  if (initializeOnly && globalCache.has(cacheKey)) {\n    return;\n  }\n  globalCache.set(cacheKey, value);\n  const loop = globalLoops.loops.get(cacheKey);\n  if (loop) {\n    loop.notifyListeners();\n  }\n}\n\nfunction formatCacheKey(cacheKey) {\n  if (Array.isArray(cacheKey)) {\n    return tuple(...cacheKey);\n  }\n  return cacheKey;\n}\n"]},"metadata":{},"sourceType":"module"}