{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nexport default class TransportWebUSB extends Transport {\n  constructor(device, interfaceNumber) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.interfaceNumber = void 0;\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n\n\n  static async open(device) {\n    await device.open();\n\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({\n      alternates\n    }) => alternates.some(a => a.interfaceClass === 255));\n\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n    }\n\n    const interfaceNumber = iface.interfaceNumber;\n\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n\n    const transport = new TransportWebUSB(device, interfaceNumber);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    }; // $FlowFixMe\n\n\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n  /**\n   * Release the transport device\n   */\n\n\n  async close() {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\n\nTransportWebUSB.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};\n\nasync function gracefullyResetDevice(device) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}","map":{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["configurationValue","endpointNumber","TransportWebUSB","device","deviceModel","channel","Math","packetSize","interfaceNumber","constructor","identifyUSBProductId","isSupported","list","getLedgerDevices","listen","observer","unsubscribed","getFirstLedgerDevice","type","descriptor","error","window","unsubscribe","request","requestLedgerDevice","openConnected","devices","open","gracefullyResetDevice","iface","alternates","a","e","transport","onDisconnect","navigator","close","apdu","log","framing","hidFraming","blocks","i","result","r","buffer","Buffer","acc","setScrambleKey","console"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}