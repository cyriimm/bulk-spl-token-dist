{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { pbkdf2 } from 'crypto';\nimport { randomBytes, secretbox } from 'tweetnacl';\nimport * as bip32 from 'bip32';\nimport bs58 from 'bs58';\nimport { EventEmitter } from 'events';\nimport { isExtension } from './utils';\nimport { useEffect, useState } from 'react';\nexport function normalizeMnemonic(mnemonic) {\n  return mnemonic.trim().split(/\\s+/g).join(\" \");\n}\nexport async function generateMnemonicAndSeed() {\n  const bip39 = await import('bip39');\n  const mnemonic = bip39.generateMnemonic(256);\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  return {\n    mnemonic,\n    seed: Buffer.from(seed).toString('hex')\n  };\n}\nexport async function mnemonicToSeed(mnemonic) {\n  const bip39 = await import('bip39');\n\n  if (!bip39.validateMnemonic(mnemonic)) {\n    throw new Error('Invalid seed words');\n  }\n\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  return Buffer.from(seed).toString('hex');\n}\n\nasync function getExtensionUnlockedMnemonic() {\n  if (!isExtension) {\n    return null;\n  }\n\n  return new Promise(resolve => {\n    chrome.runtime.sendMessage({\n      channel: 'sollet_extension_mnemonic_channel',\n      method: 'get'\n    }, resolve);\n  });\n}\n\nconst EMPTY_MNEMONIC = {\n  mnemonic: null,\n  seed: null,\n  importsEncryptionKey: null,\n  derivationPath: null\n};\n\nlet unlockedMnemonicAndSeed = (async () => {\n  const unlockedExpiration = localStorage.getItem('unlockedExpiration'); // Left here to clean up stored mnemonics from previous method\n\n  if (unlockedExpiration && Number(unlockedExpiration) < Date.now()) {\n    localStorage.removeItem('unlocked');\n    localStorage.removeItem('unlockedExpiration');\n  }\n\n  const stored = JSON.parse((await getExtensionUnlockedMnemonic()) || sessionStorage.getItem('unlocked') || localStorage.getItem('unlocked') || 'null');\n\n  if (stored === null) {\n    return EMPTY_MNEMONIC;\n  }\n\n  return {\n    importsEncryptionKey: deriveImportsEncryptionKey(stored.seed),\n    ...stored\n  };\n})();\n\nexport const walletSeedChanged = new EventEmitter();\nexport function getUnlockedMnemonicAndSeed() {\n  return unlockedMnemonicAndSeed;\n} // returns [mnemonic, loading]\n\nexport function useUnlockedMnemonicAndSeed() {\n  _s();\n\n  const [currentUnlockedMnemonic, setCurrentUnlockedMnemonic] = useState(null);\n  useEffect(() => {\n    walletSeedChanged.addListener('change', setCurrentUnlockedMnemonic);\n    unlockedMnemonicAndSeed.then(setCurrentUnlockedMnemonic);\n    return () => {\n      walletSeedChanged.removeListener('change', setCurrentUnlockedMnemonic);\n    };\n  }, []);\n  return !currentUnlockedMnemonic ? [EMPTY_MNEMONIC, true] : [currentUnlockedMnemonic, false];\n}\n\n_s(useUnlockedMnemonicAndSeed, \"Cr2yNmYbvPvJR6kpAWQYXaog4JQ=\");\n\nexport function useHasLockedMnemonicAndSeed() {\n  _s2();\n\n  const [unlockedMnemonic, loading] = useUnlockedMnemonicAndSeed();\n  return [!unlockedMnemonic.seed && !!localStorage.getItem('locked'), loading];\n}\n\n_s2(useHasLockedMnemonicAndSeed, \"EY7OL1JYtEX/hYAghjHK1/MPcKM=\", false, function () {\n  return [useUnlockedMnemonicAndSeed];\n});\n\nfunction setUnlockedMnemonicAndSeed(mnemonic, seed, importsEncryptionKey, derivationPath) {\n  const data = {\n    mnemonic,\n    seed,\n    importsEncryptionKey,\n    derivationPath\n  };\n  unlockedMnemonicAndSeed = Promise.resolve(data);\n  walletSeedChanged.emit('change', data);\n}\n\nexport async function storeMnemonicAndSeed(mnemonic, seed, password, derivationPath) {\n  const plaintext = JSON.stringify({\n    mnemonic,\n    seed,\n    derivationPath\n  });\n\n  if (password) {\n    const salt = randomBytes(16);\n    const kdf = 'pbkdf2';\n    const iterations = 100000;\n    const digest = 'sha256';\n    const key = await deriveEncryptionKey(password, salt, iterations, digest);\n    const nonce = randomBytes(secretbox.nonceLength);\n    const encrypted = secretbox(Buffer.from(plaintext), nonce, key);\n    localStorage.setItem('locked', JSON.stringify({\n      encrypted: bs58.encode(encrypted),\n      nonce: bs58.encode(nonce),\n      kdf,\n      salt: bs58.encode(salt),\n      iterations,\n      digest\n    }));\n    localStorage.removeItem('unlocked');\n  } else {\n    localStorage.setItem('unlocked', plaintext);\n    localStorage.removeItem('locked');\n  }\n\n  sessionStorage.removeItem('unlocked');\n\n  if (isExtension) {\n    chrome.runtime.sendMessage({\n      channel: 'sollet_extension_mnemonic_channel',\n      method: 'set',\n      data: ''\n    });\n  }\n\n  const importsEncryptionKey = deriveImportsEncryptionKey(seed);\n  setUnlockedMnemonicAndSeed(mnemonic, seed, importsEncryptionKey, derivationPath);\n}\nexport async function loadMnemonicAndSeed(password, stayLoggedIn) {\n  const {\n    encrypted: encodedEncrypted,\n    nonce: encodedNonce,\n    salt: encodedSalt,\n    iterations,\n    digest\n  } = JSON.parse(localStorage.getItem('locked'));\n  const encrypted = bs58.decode(encodedEncrypted);\n  const nonce = bs58.decode(encodedNonce);\n  const salt = bs58.decode(encodedSalt);\n  const key = await deriveEncryptionKey(password, salt, iterations, digest);\n  const plaintext = secretbox.open(encrypted, nonce, key);\n\n  if (!plaintext) {\n    throw new Error('Incorrect password');\n  }\n\n  const decodedPlaintext = Buffer.from(plaintext).toString();\n  const {\n    mnemonic,\n    seed,\n    derivationPath\n  } = JSON.parse(decodedPlaintext);\n\n  if (stayLoggedIn) {\n    if (isExtension) {\n      chrome.runtime.sendMessage({\n        channel: 'sollet_extension_mnemonic_channel',\n        method: 'set',\n        data: decodedPlaintext\n      });\n    } else {\n      sessionStorage.setItem('unlocked', decodedPlaintext);\n    }\n  }\n\n  const importsEncryptionKey = deriveImportsEncryptionKey(seed);\n  setUnlockedMnemonicAndSeed(mnemonic, seed, importsEncryptionKey, derivationPath);\n  return {\n    mnemonic,\n    seed,\n    derivationPath\n  };\n}\n\nasync function deriveEncryptionKey(password, salt, iterations, digest) {\n  return new Promise((resolve, reject) => pbkdf2(password, salt, iterations, secretbox.keyLength, digest, (err, key) => err ? reject(err) : resolve(key)));\n}\n\nexport function lockWallet() {\n  setUnlockedMnemonicAndSeed(null, null, null, null);\n} // Returns the 32 byte key used to encrypt imported private keys.\n\nfunction deriveImportsEncryptionKey(seed) {\n  // SLIP16 derivation path.\n  return bip32.fromSeed(Buffer.from(seed, 'hex')).derivePath(\"m/10016'/0\").privateKey;\n}\n\nexport function forgetWallet() {\n  localStorage.clear();\n  sessionStorage.removeItem('unlocked');\n\n  if (isExtension) {\n    chrome.runtime.sendMessage({\n      channel: 'sollet_extension_mnemonic_channel',\n      method: 'set',\n      data: ''\n    });\n  }\n\n  unlockedMnemonicAndSeed = {\n    mnemonic: null,\n    seed: null,\n    importsEncryptionKey: null\n  };\n  walletSeedChanged.emit('change', unlockedMnemonicAndSeed);\n\n  if (isExtension) {\n    // Must use wrapper function for window.location.reload\n    chrome.storage.local.clear(() => window.location.reload());\n  } else {\n    window.location.reload();\n  }\n}","map":{"version":3,"sources":["/Users/onyejivictor/Documents/code/cope/bulk-spl-token-dist/src/utils/wallet-seed.js"],"names":["pbkdf2","randomBytes","secretbox","bip32","bs58","EventEmitter","isExtension","useEffect","useState","normalizeMnemonic","mnemonic","trim","split","join","generateMnemonicAndSeed","bip39","generateMnemonic","seed","mnemonicToSeed","Buffer","from","toString","validateMnemonic","Error","getExtensionUnlockedMnemonic","Promise","resolve","chrome","runtime","sendMessage","channel","method","EMPTY_MNEMONIC","importsEncryptionKey","derivationPath","unlockedMnemonicAndSeed","unlockedExpiration","localStorage","getItem","Number","Date","now","removeItem","stored","JSON","parse","sessionStorage","deriveImportsEncryptionKey","walletSeedChanged","getUnlockedMnemonicAndSeed","useUnlockedMnemonicAndSeed","currentUnlockedMnemonic","setCurrentUnlockedMnemonic","addListener","then","removeListener","useHasLockedMnemonicAndSeed","unlockedMnemonic","loading","setUnlockedMnemonicAndSeed","data","emit","storeMnemonicAndSeed","password","plaintext","stringify","salt","kdf","iterations","digest","key","deriveEncryptionKey","nonce","nonceLength","encrypted","setItem","encode","loadMnemonicAndSeed","stayLoggedIn","encodedEncrypted","encodedNonce","encodedSalt","decode","open","decodedPlaintext","reject","keyLength","err","lockWallet","fromSeed","derivePath","privateKey","forgetWallet","clear","storage","local","window","location","reload"],"mappings":"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","sourcesContent":["import { pbkdf2 } from 'crypto';\nimport { randomBytes, secretbox } from 'tweetnacl';\nimport * as bip32 from 'bip32';\nimport bs58 from 'bs58';\nimport { EventEmitter } from 'events';\nimport { isExtension } from './utils';\nimport { useEffect, useState } from 'react';\n\nexport function normalizeMnemonic(mnemonic) {\n  return mnemonic.trim().split(/\\s+/g).join(\" \");\n}\n\nexport async function generateMnemonicAndSeed() {\n  const bip39 = await import('bip39');\n  const mnemonic = bip39.generateMnemonic(256);\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  return { mnemonic, seed: Buffer.from(seed).toString('hex') };\n}\n\nexport async function mnemonicToSeed(mnemonic) {\n  const bip39 = await import('bip39');\n  if (!bip39.validateMnemonic(mnemonic)) {\n    throw new Error('Invalid seed words');\n  }\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  return Buffer.from(seed).toString('hex');\n}\n\nasync function getExtensionUnlockedMnemonic() {\n  if (!isExtension) {\n    return null;\n  }\n\n  return new Promise((resolve) => {\n    chrome.runtime.sendMessage({\n      channel: 'sollet_extension_mnemonic_channel',\n      method: 'get',\n    }, resolve);\n  })\n}\n\nconst EMPTY_MNEMONIC = {\n  mnemonic: null,\n  seed: null,\n  importsEncryptionKey: null,\n  derivationPath: null,\n};\n\nlet unlockedMnemonicAndSeed = (async () => {\n  const unlockedExpiration = localStorage.getItem('unlockedExpiration');\n  // Left here to clean up stored mnemonics from previous method\n  if (unlockedExpiration && Number(unlockedExpiration) < Date.now()) {\n    localStorage.removeItem('unlocked');\n    localStorage.removeItem('unlockedExpiration');\n  }\n  const stored = JSON.parse(\n    (await getExtensionUnlockedMnemonic()) ||\n    sessionStorage.getItem('unlocked') ||\n      localStorage.getItem('unlocked') ||\n      'null',\n  );\n  if (stored === null) {\n    return EMPTY_MNEMONIC;\n  }\n  return {\n    importsEncryptionKey: deriveImportsEncryptionKey(stored.seed),\n    ...stored,\n  };\n})();\n\nexport const walletSeedChanged = new EventEmitter();\n\nexport function getUnlockedMnemonicAndSeed() {\n  return unlockedMnemonicAndSeed;\n}\n\n// returns [mnemonic, loading]\nexport function useUnlockedMnemonicAndSeed() {\n  const [currentUnlockedMnemonic, setCurrentUnlockedMnemonic] = useState(null);\n  \n  useEffect(() => {\n    walletSeedChanged.addListener('change', setCurrentUnlockedMnemonic);\n    unlockedMnemonicAndSeed.then(setCurrentUnlockedMnemonic);\n    return () => {\n      walletSeedChanged.removeListener('change', setCurrentUnlockedMnemonic);\n    }\n  }, []);\n\n  return !currentUnlockedMnemonic\n    ? [EMPTY_MNEMONIC, true]\n    : [currentUnlockedMnemonic, false];\n}\n\nexport function useHasLockedMnemonicAndSeed() {\n  const [unlockedMnemonic, loading] = useUnlockedMnemonicAndSeed();\n\n  return [!unlockedMnemonic.seed && !!localStorage.getItem('locked'), loading];\n}\n\nfunction setUnlockedMnemonicAndSeed(\n  mnemonic,\n  seed,\n  importsEncryptionKey,\n  derivationPath,\n) {\n  const data = {\n    mnemonic,\n    seed,\n    importsEncryptionKey,\n    derivationPath,\n  };\n  unlockedMnemonicAndSeed = Promise.resolve(data);\n  walletSeedChanged.emit('change', data);\n}\n\nexport async function storeMnemonicAndSeed(\n  mnemonic,\n  seed,\n  password,\n  derivationPath,\n) {\n  const plaintext = JSON.stringify({ mnemonic, seed, derivationPath });\n  if (password) {\n    const salt = randomBytes(16);\n    const kdf = 'pbkdf2';\n    const iterations = 100000;\n    const digest = 'sha256';\n    const key = await deriveEncryptionKey(password, salt, iterations, digest);\n    const nonce = randomBytes(secretbox.nonceLength);\n    const encrypted = secretbox(Buffer.from(plaintext), nonce, key);\n    localStorage.setItem(\n      'locked',\n      JSON.stringify({\n        encrypted: bs58.encode(encrypted),\n        nonce: bs58.encode(nonce),\n        kdf,\n        salt: bs58.encode(salt),\n        iterations,\n        digest,\n      }),\n    );\n    localStorage.removeItem('unlocked');\n  } else {\n    localStorage.setItem('unlocked', plaintext);\n    localStorage.removeItem('locked');\n  }\n  sessionStorage.removeItem('unlocked');\n  if (isExtension) {\n    chrome.runtime.sendMessage({\n      channel: 'sollet_extension_mnemonic_channel',\n      method: 'set',\n      data: '',\n    });\n  }\n  const importsEncryptionKey = deriveImportsEncryptionKey(seed);\n  setUnlockedMnemonicAndSeed(\n    mnemonic,\n    seed,\n    importsEncryptionKey,\n    derivationPath,\n  );\n}\n\nexport async function loadMnemonicAndSeed(password, stayLoggedIn) {\n  const {\n    encrypted: encodedEncrypted,\n    nonce: encodedNonce,\n    salt: encodedSalt,\n    iterations,\n    digest,\n  } = JSON.parse(localStorage.getItem('locked'));\n  const encrypted = bs58.decode(encodedEncrypted);\n  const nonce = bs58.decode(encodedNonce);\n  const salt = bs58.decode(encodedSalt);\n  const key = await deriveEncryptionKey(password, salt, iterations, digest);\n  const plaintext = secretbox.open(encrypted, nonce, key);\n  if (!plaintext) {\n    throw new Error('Incorrect password');\n  }\n  const decodedPlaintext = Buffer.from(plaintext).toString();\n  const { mnemonic, seed, derivationPath } = JSON.parse(decodedPlaintext);\n  if (stayLoggedIn) {\n    if (isExtension) {\n      chrome.runtime.sendMessage({\n        channel: 'sollet_extension_mnemonic_channel',\n        method: 'set',\n        data: decodedPlaintext,\n      });\n    } else {\n      sessionStorage.setItem('unlocked', decodedPlaintext);\n    }\n  }\n  const importsEncryptionKey = deriveImportsEncryptionKey(seed);\n  setUnlockedMnemonicAndSeed(\n    mnemonic,\n    seed,\n    importsEncryptionKey,\n    derivationPath,\n  );\n  return { mnemonic, seed, derivationPath };\n}\n\nasync function deriveEncryptionKey(password, salt, iterations, digest) {\n  return new Promise((resolve, reject) =>\n    pbkdf2(\n      password,\n      salt,\n      iterations,\n      secretbox.keyLength,\n      digest,\n      (err, key) => (err ? reject(err) : resolve(key)),\n    ),\n  );\n}\n\nexport function lockWallet() {\n  setUnlockedMnemonicAndSeed(null, null, null, null);\n}\n\n// Returns the 32 byte key used to encrypt imported private keys.\nfunction deriveImportsEncryptionKey(seed) {\n  // SLIP16 derivation path.\n  return bip32.fromSeed(Buffer.from(seed, 'hex')).derivePath(\"m/10016'/0\")\n    .privateKey;\n}\n\nexport function forgetWallet() {\n  localStorage.clear();\n  sessionStorage.removeItem('unlocked');\n  if (isExtension) {\n    chrome.runtime.sendMessage({\n      channel: 'sollet_extension_mnemonic_channel',\n      method: 'set',\n      data: '',\n    });\n  }\n  unlockedMnemonicAndSeed = {\n    mnemonic: null,\n    seed: null,\n    importsEncryptionKey: null,\n  };\n  walletSeedChanged.emit('change', unlockedMnemonicAndSeed);\n  if (isExtension) {\n    // Must use wrapper function for window.location.reload\n    chrome.storage.local.clear(() => window.location.reload());\n  } else {\n    window.location.reload();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}