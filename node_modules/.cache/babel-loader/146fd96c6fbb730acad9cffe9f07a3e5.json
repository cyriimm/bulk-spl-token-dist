{"ast":null,"code":"\"use strict\"; //See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value) {\n  const result = [];\n\n  while (value) {\n    result.unshift(value & 0xff);\n    value >>= 8;\n  }\n\n  return result;\n}\n\nfunction unarrayifyInteger(data, offset, length) {\n  let result = 0;\n\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n\n  return result;\n}\n\nfunction _encode(object) {\n  if (Array.isArray(object)) {\n    let payload = [];\n    object.forEach(function (child) {\n      payload = payload.concat(_encode(child));\n    });\n\n    if (payload.length <= 55) {\n      payload.unshift(0xc0 + payload.length);\n      return payload;\n    }\n\n    const length = arrayifyInteger(payload.length);\n    length.unshift(0xf7 + length.length);\n    return length.concat(payload);\n  }\n\n  if (!isBytesLike(object)) {\n    logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n  }\n\n  const data = Array.prototype.slice.call(arrayify(object));\n\n  if (data.length === 1 && data[0] <= 0x7f) {\n    return data;\n  } else if (data.length <= 55) {\n    data.unshift(0x80 + data.length);\n    return data;\n  }\n\n  const length = arrayifyInteger(data.length);\n  length.unshift(0xb7 + length.length);\n  return length.concat(data);\n}\n\nexport function encode(object) {\n  return hexlify(_encode(object));\n}\n\nfunction _decodeChildren(data, offset, childOffset, length) {\n  const result = [];\n\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n\n    if (childOffset > offset + 1 + length) {\n      logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n  }\n\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n} // returns { consumed: number, result: Object }\n\n\nfunction _decode(data, offset) {\n  if (data.length === 0) {\n    logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n  } // Array with extra length prefix\n\n\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n\n    if (offset + 1 + lengthLength > data.length) {\n      logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n\n    if (offset + 1 + lengthLength + length > data.length) {\n      logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n\n    if (offset + 1 + length > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n\n    if (offset + 1 + lengthLength > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n\n    if (offset + 1 + lengthLength + length > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n\n    if (offset + 1 + length > data.length) {\n      logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n\n  return {\n    consumed: 1,\n    result: hexlify(data[offset])\n  };\n}\n\nexport function decode(data) {\n  const bytes = arrayify(data);\n\n  const decoded = _decode(bytes, 0);\n\n  if (decoded.consumed !== bytes.length) {\n    logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n  }\n\n  return decoded.result;\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { arrayify, hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call(arrayify(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nexport function encode(object) {\n    return hexlify(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\nexport function decode(data) {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}