{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Slab = exports.SLAB_LAYOUT = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst buffer_layout_1 = require(\"buffer-layout\");\n\nconst layout_1 = require(\"./layout\");\n\nconst SLAB_HEADER_LAYOUT = buffer_layout_1.struct([// Number of modified slab nodes\nbuffer_layout_1.u32('bumpIndex'), layout_1.zeros(4), // Linked list of unused nodes\nbuffer_layout_1.u32('freeListLen'), layout_1.zeros(4), buffer_layout_1.u32('freeListHead'), buffer_layout_1.u32('root'), buffer_layout_1.u32('leafCount'), layout_1.zeros(4)], 'header');\nconst SLAB_NODE_LAYOUT = buffer_layout_1.union(buffer_layout_1.u32('tag'), buffer_layout_1.blob(68), 'node');\nSLAB_NODE_LAYOUT.addVariant(0, buffer_layout_1.struct([]), 'uninitialized');\nSLAB_NODE_LAYOUT.addVariant(1, buffer_layout_1.struct([// Only the first prefixLen high-order bits of key are meaningful\nbuffer_layout_1.u32('prefixLen'), layout_1.u128('key'), buffer_layout_1.seq(buffer_layout_1.u32(), 2, 'children')]), 'innerNode');\nSLAB_NODE_LAYOUT.addVariant(2, buffer_layout_1.struct([buffer_layout_1.u8('ownerSlot'), buffer_layout_1.u8('feeTier'), buffer_layout_1.blob(2), layout_1.u128('key'), layout_1.publicKeyLayout('owner'), layout_1.u64('quantity'), layout_1.u64('clientOrderId')]), 'leafNode');\nSLAB_NODE_LAYOUT.addVariant(3, buffer_layout_1.struct([buffer_layout_1.u32('next')]), 'freeNode');\nSLAB_NODE_LAYOUT.addVariant(4, buffer_layout_1.struct([]), 'lastFreeNode');\nexports.SLAB_LAYOUT = buffer_layout_1.struct([SLAB_HEADER_LAYOUT, buffer_layout_1.seq(SLAB_NODE_LAYOUT, buffer_layout_1.offset(SLAB_HEADER_LAYOUT.layoutFor('bumpIndex'), SLAB_HEADER_LAYOUT.offsetOf('bumpIndex') - SLAB_HEADER_LAYOUT.span), 'nodes')]);\n\nclass Slab {\n  constructor(header, nodes) {\n    this.header = header;\n    this.nodes = nodes;\n  }\n\n  static decode(buffer) {\n    return exports.SLAB_LAYOUT.decode(buffer);\n  }\n\n  get(searchKey) {\n    if (this.header.leafCount === 0) {\n      return null;\n    }\n\n    if (!(searchKey instanceof bn_js_1.default)) {\n      searchKey = new bn_js_1.default(searchKey);\n    }\n\n    let index = this.header.root;\n\n    while (true) {\n      const {\n        leafNode,\n        innerNode\n      } = this.nodes[index];\n\n      if (leafNode) {\n        if (leafNode.key.eq(searchKey)) {\n          return leafNode;\n        }\n\n        return null;\n      } else if (innerNode) {\n        if (!innerNode.key.xor(searchKey).iushrn(128 - innerNode.prefixLen).isZero()) {\n          return null;\n        }\n\n        index = innerNode.children[searchKey.testn(128 - innerNode.prefixLen - 1) ? 1 : 0];\n      } else {\n        throw new Error('Invalid slab');\n      }\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.items(false);\n  }\n\n  *items(descending = false) {\n    if (this.header.leafCount === 0) {\n      return;\n    }\n\n    const stack = [this.header.root];\n\n    while (stack.length > 0) {\n      const index = stack.pop();\n      const {\n        leafNode,\n        innerNode\n      } = this.nodes[index];\n\n      if (leafNode) {\n        yield leafNode;\n      } else if (innerNode) {\n        if (descending) {\n          stack.push(innerNode.children[0], innerNode.children[1]);\n        } else {\n          stack.push(innerNode.children[1], innerNode.children[0]);\n        }\n      }\n    }\n  }\n\n}\n\nexports.Slab = Slab;\nlayout_1.setLayoutDecoder(exports.SLAB_LAYOUT, ({\n  header,\n  nodes\n}) => new Slab(header, nodes));","map":{"version":3,"sources":["../src/slab.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Slab = exports.SLAB_LAYOUT = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst buffer_layout_1 = require(\"buffer-layout\");\nconst layout_1 = require(\"./layout\");\nconst SLAB_HEADER_LAYOUT = buffer_layout_1.struct([\n    // Number of modified slab nodes\n    buffer_layout_1.u32('bumpIndex'),\n    layout_1.zeros(4),\n    // Linked list of unused nodes\n    buffer_layout_1.u32('freeListLen'),\n    layout_1.zeros(4),\n    buffer_layout_1.u32('freeListHead'),\n    buffer_layout_1.u32('root'),\n    buffer_layout_1.u32('leafCount'),\n    layout_1.zeros(4),\n], 'header');\nconst SLAB_NODE_LAYOUT = buffer_layout_1.union(buffer_layout_1.u32('tag'), buffer_layout_1.blob(68), 'node');\nSLAB_NODE_LAYOUT.addVariant(0, buffer_layout_1.struct([]), 'uninitialized');\nSLAB_NODE_LAYOUT.addVariant(1, buffer_layout_1.struct([\n    // Only the first prefixLen high-order bits of key are meaningful\n    buffer_layout_1.u32('prefixLen'),\n    layout_1.u128('key'),\n    buffer_layout_1.seq(buffer_layout_1.u32(), 2, 'children'),\n]), 'innerNode');\nSLAB_NODE_LAYOUT.addVariant(2, buffer_layout_1.struct([\n    buffer_layout_1.u8('ownerSlot'),\n    buffer_layout_1.u8('feeTier'),\n    buffer_layout_1.blob(2),\n    layout_1.u128('key'),\n    layout_1.publicKeyLayout('owner'),\n    layout_1.u64('quantity'),\n    layout_1.u64('clientOrderId'),\n]), 'leafNode');\nSLAB_NODE_LAYOUT.addVariant(3, buffer_layout_1.struct([buffer_layout_1.u32('next')]), 'freeNode');\nSLAB_NODE_LAYOUT.addVariant(4, buffer_layout_1.struct([]), 'lastFreeNode');\nexports.SLAB_LAYOUT = buffer_layout_1.struct([\n    SLAB_HEADER_LAYOUT,\n    buffer_layout_1.seq(SLAB_NODE_LAYOUT, buffer_layout_1.offset(SLAB_HEADER_LAYOUT.layoutFor('bumpIndex'), SLAB_HEADER_LAYOUT.offsetOf('bumpIndex') - SLAB_HEADER_LAYOUT.span), 'nodes'),\n]);\nclass Slab {\n    constructor(header, nodes) {\n        this.header = header;\n        this.nodes = nodes;\n    }\n    static decode(buffer) {\n        return exports.SLAB_LAYOUT.decode(buffer);\n    }\n    get(searchKey) {\n        if (this.header.leafCount === 0) {\n            return null;\n        }\n        if (!(searchKey instanceof bn_js_1.default)) {\n            searchKey = new bn_js_1.default(searchKey);\n        }\n        let index = this.header.root;\n        while (true) {\n            const { leafNode, innerNode } = this.nodes[index];\n            if (leafNode) {\n                if (leafNode.key.eq(searchKey)) {\n                    return leafNode;\n                }\n                return null;\n            }\n            else if (innerNode) {\n                if (!innerNode.key\n                    .xor(searchKey)\n                    .iushrn(128 - innerNode.prefixLen)\n                    .isZero()) {\n                    return null;\n                }\n                index =\n                    innerNode.children[searchKey.testn(128 - innerNode.prefixLen - 1) ? 1 : 0];\n            }\n            else {\n                throw new Error('Invalid slab');\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.items(false);\n    }\n    *items(descending = false) {\n        if (this.header.leafCount === 0) {\n            return;\n        }\n        const stack = [this.header.root];\n        while (stack.length > 0) {\n            const index = stack.pop();\n            const { leafNode, innerNode } = this.nodes[index];\n            if (leafNode) {\n                yield leafNode;\n            }\n            else if (innerNode) {\n                if (descending) {\n                    stack.push(innerNode.children[0], innerNode.children[1]);\n                }\n                else {\n                    stack.push(innerNode.children[1], innerNode.children[0]);\n                }\n            }\n        }\n    }\n}\nexports.Slab = Slab;\nlayout_1.setLayoutDecoder(exports.SLAB_LAYOUT, ({ header, nodes }) => new Slab(header, nodes));\n//# sourceMappingURL=slab.js.map"]},"metadata":{},"sourceType":"script"}